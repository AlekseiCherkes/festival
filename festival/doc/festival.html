<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on August, 29 2013 by texi2html 1.70 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>The Festival Speech Synthesis System: Top</title>

<meta name="description" content="The Festival Speech Synthesis System: Top">
<meta name="keywords" content="The Festival Speech Synthesis System: Top">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.70">
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="NOD1"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="settitle">Festival Speech Synthesis System
</h1>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC1">1. Abstract</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            initial comments
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC2">2. Copying</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             How you can copy and share the code
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC3">3. Acknowledgements</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    List of contributors
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC8">4. What is new</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Enhancements since last public release
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr><tr><td align="left" valign="top"><a href="#SEC9">5. Overview</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Generalities and Philosophy
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC12">6. Installation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        Compilation and Installation
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC17">7. Quick start</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         Just tell me what to type
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC21">8. Scheme</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              A quick introduction to Festival's scripting language
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
Text methods for interfacing to Festival
</pre></th></tr><tr><td align="left" valign="top"><a href="#SEC26">9. TTS</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 Text to speech modes
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC30">10. XML/SGML mark-up</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    XML/SGML mark-up Language
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC36">11. Emacs interface</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     Using Festival within Emacs
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
Internal functions
</pre></th></tr><tr><td align="left" valign="top"><a href="#SEC37">12. Phonesets</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Defining and using phonesets
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC38">13. Lexicons</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Building and compiling Lexicons
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC47">14. Utterances</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Existing and defining new utterance types
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
Modules
</pre></th></tr><tr><td align="left" valign="top"><a href="#SEC55">15. Text analysis</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       Tokenizing text
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC61">16. POS tagging</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         Part of speech tagging
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC62">17. Phrase breaks</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       Finding phrase breaks
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC63">18. Intonation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Intonations modules
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC70">19. Duration</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Duration modules
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC75">20. UniSyn synthesizer</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  The UniSyn waveform synthesizer
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC84">21. Diphone synthesizer</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> Building and using diphone synthesizers
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC91">22. Other synthesis methods</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  other waveform synthesis methods
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC95">23. Audio output</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        Getting sound from Festival
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr><tr><td align="left" valign="top"><a href="#SEC96">24. Voices</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Adding new voices (and languages)
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr><tr><td align="left" valign="top"><a href="#SEC109">25. Tools</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               CART, Ngrams etc
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr><tr><td align="left" valign="top"><a href="#SEC115">26. Building models from databases</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
Adding new modules and writing C++ code
</pre></th></tr><tr><td align="left" valign="top"><a href="#SEC119">27. Programming</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         Programming in Festival (Lisp/C/C++)
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC126">28. API</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 Using Festival in other programs
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr><tr><td align="left" valign="top"><a href="#SEC136">29. Examples</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Some simple (and not so simple) examples
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr><tr><td align="left" valign="top"><a href="#SEC139">30. Problems</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Reporting bugs.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC140">31. References</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Other sources of information
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC141">32. Feature functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   List of builtin feature functions.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC142">33. Variable list</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       Short descriptions of all variables
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC143">34. Function list</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       Short descriptions of all functions
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC144">Index</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Index of concepts.
</td></tr>
</table>

<hr size="1">
<a name="NOD2"></a>
<a name="SEC1"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#NOD1" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC2" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[ &lt;&lt; ]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC2" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 1. Abstract </h1>

<p>This document provides a user manual for the Festival
Speech Synthesis System, version 1.4.3.  

</p><p>Festival offers a general framework for building speech synthesis
systems as well as including examples of various modules.  As a whole it
offers full text to speech through a number APIs: from shell level,
though a Scheme command interpreter, as a C++ library, and an Emacs
interface.  Festival is multi-lingual, we have develeoped voices in many
languages including English (UK and US), Spanish and Welsh, though
English is the most advanced.

</p><p>The system is written in C++ and uses the Edinburgh Speech Tools
for low level architecture and has a Scheme (SIOD) based command
interpreter for control.  Documentation is given in the FSF texinfo
format which can generate a printed manual, info files and HTML.

</p><p>The latest details and a full software distribution of the Festival Speech
Synthesis System are available through its home page which may be found
at
</p><table><tr><td>&nbsp;</td><td><pre class="example"><a href="http://www.cstr.ed.ac.uk/projects/festival.html">http://www.cstr.ed.ac.uk/projects/festival.html</a>
</pre></td></tr></table>
<hr size="6">
<a name="NOD3"></a>
<a name="SEC2"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC1" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC3" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC1" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC3" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 2. Copying </h1>

<p>As we feeel the core system has reached an acceptable level of maturity
from 1.4.0 the basic system is released under a free lience, without the
commercial restrictions we imposed on early versions. The basic system
has been placed under an X11 type licence which as free licences go is
pretty free.  No GPL code is included in festival or the speech tools
themselves (though some auxiliary files are GPL'd e.g. the Emacs mode
for Festival).  We have deliberately choosen a licence that should be
compatible with our commercial partners and our free software users.

</p><p>However although the code is free, we still offer no warranties and no
maintenance.  We will continue to endeavor to fix bugs and answer
queries when can, but are not in a position to guarantee it.  We will
consider maintenance contracts and consultancy if desired, please
contacts us for details.

</p><p>Also note that not all the voices and lexicons we distribute with
festival are free.  Particularly the British English lexicon derived
from Oxford Advanced Learners' Dictionary is free only for
non-commercial use (we will release an alternative soon).  Also the
Spanish diphone voice we relase is only free for non-commercial use.

</p><p>If you are using Festival or the speech tools in commercial environment,
even though no licence is required, we would be grateful if you let us
know as it helps justify ourselves to our various sponsors.

</p><p>The current copyright on the core system is
</p><table><tr><td>&nbsp;</td><td><pre class="example">          The Festival Speech Synthesis System: version 1.4.3
                Centre for Speech Technology Research                  
                     University of Edinburgh, UK                       
                      Copyright (c) 1996-2004                            
                        All Rights Reserved.                           
                                                                       
  Permission is hereby granted, free of charge, to use and distribute 
  this software and its documentation without restriction, including  
  without limitation the rights to use, copy, modify, merge, publish, 
  distribute, sublicense, and/or sell copies of this work, and to     
  permit persons to whom this work is furnished to do so, subject to  
  the following conditions:                                           
   1. The code must retain the above copyright notice, this list of   
      conditions and the following disclaimer.                        
   2. Any modifications must be clearly marked as such.               
   3. Original authors' names are not deleted.                        
   4. The authors' names are not used to endorse or promote products  
      derived from this software without specific prior written       
      permission.                                                     
                                                                       
  THE UNIVERSITY OF EDINBURGH AND THE CONTRIBUTORS TO THIS WORK        
  DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING      
  ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT   
  SHALL THE UNIVERSITY OF EDINBURGH NOR THE CONTRIBUTORS BE LIABLE     
  FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES    
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN   
  AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,          
  ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF       
  THIS SOFTWARE.                                                       
</pre></td></tr></table>
<hr size="6">
<a name="NOD4"></a>
<a name="SEC3"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC2" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC4" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC2" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC8" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 3. Acknowledgements </h1>

<p>The code in this system was primarily written by Alan W Black, Paul
Taylor and Richard Caley.  Festival sits on top of the Edinburgh Speech
Tools Library, and uses much of its functionality.

</p><p>Amy Isard wrote a synthesizer for her MSc project in 1995, which first
used the Edinburgh Speech Tools Library.  Although Festival doesn't
contain any code from that system, her system was used as a basic model.

</p><p>Much of the design and philosophy of Festival has been built on the
experience both Paul and Alan gained from the development of various
previous synthesizers and software systems, especially CSTR's Osprey and
Polyglot systems <cite>taylor91</cite> and ATR's CHATR system <cite>black94</cite>.

</p><p>However, it should be stated that Festival is fully developed at CSTR
and contains neither proprietary code or ideas.

</p><p>Festival contains a number of subsystems integrated from other sources
and we acknowledge those systems here.

</p><hr size="6">
<a name="SEC4"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC3" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC5" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC3" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC3" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC8" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 3.1 SIOD </h2>

<p>The Scheme interpreter (SIOD - Scheme In One Defun 3.0) was
written by George Carrett  (gjc@mitech.com, gjc@paradigm.com)
and offers a basic small Scheme (Lisp) interpreter suitable
for embedding in applications such as Festival as a scripting
language.  A number of changes and improvements have been added
in our development but it still remains that basic system.
We are grateful to George and Paradigm Associates Incorporated
for providing such a useful and well-written sub-system.
</p><table><tr><td>&nbsp;</td><td><pre class="example">                       Scheme In One Defun (SIOD)
                       COPYRIGHT (c) 1988-1994 BY 
        PARADIGM ASSOCIATES INCORPORATED, CAMBRIDGE, MASSACHUSETTS.
                           ALL RIGHTS RESERVED

Permission to use, copy, modify, distribute and sell this software
and its documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appear in all copies
and that both that copyright notice and this permission notice appear
in supporting documentation, and that the name of Paradigm Associates
Inc not be used in advertising or publicity pertaining to distribution
of the software without specific, written prior permission.

PARADIGM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
PARADIGM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.
</pre></td></tr></table>
<hr size="6">
<a name="SEC5"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC4" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC6" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC3" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC3" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC8" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 3.2 editline </h2>

<p>Because of conflicts between the copyright for GNU readline, for which
an optional interface was included in earlier versions, we have replace
the interface with a complete command line editing system based on
`<tt>editline</tt>'.  `<tt>Editline</tt>' was posted to the USENET newsgroup
`<tt>comp.sources.misc</tt>' in 1992.  A number of modifications have been
made to make it more useful to us but the original code (contained
within the standard speech tools distribution) and our modifications
fall under the following licence.
</p><table><tr><td>&nbsp;</td><td><pre class="example">Copyright 1992 Simmule Turner and Rich Salz.  All rights reserved.       
                                                                         
This software is not subject to any license of the American Telephone    
and Telegraph Company or of the Regents of the University of California. 
                                                                         
Permission is granted to anyone to use this software for any purpose on  
any computer system, and to alter it and redistribute it freely, subject 
to the following restrictions:                                           
1. The authors are not responsible for the consequences of use of this   
   software, no matter how awful, even if they arise from flaws in it.   
2. The origin of this software must not be misrepresented, either by     
   explicit claim or by omission.  Since few users ever read sources,    
   credits must appear in the documentation.                             
3. Altered versions must be plainly marked as such, and must not be      
   misrepresented as being the original software.  Since few users       
   ever read sources, credits must appear in the documentation.          
4. This notice may not be removed or altered.                            
</pre></td></tr></table>
<hr size="6">
<a name="SEC6"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC5" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC7" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC3" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC3" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC8" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 3.3 Edinburgh Speech Tools Library </h2>

<p>The Edinburgh Speech Tools lies at the core of Festival. Although
developed separately, much of the development of certain parts of the
Edinburgh Speech Tools has been directed by Festival's needs.  In turn
those who have contributed to the Speech Tools make Festival
a more usable system.

</p><p>See <a href="../speechtools/Acknowledgements.html">(speechtools)Acknowledgements</a> section `Acknowledgements' in <cite>Edinburgh Speech Tools Library Manual</cite>.

</p><p>Online information about the Edinburgh Speech Tools library
is available through
</p><table><tr><td>&nbsp;</td><td><pre class="example"><a href="http://www.cstr.ed.ac.uk/projects/speech_tools.html">http://www.cstr.ed.ac.uk/projects/speech_tools.html</a>
</pre></td></tr></table>
<hr size="6">
<a name="SEC7"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC6" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC8" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC3" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC3" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC8" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 3.4 Others </h2>

<p>Many others have provided actual code and support for Festival,
for which we are grateful.  Specifically,

</p><ul>
<li><p> Alistair Conkie:
various low level code points and some design work,
Spanish synthesis, the old diphone synthesis code.
</p></li><li><p> Steve Isard:
directorship and LPC diphone code, design of diphone schema.
</p></li><li><p> EPSRC:
who fund Alan Black and Paul Taylor.
</p></li><li><p> Sun Microsystems Laboratories: 
for supporting the project and funding Richard.
</p></li><li><p> AT&amp;T Labs - Research:
for supporting the project.
</p></li><li><p> Paradigm Associates and George Carrett:
for Scheme in one defun.
</p></li><li><p> Mike Macon:
Improving the quality of the diphone synthesizer and LPC analysis.
</p></li><li><p> Kurt Dusterhoff:
Tilt intonation training and modelling.
</p></li><li><p> Amy Isard:
for her SSML project and related synthesizer.
</p></li><li><p> Richard Tobin:
for answering all those difficult questions, the socket code,
and the XML parser.
</p></li><li><p> Simmule Turner and Rich Salz:
command line editor (editline)
</p></li><li><p> Borja Etxebarria:
Help with the Spanish synthesis
</p></li><li><p> Briony Williams:
Welsh synthesis
</p></li><li><p> Jacques H. de Villiers: `<tt>jacques@cse.ogi.edu</tt>' from CSLU
at OGI, for the TCL interface, and other usability issues
</p></li><li><p> Kevin Lenzo: `<tt>lenzo@cs.cmu.edu</tt>' from CMU for the PERL
interface.
</p></li><li><p> Rob Clarke:
for support under Linux.
</p></li><li><p> Samuel Audet `<tt>guardia@cam.org</tt>':
OS/2 support
</p></li><li><p> Mari Ostendorf:
For providing access to the BU FM Radio corpus from which some 
modules were trained.
</p></li><li><p> Melvin Hunt:
from whose work we based our residual LPC synthesis model on
</p></li><li><p> Oxford Text Archive:
For the computer users version of Oxford Advanced
Learners' Dictionary (redistributed with permission).
</p></li><li><p> Reading University:
for access to MARSEC from which the phrase break
model was trained.
</p></li><li><p> LDC &amp; Penn Tree Bank:
from which the POS tagger was trained, redistribution
of the models is with permission from the LDC.
</p></li><li><p> Roger Burroughes and Kurt Dusterhoff:
For letting us capture their voices.
</p></li><li><p> ATR and Nick Campbell:
for first getting Paul and Alan to work together and for the
experience we gained.
</p></li><li><p> FSF:
for G++, make, .... 
</p></li><li><p> Center for Spoken Language Understanding:
CSLU at OGI, particularly Ron Cole and Mike Macon, have acted as
significant users for the system giving significant feedback and
allowing us to teach courses on Festival offering valuable real-use
feedback.
</p></li><li><p> Our beta testers:
Thanks to all the people who put up with previous versions of the system
and reported bugs, both big and small.  These comments are very important
to the constant improvements in the system.  And thanks for your quick
responses when I had specific requests.
</p></li><li><p> And our users ...
Many people have downloaded earlier versions of the system.  Many have
found problems with installation and use and have reported it to us.
Many of you have put up with multiple compilations trying to fix bugs
remotely.  We thank you for putting up with us and are pleased you've
taken the time to help us improve our system.  Many of you have come up
with uses we hadn't thought of, which is always rewarding.

</p><p>Even if you haven't actively responded, the fact that you use the system
at all makes it worthwhile.
</p></li></ul>

<hr size="6">
<a name="NOD5"></a>
<a name="SEC8"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC7" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC9" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC3" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC9" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 4. What is new </h1>

<p>Compared to the the previous major release (1.3.0 release Aug 1998)
1.4.0 is not functionally so different from its previous versions.
This release is primarily a consolidation release fixing and tidying
up some of the lower level aspects of the system to allow better
modularity for some of our future planned modules.  

</p><ul>
<li><p> Copyright change:
The system is now free and has no commercial restriction.  Note that
currently on the US voices (ked and kal) are also now unrestricted.  The
UK English voices depend on the Oxford Advanced Learners' Dictionary of
Current English which cannot be used for commercial use without
permission from Oxford University Press.

</p></li><li><p> Architecture tidy up:
the interfaces to lower level part parts of the system have been tidied
up deleting some of the older code that was supported for
compatibility reasons.  This is a much higher dependence of features
and easier (and safer) ways to register new objects as feature values
and Scheme objects.  Scheme has been tidied up.  It is no longer
&quot;in one defun&quot; but &quot;in one directory&quot;. 

</p></li><li><p> New documentation system for speech tools:
A new docbook based documentation system has been added to the 
speech tools.  Festival's documentation will will move
over to this sometime soon too.

</p></li><li><p> initial JSAPI support: both JSAPI and JSML (somewhat
similar to Sable) now have initial impelementations.  They of course
depend on Java support which so far we have only (successfully)
investgated under Solaris and Linux.

</p></li><li><p> Generalization of statistical models:  CART, ngrams,
and WFSTs are now fully supported from Lisp and can be used with a 
generalized viterbi function.  This makes adding quite complex statistical
models easy without adding new C++.

</p></li><li><p> Tilt Intonation modelling:
Full support is now included for the Tilt intomation models,
both training and use.

</p></li><li><p> Documentation on Bulding New Voices in Festival:
documentation, scripts etc. for building new voices and languages in
the system, see 
</p><table><tr><td>&nbsp;</td><td><pre class="example"><a href="http://www.cstr.ed.ac.uk/projects/festival/docs/festvox/">http://www.cstr.ed.ac.uk/projects/festival/docs/festvox/</a>
</pre></td></tr></table></li></ul>

<hr size="6">
<a name="NOD6"></a>
<a name="SEC9"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC8" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC10" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC8" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC12" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 5. Overview </h1>

<p>Festival is designed as a speech synthesis system for at least three
levels of user.  First, those who simply want high quality speech from
arbitrary text with the minimum of effort.  Second, those who are
developing language systems and wish to include synthesis output.  In
this case, a certain amount of customization is desired, such as
different voices, specific phrasing, dialog types etc.  The third level
is in developing and testing new synthesis methods.

</p><p>This manual is not designed as a tutorial on converting text to speech
but for documenting the processes and use of our system.  We do not
discuss the detailed algorithms involved in converting text to speech or
the relative merits of multiple methods, though we will often give
references to relevant papers when describing the use of each module.

</p><p>For more general information about text to speech we recommend Dutoit's
`<tt>An introduction to Text-to-Speech Synthesis</tt>' <cite>dutoit97</cite>.  For
more detailed research issues in TTS see <cite>sproat98</cite> or
<cite>vansanten96</cite>.

</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC10">5.1 Philosophy</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Why we did it like it is
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC11">5.2 Future</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              How much better its going to get
</td></tr>
</table>

<hr size="6">
<a name="NOD7"></a>
<a name="SEC10"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC9" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC11" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC9" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC9" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC12" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 5.1 Philosophy </h2>

<p>One of the biggest problems in the development of speech synthesis, and
other areas of speech and language processing systems, is that there are
a lot of simple well-known techniques lying around which can help you
realise your goal.  But in order to improve some part of the whole
system it is necessary to have a whole system in which you can test and
improve your part.  Festival is intended as that whole system in which
you may simply work on your small part to improve the whole.  Without a
system like Festival, before you could even start to test your new
module you would need to spend significant effort to build a whole
system, or adapt an existing one before you could start working on your
improvements.

</p><p>Festival is specifically designed to allow the addition of new
modules, easily and efficiently, so that development need not 
get bogged down in re-implementing the wheel.

</p><p>But there is another aspect of Festival which makes it more useful than
simply an environment for researching into new synthesis techniques.
It is a fully usable text-to-speech system suitable for embedding in
other projects that require speech output.  The provision of a fully
working easy-to-use speech synthesizer in addition to just a testing
environment is good for two specific reasons.  First, it offers a conduit
for our research, in that our experiments can quickly and directly
benefit users of our synthesis system.  And secondly, in ensuring we have
a fully working usable system we can immediately see what problems exist
and where our research should be directed rather where our whims take
us.

</p><p>These concepts are not unique to Festival.  ATR's CHATR system
(<cite>black94</cite>) follows very much the same philosophy and Festival
benefits from the experiences gained in the development of that system.
Festival benefits from various pieces of previous work.  As well as
CHATR, CSTR's previous synthesizers, Osprey and the Polyglot projects
influenced many design decisions.  Also we are influenced by more
general programs in considering software engineering issues, especially
GNU Octave and Emacs on which the basic script model was based.

</p><p>Unlike in some other speech and language systems, software engineering is
considered very important to the development of Festival.  Too often
research systems consist of random collections of hacky little scripts
and code.  No one person can confidently describe the algorithms it
performs, as parameters are scattered throughout the system, with tricks
and hacks making it impossible to really evaluate why the system is good
(or bad).  Such systems do not help the advancement of speech
technology, except perhaps in pointing at ideas that should be further
investigated.  If the algorithms and techniques cannot be described
externally from the program <em>such that</em> they can reimplemented by
others, what is the point of doing the work?

</p><p>Festival offers a common framework where multiple techniques may be 
implemented (by the same or different researchers) so that they may
be tested more fairly in the same environment.

</p><p>As a final word, we'd like to make two short statements which both
achieve the same end but unfortunately perhaps not for the same reasons:
</p><blockquote>
<p>Good software engineering makes good research easier
</p></blockquote>
<p>But the following seems to be true also
</p><blockquote>
<p>If you spend enough effort on something it can be shown to be better
than its competitors.
</p></blockquote>

<hr size="6">
<a name="NOD8"></a>
<a name="SEC11"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC10" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC12" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC9" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC9" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC12" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 5.2 Future </h2>

<p>Festival is still very much in development.  Hopefully this state will
continue for a long time. It is never possible to complete software,
there are always new things that can make it better.  However as time
goes on  Festival's core architecture will stabilise and little or
no changes will be made.  Other aspects of the system will gain
greater attention such as waveform synthesis modules, intonation 
techniques, text type dependent analysers etc.

</p><p>Festival will improve, so don't expected it to be the same six months
from now.

</p><p>A number of new modules and enhancements are already under consideration
at various stages of implementation.  The following is a non-exhaustive
list of what we may (or may not) add to Festival over the
next six months or so.
</p><ul>
<li><p> Selection-based synthesis:
Moving away from diphone technology to more generalized selection
of units for speech database.
</p></li><li><p> New structure for linguistic content of utterances:
Using techniques for Metrical Phonology we are building more structure
representations of utterances reflecting there linguistic significance
better.  This will allow improvements in prosody and unit selection.
</p></li><li><p> Non-prosodic prosodic control:
For language generation systems and custom tasks where the speech
to be synthesized is being generated by some program, more information
about text structure will probably exist, such as phrasing, contrast,
key items etc.   We are investigating the relationship of high-level
tags to prosodic information through the Sole project
<a href="http://www.cstr.ed.ac.uk/projects/sole.html">http://www.cstr.ed.ac.uk/projects/sole.html</a>
</p></li><li><p> Dialect independent lexicons:
Currently for each new dialect we need a new lexicon, we are currently
investigating a form of lexical specification that is dialect independent
that allows the core form to be mapped to different dialects.  This
will make the generation of voices in different dialects much easier.
</p></li></ul>

<hr size="6">
<a name="NOD9"></a>
<a name="SEC12"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC11" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC13" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC9" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC17" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 6. Installation </h1>

<p>This section describes how to install Festival from source in a new
location and customize that installation.

</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC13">6.1 Requirements</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        Software/Hardware requirements for Festival
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC14">6.2 Configuration</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       Setting up compilation
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC15">6.3 Site initialization</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> Settings for your particular site
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC16">6.4 Checking an installation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  But does it work ...
</td></tr>
</table>

<hr size="6">
<a name="NOD10"></a>
<a name="SEC13"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC12" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC14" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC12" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC12" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC17" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 6.1 Requirements </h2>

<p>In order to compile Festival you first need the following
source packages

</p><dl compact="compact">
<dt><code> festival-1.4.3-release.tar.gz</code></dt>
<dd><p>Festival Speech Synthesis System source
</p></dd>
<dt><code> speech_tools-1.2.3-release.tar.gz</code></dt>
<dd><p>The Edinburgh Speech Tools Library 
</p></dd>
<dt><code> festlex_NAME.tar.gz</code></dt>
<dd><a name="IDX1"></a>
<p>The lexicon distribution, where possible, includes the lexicon input
file as well as the compiled form, for your convenience.  The lexicons
have varying distribution policies, but are all free except OALD, which
is only free for non-commercial use (we are working on a free
replacement).  In some cases only a pointer to an ftp'able file plus a
program to convert that file to the Festival format is included.
</p></dd>
<dt><code> festvox_NAME.tar.gz</code></dt>
<dd><p>You'll need a speech database.  A number are available (with varying
distribution policies).  Each voice may have other dependencies such as
requiring particular lexicons
</p></dd>
<dt><code> festdoc_1.4.3.tar.gz</code></dt>
<dd><p>Full postscript, info and html documentation for Festival and the
Speech Tools.  The source of the documentation is available
in the standard distributions but for your conveniences it has
been pre-generated.
</p></dd>
</dl>

<p>In addition to Festival specific sources you will also need

</p><dl compact="compact">
<dt><em> A UNIX machine</em></dt>
<dd><p>Currently we have compiled and tested the system under Solaris (2.5(.1),
2.6, 2.7 and 2.8), SunOS (4.1.3), FreeBSD (3.x, 4.x), Linux (Redhat 4.1,
5.0, 5.1, 5.2, 6.[012], 7.[01], 8.0 and other Linux distributions), and it
should work under OSF (Dec Alphas), SGI (Irix), HPs (HPUX).  But any
standard UNIX machine should be acceptable.  We have now successfully
ported this version to Windows NT and Windows 95 (using the Cygnus GNU
win32 environment).  This is still a young port but seems to work.
</p></dd>
<dt><em> A C++ compiler</em></dt>
<dd><a name="IDX2"></a>
<a name="IDX3"></a>
<a name="IDX4"></a>
<p>Note that C++ is not very portable even between different versions
of the compiler from the same vendor.  Although we've tried very
hard to make the system portable, we know it is very unlikely to
compile without change except with compilers that have already been tested.
The currently tested systems are
</p><ul>
<li><p> Sun Sparc Solaris 2.5, 2.5.1, 2.6, 2.7, 2.9:
GCC 2.95.1, GCC 3.2
</p></li><li><p> FreeBSD for Intel 3.x and 4.x:
GCC 2.95.1, GCC 3.0
</p></li><li><p> Linux for Intel (RedHat 4.1/5.0/5.1/5.2/6.0/7.x/8.0):
GCC 2.7.2, GCC 2.7.2/egcs-1.0.2, egcs 1.1.1, egcs-1.1.2, GCC 2.95.[123],
GCC &quot;2.96&quot;, GCC 3.0, GCC 3.0.1 GCC 3.2 GCC 3.2.1
</p></li><li><p> Windows NT 4.0:
GCC 2.7.2 plus egcs (from Cygnus GNU win32 b19), Visual C++ PRO v5.0,
Visual C++ v6.0
</p></li></ul>
<p>Note if GCC works on one version of Unix it usually works on
others.  

</p><a name="IDX5"></a>
<p>We have compiled both the speech tools and Festival under Windows NT 4.0
and Windows 95 using the GNU tools available from Cygnus.
</p><table><tr><td>&nbsp;</td><td><pre class="example"><a href="ftp://ftp.cygnus.com/pub/gnu-win32/">ftp://ftp.cygnus.com/pub/gnu-win32/</a>.
</pre></td></tr></table>
</dd>
<dt><em> GNU make</em></dt>
<dd><p>Due to there being too many different <code>make</code> programs out there
we have tested the system using GNU make on all systems we use.
Others may work but we know GNU make does.
</p></dd>
<dt><em> Audio hardware</em></dt>
<dd><a name="IDX6"></a>
<p>You can use Festival without audio output hardware but it doesn't sound
very good (though admittedly you can hear less problems with it).  A
number of audio systems are supported (directly inherited from the
audio support in the Edinburgh Speech Tools Library): NCD's NAS
(formerly called netaudio) a network transparent audio system (which can
be found at <a href="ftp://ftp.x.org/contrib/audio/nas/">ftp://ftp.x.org/contrib/audio/nas/</a>);
`<tt>/dev/audio</tt>' (at 8k ulaw and 8/16bit linear), found on Suns, Linux
machines and FreeBSD; and a method allowing arbitrary UNIX
commands. See section <a href="#SEC95">Audio output</a>.
</p></dd>
</dl>

<a name="IDX7"></a>
<a name="IDX8"></a>
<a name="IDX9"></a>
<p>Earlier versions of Festival mistakenly offered a command line editor
interface to the GNU package readline, but due to conflicts with the GNU
Public Licence and Festival's licence this interface was removed in
version 1.3.1.  Even Festival's new free licence would cause problems as
readline support would restrict Festival linking with non-free code.  A
new command line interface based on editline was provided that offers
similar functionality.  Editline remains a compilation option as it is
probably not yet as portable as we would like it to be.

</p><a name="IDX10"></a>
<p>In addition to the above, in order to process the documentation you will
need `<tt>TeX</tt>', `<tt>dvips</tt>' (or similar), GNU's `<tt>makeinfo</tt>' (part
of the texinfo package) and `<tt>texi2html</tt>' which is available from
<a href="http://wwwcn.cern.ch/dci/texi2html/">http://wwwcn.cern.ch/dci/texi2html/</a>.

</p><a name="IDX11"></a>
<p>However the document files are also available pre-processed into,
postscript, DVI, info and html as part of the distribution in
`<tt>festdoc-1.4.X.tar.gz</tt>'.

</p><p>Ensure you have a fully installed and working version of your C++
compiler.  Most of the problems people have had in installing Festival
have been due to incomplete or bad compiler installation.   It
might be worth checking if the following program works if you don't
know if anyone has used your C++ installation before.
</p><table><tr><td>&nbsp;</td><td><pre class="example">#include &lt;iostream.h&gt;
int main (int argc, char **argv)
{
   cout &lt;&lt; &quot;Hello world\n&quot;;
}
</pre></td></tr></table>
<p>Unpack all the source files in a new directory.  The directory
will then contain two subdirectories
</p><table><tr><td>&nbsp;</td><td><pre class="example">speech_tools/
festival/
</pre></td></tr></table>
<hr size="6">
<a name="NOD11"></a>
<a name="SEC14"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC13" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC15" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC12" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC12" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC17" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 6.2 Configuration </h2>

<p>First ensure you have a compiled version of the Edinburgh
Speech Tools Library.  See `<tt>speech_tools/INSTALL</tt>' for 
instructions.

</p><a name="IDX12"></a>
<p>The system now supports the standard GNU `<tt>configure</tt>' method
for set up.  In most cases this will automatically configure festival
for your particular system.  In most cases you need only
type
</p><table><tr><td>&nbsp;</td><td><pre class="example">gmake
</pre></td></tr></table><p>and the system will configure itself and compile, (note you
need to have compiled the Edinburgh Speech Tools
`<tt>speech_tools-1.2.2</tt>' first.

</p><a name="IDX13"></a>
<p>In some case hand configuration is required.  All of the configuration
choices are kept in the file `<tt>config/config</tt>'.

</p><a name="IDX14"></a>
<p>For the most part Festival configuration inherits the configuration from
your speech tools config file (`<tt>../speech_tools/config/config</tt>').
Additional optional modules may be added by adding them to the end of
your config file e.g.
</p><table><tr><td>&nbsp;</td><td><pre class="example">ALSO_INCLUDE += clunits
</pre></td></tr></table><p>Adding and new module here will treat is as a new directory in
the `<tt>src/modules/</tt>' and compile it into the system in the
same way the <code>OTHER_DIRS</code> feature was used in
previous versions.

</p><a name="IDX15"></a>
<a name="IDX16"></a>
<p>If the compilation directory being accessed by NFS or if you use an
automounter (e.g. amd) it is recommend to explicitly set the variable
<code>FESTIVAL_HOME</code> in `<tt>config/config</tt>'. The command <code>pwd</code> is
not reliable when a directory may have multiple names.

</p><p>There is a simple test suite with Festival but it requires the three
basic voices and their respective lexicons installed before it will work.
Thus you need to install
</p><table><tr><td>&nbsp;</td><td><pre class="example">festlex_CMU.tar.gz
festlex_OALD.tar.gz
festlex_POSLEX.tar.gz
festvox_don.tar.gz
festvox_kedlpc16k.tar.gz
festvox_rablpc16k.tar.gz
</pre></td></tr></table><p>If these are installed you can test the installation with
</p><table><tr><td>&nbsp;</td><td><pre class="example">gmake test
</pre></td></tr></table>
<p>To simply make it run with a male US English voice it is 
sufficient to install just
</p><table><tr><td>&nbsp;</td><td><pre class="example">festlex_CMU.tar.gz
festlex_POSLEX.tar.gz
festvox_kallpc16k.tar.gz
</pre></td></tr></table>
<p>Note that the single most common reason for problems in compilation and
linking found amongst the beta testers was a bad installation of GNU
C++.  If you get many strange errors in G++ library header files or link
errors it is worth checking that your system has the compiler, header
files and runtime libraries properly installed.  This may be checked by
compiling a simple program under C++ and also finding out if anyone at
your site has ever used the installation.  Most of these installation
problems are caused by upgrading to a newer version of libg++ without
removing the older version so a mixed version of the `<tt>.h</tt>' files
exist.

</p><p>Although we have tried very hard to ensure that Festival compiles with
no warnings this is not possible under some systems.

</p><a name="IDX17"></a>
<p>Under SunOS the system include files do not declare a number of
system provided functions.  This a bug in Sun's include files.  This
will causes warnings like &quot;implicit definition of fprintf&quot;.  These
are harmless.

</p><a name="IDX18"></a>
<p>Under Linux a warning at link time about reducing the size of some
symbols often is produced.  This is harmless.  There is often
occasional warnings about some socket system function having an
incorrect argument type, this is also harmless.

</p><a name="IDX19"></a>
<p>The speech tools and festival compile under Windows95 or Windows NT
with Visual C++ v5.0 using the Microsoft `<tt>nmake</tt>' make program.  We've
only done this with the Professonal edition, but have no reason to
believe that it relies on anything not in the standard edition.

</p><p>In accordance to VC++ conventions, object files are created with extension
.obj, executables with extension .exe and libraries with extension
.lib. This may mean that both unix and Win32 versions can be built in
the same directory tree, but I wouldn't rely on it.

</p><p>To do this you require nmake Makefiles for the system. These can be
generated from the gnumake Makefiles, using the command
</p><table><tr><td>&nbsp;</td><td><pre class="example">gnumake VCMakefile
</pre></td></tr></table><p>in the speech_tools and festival directories. I have only done this
under unix, it's possible it would work under the cygnus gnuwin32
system. 

</p><p>If `<tt>make.depend</tt>' files exist (i.e. if you have done `<tt>gnumake
depend</tt>' in unix) equivalent `<tt>vc_make.depend</tt>' files will be created, if not
the VCMakefiles will not contain dependency information for the `<tt>.cc</tt>'
files. The result will be that you can compile the system once, but
changes will not cause the correct things to be rebuilt.

</p><p>In order to compile from the DOS command line using Visual C++ you
need to have a collection of environment variables set. In Windows NT
there is an instalation option for Visual C++ which sets these
globally. Under Windows95 or if you don't ask for them to be set
globally under NT you need to run 
</p><table><tr><td>&nbsp;</td><td><pre class="example">vcvars32.bat
</pre></td></tr></table><p>See the VC++ documentation for more details.

</p><p>Once you have the source trees with VCMakefiles somewhere visible from
Windows, you need to copy
`<tt>peech_tools\config\vc_config-dist</tt>' to
`<tt>speech_tools\config\vc_config</tt>' and edit it to suit your
local situation. Then do the same with
`<tt>festival\config\vc_config-dist</tt>'.

</p><p>The thing most likely to need changing is the definition of
<code>FESTIVAL_HOME</code> in `<tt>festival\config\vc_config_make_rules</tt>'
which needs to point to where you have put festival.

</p><p>Now you can compile. cd to the speech_tools directory and do
</p><table><tr><td>&nbsp;</td><td><pre class="example">nmake /nologo /fVCMakefile 
</pre></td></tr></table><p>and the library, the programs in main and the test programs should be
compiled. 

</p><p>The tests can't be run automatically under Windows. A simple test to
check that things are probably OK is:
</p><table><tr><td>&nbsp;</td><td><pre class="example">main\na_play testsuite\data\ch_wave.wav
</pre></td></tr></table><p>which reads and plays a waveform.

</p><p>Next go into the festival directory and do
</p><table><tr><td>&nbsp;</td><td><pre class="example">nmake /nologo /fVCMakefile 
</pre></td></tr></table><p>to build festival. When it's finished, and assuming you have the
voices and lexicons unpacked in the right place, festival should run
just as under unix.

</p><p>We should remind you that the NT/95 ports are still young and there may
yet be problems that we've not found yet.  We only recommend the use the
speech tools and Festival under Windows if you have significant
experience in C++ under those platforms.

</p><a name="IDX20"></a>
<a name="IDX21"></a>
<p>Most of the modules `<tt>src/modules</tt>' are actually optional and the
system could be compiled without them.  The basic set could be reduced
further if certain facilities are not desired.  Particularly:
`<tt>donovan</tt>' which is only required if the donovan voice is used;
`<tt>rxp</tt>' if no XML parsing is required (e.g. Sable); and `<tt>parser</tt>'
if no stochastic paring is required (this parser isn't used for any of
our currently released voices).  Actually even `<tt>UniSyn</tt>' and
`<tt>UniSyn_diphone</tt>' could be removed if some external waveform
synthesizer is being used (e.g. MBROLA) or some alternative one like
`<tt>OGIresLPC</tt>'.  Removing unused modules will make the festival binary
smaller and (potentially) start up faster but don't expect too much.
You can delete these by changing the <code>BASE_DIRS</code> variable in
`<tt>src/modules/Makefile</tt>'.

</p><hr size="6">
<a name="NOD12"></a>
<a name="SEC15"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC14" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC16" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC12" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC12" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC17" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 6.3 Site initialization </h2>

<p>Once compiled Festival may be further customized for particular sites.
At start up time Festival loads the file `<tt>init.scm</tt>' from its
library directory.  This file further loads other necessary files such
as phoneset descriptions, duration parameters, intonation parameters,
definitions of voices etc.  It will also load the files
`<tt>sitevars.scm</tt>' and `<tt>siteinit.scm</tt>' if they exist.  
`<tt>sitevars.scm</tt>' is loaded after the basic Scheme library functions
are loaded but before any of the festival related functions are
loaded.  This file is intended to set various path names before
various subsystems are loaded.  Typically variables such
as <code>lexdir</code> (the directory where the lexicons are held), and
<code>voices_dir</code> (pointing to voice directories) should
be reset here if necessary.

</p><a name="IDX22"></a>
<a name="IDX23"></a>
<a name="IDX24"></a>
<p>The default installation will try to find its lexicons and voices
automatically based on the value of <code>load-path</code> (this is derived
from <code>FESTIVAL_HOME</code> at compilation time or by using the <code>--libdir</code>
at run-time).  If the voices and lexicons have been unpacked into
subdirectories of the library directory (the default) then no site
specific initialization of the above pathnames will be necessary.

</p><p>The second site specific file is `<tt>siteinit.scm</tt>'.  Typical examples
of local initialization are as follows.  The default audio output method
is NCD's NAS system if that is supported as that's what we use normally
in CSTR.  If it is not supported, any hardware specific mode is the
default (e.g. sun16audio, freebas16audio, linux16audio or mplayeraudio).
But that default is just a setting in `<tt>init.scm</tt>'.  If for example
in your environment you may wish the default audio output method to be
8k mulaw through `<tt>/dev/audio</tt>' you should add the following line to
your `<tt>siteinit.scm</tt>' file
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(Parameter.set 'Audio_Method 'sunaudio)
</pre></td></tr></table><p>Note the use of <code>Parameter.set</code> rather than <code>Parameter.def</code>
the second function will not reset the value if it is already set.
Remember that you may use the audio methods <code>sun16audio</code>. 
<code>linux16audio</code> or <code>freebsd16audio</code> only if <code>NATIVE_AUDIO</code>
was selected in `<tt>speech_tools/config/config</tt>' and your are
on such machines.  The Festival variable <code>*modules*</code> contains
a list of all supported functions/modules in a particular installation
including audio support.  Check the value of that variable if things
aren't what you expect.

</p><p>If you are installing on a machine whose audio is not directly supported
by the speech tools library, an external command may be executed to play
a waveform.  The following example is for an imaginary machine that can
play audio files through a program called `<tt>adplay</tt>' with arguments
for sample rate and file type.  When playing waveforms, Festival, by
default, outputs as unheadered waveform in native byte order.  In this
example you would set up the default audio playing mechanism in
`<tt>siteinit.scm</tt>' as follows
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(Parameter.set 'Audio_Method 'Audio_Command)
(Parameter.set 'Audio_Command &quot;adplay -raw -r $SR $FILE&quot;)
</pre></td></tr></table><a name="IDX25"></a>
<a name="IDX26"></a>
<a name="IDX27"></a>
<a name="IDX28"></a>
<a name="IDX29"></a>
<p>For <code>Audio_Command</code> method of playing waveforms Festival supports
two additional audio parameters. <code>Audio_Required_Rate</code> allows you
to use Festivals internal sample rate conversion function to any desired
rate.  Note this may not be as good as playing the waveform at the
sample rate it is originally created in, but as some hardware devices
are restrictive in what sample rates they support, or have naive
resample functions this could be optimal.  The second addition
audio parameter is <code>Audio_Required_Format</code> which can be
used to specify the desired output forms of the file.  The default
is unheadered raw, but this may be any of the values supported by 
the speech tools (including nist, esps, snd, riff, aiff, audlab, raw
and, if you really want it, ascii).  

</p><p>For example suppose you run Festival on a remote machine and are not
running any network audio system and want Festival to copy files back to
your local machine and simply cat them to `<tt>/dev/audio</tt>'.  The
following would do that (assuming permissions for rsh are allowed).
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(Parameter.set 'Audio_Method 'Audio_Command)
;; Make output file ulaw 8k (format ulaw implies 8k)
(Parameter.set 'Audio_Required_Format 'ulaw)
(Parameter.set 'Audio_Command 
 &quot;userhost=`echo $DISPLAY | sed 's/:.*$//'`; rcp $FILE $userhost:$FILE; \
  rsh $userhost \&quot;cat $FILE &gt;/dev/audio\&quot; ; rsh $userhost \&quot;rm $FILE\&quot;&quot;)
</pre></td></tr></table><p>Note there are limits on how complex a command you want to put in the
<code>Audio_Command</code> string directly.  It can get very confusing with respect
to quoting.  It is therefore recommended that once you get past a certain
complexity consider writing a simple shell script and calling it from
the <code>Audio_Command</code> string.

</p><a name="IDX30"></a>
<p>A second typical customization is setting the default speaker.  Speakers
depend on many things but due to various licence (and resource)
restrictions you may only have some diphone/nphone databases available
in your installation.  The function name that is the value of
<code>voice_default</code> is called immediately after `<tt>siteinit.scm</tt>' is
loaded offering the opportunity for you to change it.  In
the standard distribution no change should be required.  If you
download all the distributed voices <code>voice_rab_diphone</code> is
the default voice.  You may change this for a site by adding
the following to `<tt>siteinit.scm</tt>' or per person by changing
your `<tt>.festivalrc</tt>'.  For example if you wish to
change the default voice to the American one <code>voice_ked_diphone</code>
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(set! voice_default 'voice_ked_diphone)
</pre></td></tr></table><p>Note the single quote, and note that unlike in early versions
<code>voice_default</code> is not a function you can call directly.

</p><a name="IDX31"></a>
<a name="IDX32"></a>
<p>A second level of customization is on a per user basis.  After loading
`<tt>init.scm</tt>', which includes `<tt>sitevars.scm</tt>' and
`<tt>siteinit.scm</tt>' for local installation, Festival loads the file
`<tt>.festivalrc</tt>' from the user's home directory (if it exists).  This
file may contain arbitrary Festival commands.    

</p><hr size="6">
<a name="NOD13"></a>
<a name="SEC16"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC15" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC17" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC12" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC12" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC17" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 6.4 Checking an installation </h2>

<p>Once compiled and site initialization is set up you should test 
to see if Festival can speak or not.

</p><p>Start the system
</p><table><tr><td>&nbsp;</td><td><pre class="example">$ bin/festival
Festival Speech Synthesis System 1.4.3:release Jan 2003
Copyright (C) University of Edinburgh, 1996-2003. All rights reserved.
For details type `(festival_warranty)'
festival&gt; ^D
</pre></td></tr></table><p>If errors occur at this stage they are most likely to do
with pathname problems.  If any error messages are printed
about non-existent files check that those pathnames
point to where you intended them to be.  Most of the (default)
pathnames are dependent on the basic library path.  Ensure that
is correct.  To find out what it has been set to, start the
system without loading the init files.
</p><table><tr><td>&nbsp;</td><td><pre class="example">$ bin/festival -q
Festival Speech Synthesis System 1.4.3:release Jan 2003
Copyright (C) University of Edinburgh, 1996-2003. All rights reserved.
For details type `(festival_warranty)'
festival&gt; libdir
&quot;/projects/festival/lib/&quot;
festival&gt; ^D
</pre></td></tr></table><p>This should show the pathname you set in your `<tt>config/config</tt>'.

</p><p>If the system starts with no errors try to synthesize something
</p><table><tr><td>&nbsp;</td><td><pre class="example">festival&gt; (SayText &quot;hello world&quot;)
</pre></td></tr></table><p>Some files are only accessed at synthesis time so this may
show up other problem pathnames.  If it talks, you're in business,
if it doesn't, here are some possible problems.

</p><a name="IDX33"></a>
<p>If you get the error message
</p><table><tr><td>&nbsp;</td><td><pre class="example">Can't access NAS server
</pre></td></tr></table><p>You have selected NAS as the audio output but have no server running on
that machine or your <code>DISPLAY</code> or <code>AUDIOSERVER</code> environment
variable is not set properly for your output device.  Either set these
properly or change the audio output device in `<tt>lib/siteinit.scm</tt>' as
described above.

</p><p>Ensure your audio device actually works the way you think it does.  On
Suns, the audio output device can be switched into a number of different
output modes, speaker, jack, headphones.  If this is set to the wrong
one you may not hear the output.  Use one of Sun's tools to change this
(try `<tt>/usr/demo/SOUND/bin/soundtool</tt>').  Try to find an audio
file independent of Festival and get it to play on your audio.
Once you have done that ensure that the audio output method set in
Festival matches that.

</p><p>Once you have got it talking, test the audio spooling device.
</p><table><tr><td>&nbsp;</td><td><pre class="example">festival&gt; (intro)
</pre></td></tr></table><p>This plays a short introduction of two sentences, spooling the audio
output.

</p><p>Finally exit from Festival (by end of file or <code>(quit)</code>) and test
the script mode with.
</p><table><tr><td>&nbsp;</td><td><pre class="example">$ examples/saytime
</pre></td></tr></table>
<p>A test suite is included with Festival but it makes certain assumptions
about which voices are installed.  It assumes that
<code>voice_rab_diphone</code> (`<tt>festvox_rabxxxx.tar.gz</tt>') is the default
voice and that <code>voice_ked_diphone</code> and <code>voice_don_diphone</code>
(`<tt>festvox_kedxxxx.tar.gz</tt>' and `<tt>festvox_don.tar.gz</tt>') are
installed.  Also local settings in your `<tt>festival/lib/siteinit.scm</tt>'
may affect these tests.  However, after installation it may
be worth trying
</p><table><tr><td>&nbsp;</td><td><pre class="example">gnumake test
</pre></td></tr></table><p>from the `<tt>festival/</tt>' directory.  This will do various tests
including basic utterance tests and tokenization tests.  It also checks
that voices are installed and that they don't interfere with each other.
These tests are primarily regression tests for the developers of
Festival, to ensure new enhancements don't mess up existing supported
features.  They are not designed to test an installation is successful,
though if they run correctly it is most probable the installation has
worked.

</p><hr size="6">
<a name="NOD14"></a>
<a name="SEC17"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC16" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC18" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC12" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC21" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 7. Quick start </h1>

<p>This section is for those who just want to know the absolute basics
to run the system.

</p><a name="IDX34"></a>
<a name="IDX35"></a>
<a name="IDX36"></a>
<p>Festival works in two fundamental modes, <em>command mode</em> and
<em>text-to-speech mode</em> (tts-mode).  In command mode, information (in
files or through standard input) is treated as commands and is
interpreted by a Scheme interpreter.  In tts-mode, information (in files
or through standard input) is treated as text to be rendered as speech.
The default mode is command mode, though this may change in later
versions.

</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC18">7.1 Basic command line options</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC19">7.2 Sample command driven session</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC20">7.3 Getting some help</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="NOD15"></a>
<a name="SEC18"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC17" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC19" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC17" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC17" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC21" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 7.1 Basic command line options </h2>

<p>Festival's basic calling method is as

</p><table><tr><td>&nbsp;</td><td><pre class="lisp">festival [options] file1 file2 ...
</pre></td></tr></table>
<p>Options may be any of the following

</p><dl compact="compact">
<dt><code> -q</code></dt>
<dd><p>start Festival without loading `<tt>init.scm</tt>' or user's 
`<tt>.festivalrc</tt>'
</p></dd>
<dt><code> -b</code></dt>
<dt><code> --batch</code></dt>
<dd><a name="IDX37"></a>
<p>After processing any file arguments do not become interactive
</p></dd>
<dt><code> -i</code></dt>
<dt><code> --interactive</code></dt>
<dd><a name="IDX38"></a>
<p>After processing file arguments become interactive.  This option overrides
any batch argument.
</p></dd>
<dt><code> --tts</code></dt>
<dd><a name="IDX39"></a>
<p>Treat file arguments in text-to-speech mode, causing them to be
rendered as speech rather than interpreted as commands.  When selected
in interactive mode the command line edit functions are not available 
</p></dd>
<dt><code> --command</code></dt>
<dd><a name="IDX40"></a>
<p>Treat file arguments in command mode.  This is the default.
</p></dd>
<dt><code> --language LANG</code></dt>
<dd><a name="IDX41"></a>
<p>Set the default language to <var>LANG</var>.  Currently <var>LANG</var> may be
one of <code>english</code>, <code>spanish</code> or <code>welsh</code> (depending on
what voices are actually available in your installation).
</p></dd>
<dt><code> --server </code></dt>
<dd><p>After loading any specified files go into server mode.  This is
a mode where Festival waits for clients on a known port (the
value of <code>server_port</code>, default is 1314).  Connected
clients may send commands (or text) to the server and expect
waveforms back. See section <a href="#SEC129">Server/client API</a>.  Note server mode
may be unsafe and allow unauthorised access to your
machine, be sure to read the security recommendations in 
<a href="#SEC129">Server/client API</a>
</p></dd>
<dt><code> --script scriptfile</code></dt>
<dd><a name="IDX42"></a>
<a name="IDX43"></a>
<p>Run scriptfile as a Festival script file.  This is similar to 
to <code>--batch</code> but it encapsulates the command line arguments into
the Scheme variables <code>argv</code> and <code>argc</code>, so that Festival
scripts may process their command line arguments just like
any other program.  It also does not load the the basic initialisation
files as sometimes you may not want to do this.  If you wish them,
you should copy the loading sequence from an example Festival
script like `<tt>festival/examples/saytext</tt>'.
</p></dd>
<dt><code> --heap NUMBER</code></dt>
<dd><a name="IDX44"></a>
<a name="IDX45"></a>
<p>The Scheme heap (basic number of Lisp cells) is of a fixed size and
cannot be dynamically increased at run time (this would complicate
garbage collection).  The default size is 210000 which seems to be more
than adequate for most work.  In some of our training experiments where
very large list structures are required it is necessary to increase
this.  Note there is a trade off between size of the heap and time it
takes to garbage collect so making this unnecessarily big is not a good
idea.  If you don't understand the above explanation you almost
certainly don't need to use the option.
</p></dd>
</dl>
<p>In command mode, if the file name starts with a left parenthesis, the
name itself is read and evaluated as a Lisp command.  This is often
convenient when running in batch mode and a simple command is necessary
to start the whole thing off after loading in some other specific files.

</p><hr size="6">
<a name="NOD16"></a>
<a name="SEC19"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC18" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC20" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC17" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC17" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC21" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 7.2 Sample command driven session </h2>

<p>Here is a short session using Festival's command interpreter.

</p><p>Start Festival with no arguments
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">$ festival
Festival Speech Synthesis System 1.4.3:release Dec 2002
Copyright (C) University of Edinburgh, 1996-2002. All rights reserved.
For details type `(festival_warranty)'
festival&gt;
</pre></td></tr></table>
<p>Festival uses the a command line editor based on editline for terminal
input so command line editing may be done with Emacs commands.  Festival
also supports history as well as function, variable name, and file name
completion via the <kbd>TAB</kbd> key.

</p><p>Typing <code>help</code> will give you more information, that is <code>help</code>
without any parenthesis.  (It is actually a variable name whose value is a
string containing help.)

</p><a name="IDX46"></a>
<a name="IDX47"></a>
<p>Festival offers what is called a read-eval-print loop, because
it reads an s-expression (atom or list), evaluates it and prints
the result.  As Festival includes the SIOD Scheme interpreter most
standard Scheme commands work
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">festival&gt; (car '(a d))
a
festival&gt; (+ 34 52)
86
</pre></td></tr></table><p>In addition to standard Scheme commands a number of commands specific to
speech synthesis are included.  Although, as we will see, there are
simpler methods for getting Festival to speak, here are the basic
underlying explicit functions used in synthesizing an utterance.

</p><a name="IDX48"></a>
<a name="IDX49"></a>
<p>Utterances can consist of various types See section <a href="#SEC49">Utterance types</a>,
but the simplest form is plain text.  We can create an utterance
and save it in a variable
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">festival&gt; (set! utt1 (Utterance Text &quot;Hello world&quot;))
#&lt;Utterance 1d08a0&gt;
festival&gt;
</pre></td></tr></table><p>The (hex) number in the return value may be different for your
installation.  That is the print form for utterances.  Their internal
structure can be very large so only a token form is printed.

</p><a name="IDX50"></a>
<p>Although this creates an utterance it doesn't do anything else.
To get a waveform you must synthesize it.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">festival&gt; (utt.synth utt1)
#&lt;Utterance 1d08a0&gt;
festival&gt;
</pre></td></tr></table><a name="IDX51"></a>
<p>This calls various modules, including tokenizing, duration,. intonation
etc.  Which modules are called are defined with respect to the type
of the utterance, in this case <code>Text</code>. It is possible to 
individually call the modules by hand but you just wanted it to talk didn't
you.  So 
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">festival&gt; (utt.play utt1)
#&lt;Utterance 1d08a0&gt;
festival&gt;
</pre></td></tr></table><p>will send the synthesized waveform to your audio device.  You should
hear &quot;Hello world&quot; from your machine.

</p><a name="IDX52"></a>
<p>To make this all easier a small function doing these three steps exists.
<code>SayText</code> simply takes a string of text, synthesizes it and sends it
to the audio device.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">festival&gt; (SayText &quot;Good morning, welcome to Festival&quot;)
#&lt;Utterance 1d8fd0&gt;
festival&gt;
</pre></td></tr></table><p>Of course as history and command line editing are supported <kbd>c-p</kbd>
or up-arrow will allow you to edit the above to whatever you wish.

</p><p>Festival may also synthesize from files rather than simply text.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">festival&gt; (tts &quot;myfile&quot; nil)
nil
festival&gt;
</pre></td></tr></table><a name="IDX53"></a>
<a name="IDX54"></a>
<p>The end of file character <kbd>c-d</kbd> will exit from Festival and
return you to the shell, alternatively the command <code>quit</code> may
be called (don't forget the parentheses).

</p><a name="IDX55"></a>
<a name="IDX56"></a>
<p>Rather than starting the command interpreter, Festival may synthesize
files specified on the command line
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">unix$ festival --tts myfile
unix$
</pre></td></tr></table>
<a name="IDX57"></a>
<a name="IDX58"></a>
<p>Sometimes a simple waveform is required from text that is to be kept and
played at some later time.  The simplest way to do this with festival is
by using the `<tt>text2wave</tt>' program.  This is a festival script that
will take a file (or text from standard input) and produce a single
waveform.  

</p><a name="IDX59"></a>
<p>An example use is
</p><table><tr><td>&nbsp;</td><td><pre class="example">text2wave myfile.txt -o myfile.wav
</pre></td></tr></table><p>Options exist to specify the waveform file type, for example if
Sun audio format is required
</p><table><tr><td>&nbsp;</td><td><pre class="example">text2wave myfile.txt -otype snd -o myfile.wav
</pre></td></tr></table><p>Use `<tt>-h</tt>' on `<tt>text2wave</tt>' to see all options.

</p><hr size="6">
<a name="NOD17"></a>
<a name="SEC20"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC19" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC21" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC17" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC17" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC21" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 7.3 Getting some help </h2>

<p>If no audio is generated then you must check to see if audio is
properly initialized on your machine. See section <a href="#SEC95">Audio output</a>.

</p><p>In the command interpreter <kbd>m-h</kbd> (meta-h) will give you help
on the current symbol before the cursor.  This will be a short
description of the function or variable, how to use it and what
its arguments are.  A listing of all such help strings appears
at the end of this document.  <kbd>m-s</kbd> will synthesize and say
the same information, but this extra function is really just for show.

</p><a name="IDX60"></a>
<p>The lisp function <code>manual</code> will send the appropriate command to an
already running Netscape browser process.  If <code>nil</code> is given as an
argument the browser will be directed to the tables of contents of the
manual.  If a non-nil value is given it is assumed to be a section title
and that section is searched and if found displayed.  For example
</p><table><tr><td>&nbsp;</td><td><pre class="example">festival&gt; (manual &quot;Accessing an utterance&quot;)
</pre></td></tr></table><p>Another related function is <code>manual-sym</code> which given a symbol will
check its documentation string for a cross reference to a manual
section and request Netscape to display it.  This function is 
bound to <kbd>m-m</kbd> and will display the appropriate section for 
the given symbol.

</p><p>Note also that the <kbd>TAB</kbd> key can be used to find out the name
of commands available as can the function <code>Help</code> (remember the
parentheses).

</p><p>For more up to date information on Festival regularly check 
the Festival Home Page at
</p><table><tr><td>&nbsp;</td><td><pre class="example"><a href="http://www.cstr.ed.ac.uk/projects/festival.html">http://www.cstr.ed.ac.uk/projects/festival.html</a>
</pre></td></tr></table>
<p>Further help is available by mailing questions to 
</p><table><tr><td>&nbsp;</td><td><pre class="example">festival-help@cstr.ed.ac.uk
</pre></td></tr></table><p>Although we cannot guarantee the time required to answer you, we 
will do our best to offer help.

</p><a name="IDX61"></a>
<p>Bug reports should be submitted to 
</p><table><tr><td>&nbsp;</td><td><pre class="example">festival-bug@cstr.ed.ac.uk
</pre></td></tr></table>
<p>If there is enough user traffic a general mailing list will be
created so all users may share comments and receive announcements.
In the mean time watch the Festival Home Page for news.

</p><hr size="6">
<a name="NOD18"></a>
<a name="SEC21"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC20" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC22" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC17" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC26" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 8. Scheme </h1>

<p>Many people seem daunted by the fact that Festival uses Scheme as its
scripting language and feel they can't use Festival because they don't
know Scheme.  However most of those same people use Emacs everyday which
also has (a much more complex) Lisp system underneath.  The number of
Scheme commands you actually need to know in Festival is really very
small and you can easily just find out as you go along.  Also people use
the Unix shell often but only know a small fraction of actual commands
available in the shell (or in fact that there even is a distinction
between shell builtin commands and user definable ones).  So take it
easy, you'll learn the commands you need fairly quickly.

</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC22">8.1 Scheme references</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   Places to learn more about Scheme
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC23">8.2 Scheme fundamentals</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> Syntax and semantics
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC24">8.3 Scheme Festival specifics</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC25">8.4 Scheme I/O</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> 
</td></tr>
</table>

<hr size="6">
<a name="NOD19"></a>
<a name="SEC22"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC21" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC23" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC21" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC21" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC26" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 8.1 Scheme references </h2>

<p>If you wish to learn about Scheme in more detail I recommend
the book <cite>abelson85</cite>.

</p><p>The Emacs Lisp documentation is reasonable as it is comprehensive and
many of the underlying uses of Scheme in Festival were influenced
by Emacs.  Emacs Lisp however is not Scheme so there are some
differences.

</p><a name="IDX62"></a>
<p>Other Scheme tutorials and resources available on the Web are
</p><ul>
<li>
<p>The Revised Revised Revised Revised Scheme Report, the document
defining the language is available from 
</p><table><tr><td>&nbsp;</td><td><pre class="example"><a href="http://tinuviel.cs.wcu.edu/res/ldp/r4rs-html/r4rs_toc.html">http://tinuviel.cs.wcu.edu/res/ldp/r4rs-html/r4rs_toc.html</a>
</pre></td></tr></table></li><li>
<p>a Scheme tutorials from the net:
</p><ul>
<li><p> <a href="http://www.cs.uoregon.edu/classes/cis425/schemeTutorial.html">http://www.cs.uoregon.edu/classes/cis425/schemeTutorial.html</a>
</p></li></ul></li><li><p> the Scheme FAQ
</p><ul>
<li><p> <a href="http://www.landfield.com/faqs/scheme-faq/part1/">http://www.landfield.com/faqs/scheme-faq/part1/</a>
</p></li></ul></li></ul>

<hr size="6">
<a name="NOD20"></a>
<a name="SEC23"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC22" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC24" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC21" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC21" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC26" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 8.2 Scheme fundamentals </h2>

<p>But you want more now, don't you, not just be referred to some
other book.  OK here goes.

</p><p><em>Syntax</em>: an expression is an <em>atom</em> or a <em>list</em>.  A 
list consists of a left paren, a number of expressions and right
paren.  Atoms can be symbols, numbers, strings or other special
types like functions, hash tables, arrays, etc.

</p><p><em>Semantics</em>:  All expressions can be evaluated.  Lists are
evaluated as function calls.  When evaluating a list all the
members of the list are evaluated first then the first item (a
function) is called with the remaining items in the list as arguments.
Atoms are evaluated depending on their type: symbols are
evaluated as variables returning their values.  Numbers, strings,
functions, etc. evaluate to themselves.

</p><p>Comments are started by a semicolon and run until end of line.

</p><p>And that's it. There is nothing more to the language that.  But just
in case you can't follow the consequences of that, here are
some key examples.

</p><table><tr><td>&nbsp;</td><td><pre class="lisp">festival&gt; (+ 2 3)
5
festival&gt; (set! a 4)
4
festival&gt; (* 3 a)
12
festival&gt; (define (add a b) (+ a b))
#&lt;CLOSURE (a b) (+ a b)&gt;
festival&gt; (add 3 4)
7
festival&gt; (set! alist '(apples pears bananas))
(apples pears bananas)
festival&gt; (car alist)
apples
festival&gt; (cdr alist)
(pears bananas)
festival&gt; (set! blist (cons 'oranges alist))
(oranges apples pears bananas)
festival&gt; (append alist blist)
(apples pears bananas oranges apples pears bananas)
festival&gt; (cons alist blist)
((apples pears bananas) oranges apples pears bananas)
festival&gt; (length alist)
3
festival&gt; (length (append alist blist))
7
</pre></td></tr></table>
<hr size="6">
<a name="NOD21"></a>
<a name="SEC24"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC23" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC25" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC21" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC21" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC26" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 8.3 Scheme Festival specifics </h2>

<p>There a number of additions to SIOD that are Festival specific though
still part of the Lisp system rather than the synthesis functions per se.

</p><p>By convention if the first statement of a function is a string,
it is treated as a documentation string.  The string will be
printed when help is requested for that function symbol.

</p><a name="IDX63"></a>
<a name="IDX64"></a>
<a name="IDX65"></a>
<p>In interactive mode if the function <code>:backtrace</code> is called (within
parenthesis) the previous stack trace is displayed.  Calling
<code>:backtrace</code> with a numeric argument will display that particular
stack frame in full.  Note that any command other than <code>:backtrace</code>
will reset the trace.  You may optionally call
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(set_backtrace t)
</pre></td></tr></table><p>Which will cause a backtrace to be displayed whenever a Scheme error
occurs. This can be put in your `<tt>.festivalrc</tt>' if you wish.  This
is especially useful when running Festival in non-interactive mode 
(batch or script mode) so that more information is printed when an error
occurs.

</p><a name="IDX66"></a>
<p>A <em>hook</em> in Lisp terms is a position within some piece of code
where a user may specify their own customization.  The notion is used
heavily in Emacs.  In Festival there a number of places where hooks are
used.  A hook variable contains either a function or list of functions
that are to be applied at some point in the processing.  For example the
<code>after_synth_hooks</code> are applied after synthesis has been applied to
allow specific customization such as resampling or modification of the
gain of the synthesized waveform.  The Scheme function
<code>apply_hooks</code> takes a hook variable as argument and an object and
applies the function/list of functions in turn to the object.

</p><a name="IDX67"></a>
<a name="IDX68"></a>
<a name="IDX69"></a>
<p>When an error occurs in either Scheme or within the C++ part of Festival
by default the system jumps to the top level, resets itself and
continues.  Note that errors are usually serious things, pointing to
bugs in parameters or code.  Every effort has been made to ensure
that the processing of text never causes errors in Festival.
However when using Festival as a development system it is often
that errors occur in code.  

</p><p>Sometimes in writing Scheme code you know there is a potential for
an error but you wish to ignore that and continue on to the next
thing without exiting or stopping and returning to the top level.  For
example you are processing a number of utterances from a database and
some files containing the descriptions have errors in them but you
want your processing to continue through every utterance that can
be processed rather than stopping 5 minutes after you gone home after
setting a big batch job for overnight.

</p><a name="IDX70"></a>
<a name="IDX71"></a>
<p>Festival's Scheme provides the function <code>unwind-protect</code> which
allows the catching of errors and then continuing normally.  For example
suppose you have the function <code>process_utt</code> which takes a filename
and does things which you know might cause an error.  You can write the
following to ensure you continue processing even in an error
occurs.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(unwind-protect
 (process_utt filename) 
 (begin
   (format t &quot;Error found in processing %s\n&quot; filename)
   (format t &quot;continuing\n&quot;)))
</pre></td></tr></table><p>The <code>unwind-protect</code> function takes two arguments.  The first is
evaluated and if no error occurs the value returned from that expression
is returned.  If an error does occur while evaluating the first
expression, the second expression is evaluated.  <code>unwind-protect</code>
may be used recursively.  Note that all files opened while evaluating
the first expression are closed if an error occurs.  All global
variables outside the scope of the <code>unwind-protect</code> will be left as
they were set up until the error.  Care should be taken in using this
function but its power is necessary to be able to write robust Scheme
code.

</p><hr size="6">
<a name="NOD22"></a>
<a name="SEC25"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC24" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC26" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC21" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC21" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC26" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 8.4 Scheme I/O </h2>

<p>Different Scheme's may have quite different implementations of 
file i/o functions so in this section we will describe the
basic functions in Festival SIOD regarding i/o.

</p><p>Simple printing to the screen may be achieved with the function
<code>print</code> which prints the given s-expression to the screen.
The printed form is preceded by a new line.  This is often useful
for debugging but isn't really powerful enough for much else.

</p><a name="IDX72"></a>
<a name="IDX73"></a>
<p>Files may be opened and closed and referred to file descriptors
in a direct analogy to C's stdio library.  The SIOD functions
<code>fopen</code> and <code>fclose</code> work in the exactly the same
way as their equivalently named partners in C.

</p><a name="IDX74"></a>
<a name="IDX75"></a>
<p>The <code>format</code> command follows the command of the same name in Emacs
and a number of other Lisps.  C programmers can think of it as
<code>fprintf</code>.  <code>format</code> takes a file descriptor, format string
and arguments to print.  The file description may be a file descriptor
as returned by the Scheme function <code>fopen</code>, it may also be <code>t</code>
which means the output will be directed as standard out
(cf. <code>printf</code>).  A third possibility is <code>nil</code> which will cause
the output to printed to a string which is returned (cf. <code>sprintf</code>).

</p><p>The format string  closely follows the format strings
in ANSI C, but it is not the same.  Specifically the directives
currently supported are, <code>%%</code>, <code>%d</code>, <code>%x</code>,
<code>%s</code>, <code>%f</code>, <code>%g</code> and <code>%c</code>.  All modifiers
for these are also supported.  In addition <code>%l</code> is provided
for printing of Scheme objects as objects.

</p><p>For example
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(format t &quot;%03d %3.4f %s %l %l %l\n&quot; 23 23 &quot;abc&quot; &quot;abc&quot; '(a b d) utt1)
</pre></td></tr></table><p>will produce
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">023 23.0000 abc &quot;abc&quot; (a b d) #&lt;Utterance 32f228&gt;
</pre></td></tr></table><p>on standard output.

</p><a name="IDX76"></a>
<p>When large lisp expressions are printed they are difficult to read
because of the parentheses.  The function <code>pprintf</code> prints an
expression to a file description (or <code>t</code> for standard out).  It
prints so the s-expression is nicely lined up and indented.  This
is often called pretty printing in Lisps.

</p><a name="IDX77"></a>
<a name="IDX78"></a>
<p>For reading input from terminal or file, there is currently no
equivalent to <code>scanf</code>.  Items may only be read as Scheme
expressions.  The command
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(load FILENAME t)
</pre></td></tr></table>
<p>will load all s-expressions in <code>FILENAME</code> and return them,
unevaluated as a list.  Without the third argument  the <code>load</code>
function will load and evaluate each s-expression in the file.

</p><p>To read individual s-expressions use <code>readfp</code>.  For
example
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(let ((fd (fopen trainfile &quot;r&quot;))
      (entry)
      (count 0))
    (while (not (equal? (set! entry (readfp fd)) (eof-val)))
     (if (string-equal (car entry) &quot;home&quot;)
        (set! count (+ 1 count))))
    (fclose fd))
</pre></td></tr></table>
<a name="IDX79"></a>
<a name="IDX80"></a>
<a name="IDX81"></a>
<a name="IDX82"></a>
<p>To convert a symbol whose print name is a number to a number
use <code>parse-number</code>.  This is the equivalent to <code>atof</code>
in C.

</p><p>Note that, all i/o from Scheme input files is assumed to be
basically some form of Scheme data (though can be just numbers,
tokens).  For more elaborate analysis of incoming data it is
possible to use the text tokenization functions which offer
a fully programmable method of reading data.

</p><hr size="6">
<a name="NOD23"></a>
<a name="SEC26"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC25" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC27" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC21" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC30" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 9. TTS </h1>

<p>Festival supports text to speech for raw text files.  If you
are not interested in using Festival in any other way except as
black box for rendering text as speech, the following method
is probably what you want.
</p><table><tr><td>&nbsp;</td><td><pre class="example">festival --tts myfile
</pre></td></tr></table><p>This will say the contents of `<tt>myfile</tt>'.  Alternatively text
may be submitted on standard input
</p><table><tr><td>&nbsp;</td><td><pre class="example">echo hello world | festival --tts
cat myfile | festival --tts
</pre></td></tr></table>
<a name="IDX83"></a>
<p>Festival supports the notion of <em>text modes</em> where the text file
type may be identified, allowing Festival to process the file in an
appropriate way.  Currently only two types are considered stable:
<code>STML</code> and <code>raw</code>, but other types such as <code>email</code>,
<code>HTML</code>, <code>Latex</code>, etc. are being developed and discussed below.
This follows the idea of buffer modes in Emacs where a file's type can
be utilized to best display the text.  Text mode may also be selected
based on a filename's extension.

</p><p>Within the command interpreter the function <code>tts</code> is used
to render files as text; it takes a filename and the text mode 
as arguments.

</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC27">9.1 Utterance chunking</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   From text to utterances
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC28">9.2 Text modes</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Mode specific text analysis 
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC29">9.3 Example text mode</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    An example mode for reading email
</td></tr>
</table>

<hr size="6">
<a name="NOD24"></a>
<a name="SEC27"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC26" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC28" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC26" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC26" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC30" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 9.1 Utterance chunking </h2>

<p>Text to speech works by first tokenizing the file and chunking the
tokens into utterances.  The definition of utterance breaks is
determined by the utterance tree in variable <code>eou_tree</code>.  A default
version is given in `<tt>lib/tts.scm</tt>'.  This uses a decision tree to
determine what signifies an utterance break.  Obviously blank lines are
probably the most reliable, followed by certain punctuation.  The
confusion of the use of periods for both sentence breaks and
abbreviations requires some more heuristics to best guess their
different use.  The following tree is currently used which
works better than simply using punctuation.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(defvar eou_tree 
'((n.whitespace matches &quot;.*\n.*\n\\(.\\|\n\\)*&quot;) ;; 2 or more newlines
  ((1))
  ((punc in (&quot;?&quot; &quot;:&quot; &quot;!&quot;))
   ((1))
   ((punc is &quot;.&quot;)
    ;; This is to distinguish abbreviations vs periods
    ;; These are heuristics
    ((name matches &quot;\\(.*\\..*\\|[A-Z][A-Za-z]?[A-Za-z]?\\|etc\\)&quot;)
     ((n.whitespace is &quot; &quot;)
      ((0))                  ;; if abbrev single space isn't enough for break
      ((n.name matches &quot;[A-Z].*&quot;)
       ((1))
       ((0))))
     ((n.whitespace is &quot; &quot;)  ;; if it doesn't look like an abbreviation
      ((n.name matches &quot;[A-Z].*&quot;)  ;; single space and non-cap is no break
       ((1))
       ((0)))
      ((1))))
    ((0)))))
</pre></td></tr></table><p>The token items this is applied to will always (except in the
end of file case) include one following token, so look ahead is
possible.  The &quot;n.&quot; and &quot;p.&quot; and &quot;p.p.&quot; prefixes allow access to the
surrounding token context.  The features <code>name</code>, <code>whitespace</code>
and <code>punc</code> allow access to the contents of the token itself.  At
present there is no way to access the lexicon form this tree which
unfortunately might be useful if certain abbreviations were identified
as such there.

</p><p>Note these are heuristics and written by hand not trained from data,
though problems have been fixed as they have been observed in data.  The
above rules may make mistakes where abbreviations appear at end of
lines, and when improper spacing and capitalization is used.  This is
probably worth changing, for modes where more casual text appears, such
as email messages and USENET news messages.  A possible improvement
could be made by analysing a text to find out its basic threshold of
utterance break (i.e. if no full stop, two spaces, followed by a
capitalized word sequences appear and the text is of a reasonable length
then look for other criteria for utterance breaks).

</p><p>Ultimately what we are trying to do is to chunk the text into utterances
that can be synthesized quickly and start to play them quickly to
minimise the time someone has to wait for the first sound when starting
synthesis.  Thus it would be better if this chunking were done on
<em>prosodic phrases</em> rather than chunks more similar to linguistic
sentences.  Prosodic phrases are bounded in size, while sentences are
not.

</p><hr size="6">
<a name="NOD25"></a>
<a name="SEC28"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC27" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC29" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC26" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC26" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC30" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 9.2 Text modes </h2>

<p>We do not believe that all texts are of the same type.  Often information
about the general contents of file will aid synthesis greatly.  For
example in Latex files we do not want to here &quot;left brace, backslash e
m&quot; before each emphasized word, nor do we want to necessarily hear
formating commands.  Festival offers a basic method for specifying
customization rules depending on the <em>mode</em> of the text.  By type
we are following the notion of modes in Emacs and eventually will allow
customization at a similar level.

</p><p>Modes are specified as the third argument to the function <code>tts</code>.
When using the Emacs interface to Festival the buffer mode is
automatically passed as the text mode.  If the mode is not supported a
warning message is printed and the raw text mode is used.

</p><p>Our initial text mode implementation allows configuration both in C++
and in Scheme.  Obviously in C++ almost anything can be done but it is
not as easy to reconfigure without recompilation.  Here
we will discuss those modes which can be fully configured at 
run time.

</p><p>A text mode may contain the following
</p><dl compact="compact">
<dt><em> filter</em></dt>
<dd><p>A Unix shell program filter that processes the text file in some 
appropriate way.  For example for email it might remove uninteresting
headers and just output the subject, from line and the message body.
If not specified, an identity filter is used.
</p></dd>
<dt><em> init_function</em></dt>
<dd><p>This (Scheme) function will be called before any processing
will be done.  It allows further set up of tokenization rules
and voices etc.
</p></dd>
<dt><em> exit_function</em></dt>
<dd><p>This (Scheme) function will be called at the end of any processing
allowing reseting of tokenization rules etc.
</p></dd>
<dt><em> analysis_mode</em></dt>
<dd><p>If analysis mode is <code>xml</code> the file is read through the built in XML
parser <code>rxp</code>.  Alternatively if analysis mode is <code>xxml</code> the
filter should an SGML normalising parser and the output is processed in
a way suitable for it.  Any other value is ignored.
</p></dd>
</dl>
<p>These mode specific parameters are specified in the a-list
held in <code>tts_text_modes</code>.

</p><p>When using Festival in Emacs the emacs buffer mode is passed to
Festival as the text mode.

</p><p>Note that above mechanism is not really designed to be re-entrant,
this should be addressed in later versions.

</p><a name="IDX84"></a>
<a name="IDX85"></a>
<p>Following the use of auto-selection of mode in Emacs, Festival can
auto-select the text mode based on the filename given when no explicit
mode is given.  The Lisp variable <code>auto-text-mode-alist</code> is a list
of dotted pairs of regular expression and mode name.  For example
to specify that the <code>email</code> mode is to be used for files ending
in `<tt>.email</tt>' we would add to the current <code>auto-text-mode-alist</code>
as follows
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(set! auto-text-mode-alist
      (cons (cons &quot;\\.email$&quot; 'email) 
            auto-text-mode-alist))
</pre></td></tr></table><p>If the function <code>tts</code> is called with a mode other than <code>nil</code>
that mode overrides any specified by the <code>auto-text-mode-alist</code>.
The mode <code>fundamental</code> is the explicit &quot;null&quot; mode, it is used
when no mode is specified in the function <code>tts</code>, and match
is found in <code>auto-text-mode-alist</code> or the specified mode
is not found.

</p><p>By convention if a requested text model is not found in
<code>tts_text_modes</code> the file `<tt>MODENAME-mode</tt>' will be
<code>required</code>.  Therefore if you have the file
`<tt>MODENAME-mode.scm</tt>' in your library then it will be automatically
loaded on reference.  Modes may be quite large and it is not necessary
have Festival load them all at start up time.

</p><p>Because of the <code>auto-text-mode-alist</code> and the auto loading
of currently undefined text modes you can use Festival like
</p><table><tr><td>&nbsp;</td><td><pre class="example">festival --tts example.email
</pre></td></tr></table><p>Festival with automatically synthesize `<tt>example.email</tt>' in text
mode <code>email</code>.

</p><a name="IDX86"></a>
<p>If you add your own personal text modes you should do the following.
Suppose you've written an HTML mode.  You have named it
`<tt>html-mode.scm</tt>' and put it in `<tt>/home/awb/lib/festival/</tt>'.  In
your `<tt>.festivalrc</tt>' first identify you're personal Festival library
directory by adding it to <code>lib-path</code>.
</p><table><tr><td>&nbsp;</td><td><pre class="example">(set! lib-path (cons &quot;/home/awb/lib/festival/&quot; lib-path))
</pre></td></tr></table><p>Then add the definition to the <code>auto-text-mode-alist</code>
that file names ending `<tt>.html</tt>' or `<tt>.htm</tt>' should
be read in HTML mode.
</p><table><tr><td>&nbsp;</td><td><pre class="example">(set! auto-text-mode-alist
      (cons (cons &quot;\\.html?$&quot; 'html) 
            auto-text-mode-alist))
</pre></td></tr></table><p>Then you may synthesize an HTML file either from Scheme
</p><table><tr><td>&nbsp;</td><td><pre class="example">(tts &quot;example.html&quot; nil)
</pre></td></tr></table><p>Or from the shell command line
</p><table><tr><td>&nbsp;</td><td><pre class="example">festival --tts example.html
</pre></td></tr></table><p>Anyone familiar with modes in Emacs should recognise that the process of
adding a new text mode to Festival is very similar to adding a new
buffer mode to Emacs.

</p><hr size="6">
<a name="NOD26"></a>
<a name="SEC29"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC28" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC30" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC26" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC26" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC30" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 9.3 Example text mode </h2>

<p>Here is a short example of a tts mode for reading email messages.  It
is by no means complete but is a start at showing how you can customize
tts modes without writing new C++ code.

</p><p>The first task is to define a filter that will take a saved mail
message and remove extraneous headers and just leave the from
line, subject and body of the message.  The filter program
is given a file name as its first argument and should output the
result on standard out.  For our purposes we will do this as
a shell script.
</p><table><tr><td>&nbsp;</td><td><pre class="example">#!/bin/sh
#  Email filter for Festival tts mode
#  usage: email_filter mail_message &gt;tidied_mail_message
grep &quot;^From: &quot; $1
echo 
grep &quot;^Subject: &quot; $1
echo
# delete up to first blank line (i.e. the header)
sed '1,/^$/ d' $1
</pre></td></tr></table><p>Next we define the email init function, which will be called 
when we start this mode.  What we will do is save the current
token to words function and slot in our own new one.  We can
then restore the previous one when we exit.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(define (email_init_func)
 &quot;Called on starting email text mode.&quot;
 (set! email_previous_t2w_func token_to_words)
 (set! english_token_to_words email_token_to_words)
 (set! token_to_words email_token_to_words))
</pre></td></tr></table><p>Note that <em>both</em> <code>english_token_to_words</code> and
<code>token_to_words</code> should be set to ensure that our new
token to word function is still used when we change voices.

</p><p>The corresponding end function puts the token to words function 
back.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(define (email_exit_func)
 &quot;Called on exit email text mode.&quot;
 (set! english_token_to_words email_previous_t2w_func)
 (set! token_to_words email_previous_t2w_func))
</pre></td></tr></table><p>Now we can define the email specific token to words function.  In this
example we deal with two specific cases.  First we deal with the common
form of email addresses so that the angle brackets are not pronounced.
The second points are to recognise quoted text and immediately change the 
the speaker to the alternative speaker.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(define (email_token_to_words token name)
  &quot;Email specific token to word rules.&quot;
  (cond
</pre></td></tr></table><p>This first condition identifies the token as a bracketed email address
and removes the brackets and splits the token into name
and IP address.  Note that we recursively call the function
<code>email_previous_t2w_func</code> on the email name and IP address
so that they will be pronounced properly.  Note that because that
function returns a <em>list</em> of words we need to append them together.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">   ((string-matches name &quot;&lt;.*.*&gt;&quot;)
     (append
      (email_previous_t2w_func token
       (string-after (string-before name &quot;@&quot;) &quot;&lt;&quot;))
      (cons 
       &quot;at&quot;
       (email_previous_t2w_func token
        (string-before (string-after name &quot;@&quot;) &quot;&gt;&quot;)))))
</pre></td></tr></table><p>Our next condition deals with identifying a greater than sign being used
as a quote marker.  When we detect this we select the alternative
speaker, even though it may already be selected.  We then return no
words so the quote marker is not spoken.  The following condition finds
greater than signs which are the first token on a line.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">   ((and (string-matches name &quot;&gt;&quot;)
         (string-matches (item.feat token &quot;whitespace&quot;) 
                         &quot;[ \t\n]*\n *&quot;))
    (voice_don_diphone)
    nil ;; return nothing to say
   )
</pre></td></tr></table><p>If it doesn't match any of these we can go ahead and use the builtin
token to words function  Actually, we call the function that was set
before we entered this mode to ensure any other specific rules
still remain.  But before that we need to check if we've had a newline
with doesn't start with a greater than sign.  In that case we
switch back to the primary speaker.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">   (t  ;; for all other cases
     (if (string-matches (item.feat token &quot;whitespace&quot;) 
                         &quot;.*\n[ \t\n]*&quot;)
         (voice_rab_diphone))
     (email_previous_t2w_func token name))))
</pre></td></tr></table><a name="IDX87"></a>
<p>In addition to these we have to actually declare the text mode.
This we do by adding to any existing modes as follows.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(set! tts_text_modes
   (cons
    (list
      'email   ;; mode name
      (list         ;; email mode params
       (list 'init_func email_init_func)
       (list 'exit_func email_exit_func)
       '(filter &quot;email_filter&quot;)))
    tts_text_modes))
</pre></td></tr></table><p>This will now allow simple email messages to be dealt with in a mode
specific way.  

</p><p>An example mail message is included in `<tt>examples/ex1.email</tt>'.  To
hear the result of the above text mode start Festival, load
in the email mode descriptions,  and call TTS on the example file.
</p><table><tr><td>&nbsp;</td><td><pre class="example">(tts &quot;.../examples/ex1.email&quot; 'email)
</pre></td></tr></table>
<p>The above is very short of a real email mode but does illustrate
how one might go about building one.  It should be reiterated
that text modes are new in Festival and their most effective form
has not been discovered yet.  This will improve with time
and experience.

</p><hr size="6">
<a name="NOD27"></a>
<a name="SEC30"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC29" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC31" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC26" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC36" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 10. XML/SGML mark-up </h1>

<p>The ideas of a general, synthesizer system nonspecific, mark-up language
for labelling text has been under discussion for some time.  Festival
has supported an SGML based markup language through multiple versions
most recently STML (<cite>sproat97</cite>).  This is based on the earlier SSML
(Speech Synthesis Markup Language) which was supported by previous
versions of Festival (<cite>taylor96</cite>).  With this version of Festival
we support <em>Sable</em> a similar mark-up language devised by a
consortium from Bell Labls, Sub Microsystems, AT&amp;T and Edinburgh,
<cite>sable98</cite>.  Unlike the previous versions which were SGML based, the
implementation of Sable in Festival is now XML based.  To the user they
different is negligable but using XML makes processing of files easier
and more standardized.  Also Festival now includes an XML parser thus
reducing the dependencies in processing Sable text.

</p><p>Raw text has the problem that it cannot always easily be rendered as
speech in the way the author wishes.  Sable offers a well-defined way of
marking up text so that the synthesizer may render it appropriately.

</p><a name="IDX88"></a>
<a name="IDX89"></a>
<a name="IDX90"></a>
<p>The definition of Sable is by no means settled and is still in
development.  In this release Festival offers people working on Sable
and other XML (and SGML) based markup languages a chance to quickly
experiment with prototypes by providing a DTD (document type
descriptions) and the mapping of the elements in the DTD to Festival
functions.  Although we have not yet (personally) investigated facilities
like cascading style sheets and generalized SGML specification languages
like DSSSL we believe the facilities offer by Festival allow rapid
prototyping of speech output markup languages.

</p><p>Primarily we see Sable markup text as a language that will be generated by
other programs, e.g. text generation systems, dialog managers etc.
therefore a standard, easy to parse, format is required, even if
it seems overly verbose for human writers.

</p><p>For more information of Sable and access to the mailing list see
</p><table><tr><td>&nbsp;</td><td><pre class="example"><a href="http://www.cstr.ed.ac.uk/projects/sable.html">http://www.cstr.ed.ac.uk/projects/sable.html</a>
</pre></td></tr></table>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC31">10.1 Sable example</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          an example of Sable with descriptions
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC32">10.2 Supported Sable tags</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   Currently supported Sable tags
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC33">10.3 Adding Sable tags</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">      Adding new Sable tags
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC34">10.4 XML/SGML requirements</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  Software environment requirements for use
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC35">10.5 Using Sable</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Rendering Sable files as speech
</td></tr>
</table>

<hr size="6">
<a name="NOD28"></a>
<a name="SEC31"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC30" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC32" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC30" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC30" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC36" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 10.1 Sable example </h2>

<p>Here is a simple example of Sable marked up text

</p><table><tr><td>&nbsp;</td><td><pre class="example">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE SABLE PUBLIC &quot;-//SABLE//DTD SABLE speech mark up//EN&quot; 
      &quot;Sable.v0_2.dtd&quot;
[]&gt;
&lt;SABLE&gt;
&lt;SPEAKER NAME=&quot;male1&quot;&gt;

The boy saw the girl in the park &lt;BREAK/&gt; with the telescope.
The boy saw the girl &lt;BREAK/&gt; in the park with the telescope.

Good morning &lt;BREAK /&gt; My name is Stuart, which is spelled
&lt;RATE SPEED=&quot;-40%&quot;&gt;
&lt;SAYAS MODE=&quot;literal&quot;&gt;stuart&lt;/SAYAS&gt; &lt;/RATE&gt;
though some people pronounce it 
&lt;PRON SUB=&quot;stoo art&quot;&gt;stuart&lt;/PRON&gt;.  My telephone number
is &lt;SAYAS MODE=&quot;literal&quot;&gt;2787&lt;/SAYAS&gt;.

I used to work in &lt;PRON SUB=&quot;Buckloo&quot;&gt;Buccleuch&lt;/PRON&gt; Place, 
but no one can pronounce that.

By the way, my telephone number is actually
&lt;AUDIO SRC=&quot;http://www.cstr.ed.ac.uk/~awb/sounds/touchtone.2.au&quot;/&gt;
&lt;AUDIO SRC=&quot;http://www.cstr.ed.ac.uk/~awb/sounds/touchtone.7.au&quot;/&gt;
&lt;AUDIO SRC=&quot;http://www.cstr.ed.ac.uk/~awb/sounds/touchtone.8.au&quot;/&gt;
&lt;AUDIO SRC=&quot;http://www.cstr.ed.ac.uk/~awb/sounds/touchtone.7.au&quot;/&gt;.
&lt;/SPEAKER&gt;
&lt;/SABLE&gt;
</pre></td></tr></table><a name="IDX91"></a>
<a name="IDX92"></a>
<p>After the initial definition of the SABLE tags, through the file
`<tt>Sable.v0_2.dtd</tt>', which is distributed as part of Festival, the
body is given.  There are tags for identifying the language and the
voice.  Explicit boundary markers may be given in text.  Also duration
and intonation control can be explicit specified as can new
pronunciations of words.  The last sentence specifies some external
filenames to play at that point.

</p><hr size="6">
<a name="NOD29"></a>
<a name="SEC32"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC31" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC33" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC30" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC30" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC36" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 10.2 Supported Sable tags </h2>

<p>There is not yet a definitive set of tags but hopefully such a list
will form over the next few months.  As adding support for new tags is
often trivial the problem lies much more in defining what tags there
should be than in actually implementing them.    The following
are based on version 0.2 of Sable as described in 
<a href="http://www.cstr.ed.ac.uk/projects/sable_spec2.html">http://www.cstr.ed.ac.uk/projects/sable_spec2.html</a>, though
some aspects are not currently supported in this implementation.
Further updates will be announces through the Sable mailing list.

</p><dl compact="compact">
<dt><code> LANGUAGE</code></dt>
<dd><p>Allows the specification of the language through the <code>ID</code>
attribute.  Valid values in Festival are, <code>english</code>,
<code>en1</code>, <code>spanish</code>, <code>en</code>, and others depending
on your particular installation.
For example
</p><table><tr><td>&nbsp;</td><td><pre class="example">&lt;LANGUAGE id=&quot;english&quot;&gt; ... &lt;/LANGUAGE&gt;
</pre></td></tr></table><p>If the language isn't supported by the particualr installation of
Festival &quot;Some text in ..&quot; is said instead and the section is
ommitted.
</p></dd>
<dt><code> SPEAKER</code></dt>
<dd><p>Select a voice.  Accepts a parameter <code>NAME</code> which takes values
<code>male1</code>, <code>male2</code>, <code>female1</code>,  etc.  There
is currently no definition about what happens when a voice is selected
which the synthesizer doesn't support.  An example is
</p><table><tr><td>&nbsp;</td><td><pre class="example">&lt;SPEAKER name=&quot;male1&quot;&gt; ... &lt;/SPEAKER&gt;
</pre></td></tr></table></dd>
<dt><code> AUDIO</code></dt>
<dd><p>This allows the specification of an external waveform that is to
be included.  There are attributes for specifying volume and whether
the waveform is to be played in the background of the following
text or not.  Festival as yet only supports insertion.
</p><table><tr><td>&nbsp;</td><td><pre class="example">My telephone number is 
&lt;AUDIO SRC=&quot;http://www.cstr.ed.ac.uk/~awb/sounds/touchtone.2.au&quot;/&gt;
&lt;AUDIO SRC=&quot;http://www.cstr.ed.ac.uk/~awb/sounds/touchtone.7.au&quot;/&gt;
&lt;AUDIO SRC=&quot;http://www.cstr.ed.ac.uk/~awb/sounds/touchtone.8.au&quot;/&gt;
&lt;AUDIO SRC=&quot;http://www.cstr.ed.ac.uk/~awb/sounds/touchtone.7.au&quot;/&gt;.
</pre></td></tr></table></dd>
<dt><code> MARKER</code></dt>
<dd><p>This allows Festival to mark when a particalur part of the text has
been reached.  At present the simply the value of the <code>MARK</code>
attribute is printed.  This is done some when that piece
of text is analyzed. not when it is played.  To use
this in any real application would require changes to this tags
implementation.
</p><table><tr><td>&nbsp;</td><td><pre class="example">Move the &lt;MARKER MARK=&quot;mouse&quot; /&gt; mouse to the top.
</pre></td></tr></table></dd>
<dt><code> BREAK</code></dt>
<dd><p>Specifies a boundary at some <code>LEVEL</code>.  Strength may be values
<code>Large</code>, <code>Medium</code>, <code>Small</code> or a number.  Note that
this this tag is an empty tag and must include the closing part
within itsefl specification.
</p><table><tr><td>&nbsp;</td><td><pre class="example">&lt;BREAK LEVEL=&quot;LARGE&quot;/&gt;
</pre></td></tr></table></dd>
<dt><code> DIV</code></dt>
<dd><p>This signals an division.  In Festival this causes an utterance
break.  A <code>TYPE</code> attribute may be specified but it is ignored
by Festival.
</p></dd>
<dt><code> PRON</code></dt>
<dd><p>Allows pronunciation of enclosed text to be explcitily given.  It
supports the attributes <code>IPA</code> for an IPA specification (not
currently supported by Festival); <code>SUB</code> text to be substituted
which can be in some form of phonetic spelling, and <code>ORIGIN</code> where
the linguistic origin of the enclosed text may be identified to assist
in etymologically sensitive letter to sound rules.
</p><table><tr><td>&nbsp;</td><td><pre class="example">&lt;PRON SUB=&quot;toe maa toe&quot;&gt;tomato&lt;/PRON&gt;
</pre></td></tr></table></dd>
<dt><code> SAYAS</code></dt>
<dd><p>Allows indeitnfication of the enclose tokens/text.  The attribute
<code>MODE</code> cand take any of the following a values: <code>literal</code>,
<code>date</code>, <code>time</code>, <code>phone</code>, <code>net</code>, <code>postal</code>,
<code>currency</code>, <code>math</code>, <code>fraction</code>, <code>measure</code>,
<code>ordinal</code>, <code>cardinal</code>, or <code>name</code>.  Further specification
of type for dates (MDY, DMY etc) may be speficied through the 
<code>MODETYPE</code> attribute.
</p><table><tr><td>&nbsp;</td><td><pre class="example">As a test of marked-up numbers. Here we have 
a year &lt;SAYAS MODE=&quot;date&quot;&gt;1998&lt;/SAYAS&gt;, 
an ordinal &lt;SAYAS MODE=&quot;ordinal&quot;&gt;1998&lt;/SAYAS&gt;, 
a cardinal &lt;SAYAS MODE=&quot;cardinal&quot;&gt;1998&lt;/SAYAS&gt;, 
a literal &lt;SAYAS MODE=&quot;literal&quot;&gt;1998&lt;/SAYAS&gt;, 
and phone number &lt;SAYAS MODE=&quot;phone&quot;&gt;1998&lt;/SAYAS&gt;.
</pre></td></tr></table></dd>
<dt><code> EMPH</code></dt>
<dd><p>To specify enclose text should be emphasized, a <code>LEVEL</code>
attribute may be specified but its value is currently 
ignored by Festival (besides the emphasis Festival generates
isn't very good anyway).
</p><table><tr><td>&nbsp;</td><td><pre class="example">The leaders of &lt;EMPH&gt;Denmark&lt;/EMPH&gt; and &lt;EMPH&gt;India&lt;/EMPH&gt; meet on
Friday.
</pre></td></tr></table></dd>
<dt><code> PITCH</code></dt>
<dd><p>Allows the specification of pitch range, mid and base points.
</p><table><tr><td>&nbsp;</td><td><pre class="example">Without his penguin, &lt;PITCH BASE=&quot;-20%&quot;&gt; which he left at home, &lt;/PITCH&gt;
he could not enter the restaurant.
</pre></td></tr></table></dd>
<dt><code> RATE</code></dt>
<dd><p>Allows the specification of speaking rate
</p><table><tr><td>&nbsp;</td><td><pre class="example">The address is &lt;RATE SPEED=&quot;-40%&quot;&gt; 10 Main Street &lt;/RATE&gt;.
</pre></td></tr></table></dd>
<dt><code> VOLUME</code></dt>
<dd><p>Allows the specification of volume.  Note in festival this
causes an utterance break before and after this tag.
</p><table><tr><td>&nbsp;</td><td><pre class="example">Please speak more &lt;VOLUME LEVEL=&quot;loud&quot;&gt;loudly&lt;/VOLUME&gt;, except
when I ask you to speak &lt;VOLUME LEVEL=&quot;quiet&quot;&gt;in a quiet voice&lt;/VOLUME&gt;.
</pre></td></tr></table></dd>
<dt><code> ENGINE</code></dt>
<dd><p>This allows specification of engine specific commands
</p><table><tr><td>&nbsp;</td><td><pre class="example">An example is &lt;ENGINE ID=&quot;festival&quot; DATA=&quot;our own festival speech
synthesizer&quot;&gt; the festival speech synthesizer&lt;/ENGINE&gt; or
the Bell Labs speech synthesizer.
</pre></td></tr></table></dd>
</dl>

<p>These tags may change in name but they cover the aspects of speech
mark up that we wish to express.  Later additions and changes to these
are expected.

</p><p>See the files `<tt>festival/examples/example.sable</tt>' and
`<tt>festival/examples/example2.sable</tt>' for working examples.

</p><p>Note the definition of Sable is on going and there are likely to be
later more complete implementations of sable for Festival as independent
releases consult `<tt>url://www.cstr.ed.ac.uk/projects/sable.html</tt>' for
the most recent updates.

</p><hr size="6">
<a name="NOD30"></a>
<a name="SEC33"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC32" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC34" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC30" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC30" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC36" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 10.3 Adding Sable tags </h2>

<p>We do not yet claim that there is a fixed standard for Sable tags but
we wish to move towards such a standard.  In the mean time we have
made it easy in Festival to add support for new tags without, in 
general, having to change any of the core functions.

</p><p>Two changes are necessary to add a new tags.  First, change the
definition in `<tt>lib/Sable.v0_2.dtd</tt>', so that Sable files may use it.
The second stage is to make Festival sensitive to that new tag.  The
example in <code>festival/lib/sable-mode.scm</code> shows how a new text mode
may be implemented for an XML/SGML-based markup language.  The basic
point is that an identified function will be called on finding a start
tag or end tags in the document.  It is the tag-function's job to
synthesize the given utterance if the tag signals an utterance boundary.
The return value from the tag-function is the new status of the current
utterance, which may remain unchanged or if the current utterance has
been synthesized <code>nil</code> should be returned signalling a new
utterance.

</p><p>Note the hierarchical structure of the document is not available in this
method of tag-functions.  Any hierarchical state that must be preserved
has to be done using explicit stacks in Scheme.  This is an artifact
due to the cross relationship to utterances and tags (utterances may end
within start and end tags), and the desire to have all specification in
Scheme rather than C++.

</p><p>The tag-functions are defined in an elements list.  They are identified
with names such as &quot;(SABLE&quot; and &quot;)SABLE&quot; denoting start and end tags
respectively.  Two arguments are passed to these tag functions, 
an assoc list of attributes and values as specified in the document
and the current utterances.  If the tag denotes an utterance
break, call <code>xxml_synth</code> on <code>UTT</code> and return <code>nil</code>.
If a tag (start or end) is found in the document and there is no
corresponding tag-function it is ignored.

</p><p>New features may be added to words with a start and end tag by
adding features to the global <code>xxml_word_features</code>.  Any
features in that variable will be added to each word.

</p><p>Note that this method may be used for both XML based lamnguages and SGML
based markup languages (though and external normalizing SGML parser is
required in the SGML case).  The type (XML vs SGML) is identified
by the <code>analysis_type</code> parameter in the tts text mode specification.

</p><hr size="6">
<a name="NOD31"></a>
<a name="SEC34"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC33" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC35" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC30" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC30" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC36" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 10.4 XML/SGML requirements </h2>

<p>Festival is distributed with <code>rxp</code> an XML parser developed
by Richard Tobin of the Language Technology Group, University of
Edinburgh.  Sable is set up as an XML text mode so no
further requirements or external programs are required to synthesize
from Sable marked up text (unlike previous releases).  Note that <code>rxp</code>
is not a full validation parser and hence doesn't check some aspects
of the file (tags within tags).

</p><a name="IDX93"></a>
<a name="IDX94"></a>
<p>Festival still supports SGML based markup but in such cases requires an
external SGML normalizing parser.  We have tested `<tt>nsgmls-1.0</tt>'
which is available as part of the SGML tools set `<tt>sp-1.1.tar.gz</tt>'
which is available from <a href="http://www.jclark.com/sp/index.html">http://www.jclark.com/sp/index.html</a>.
This seems portable between many platforms.

</p><hr size="6">
<a name="NOD32"></a>
<a name="SEC35"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC34" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC36" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC30" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC30" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC36" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 10.5 Using Sable </h2>

<p>Support in Festival for Sable is as a text mode.  In the command
mode use the following to process an Sable file
</p><table><tr><td>&nbsp;</td><td><pre class="example">(tts &quot;file.sable&quot; 'sable)
</pre></td></tr></table>
<p>Also the automatic selection of mode based on file type has been set up
such that files ending `<tt>.sable</tt>' will be automatically synthesized in
this mode.  Thus
</p><table><tr><td>&nbsp;</td><td><pre class="example">festival --tts fred.sable
</pre></td></tr></table><p>Will render `<tt>fred.sable</tt>' as speech in Sable mode.

</p><p>Another way of using Sable is through the Emacs interface.  The
say-buffer command will send the Emacs buffer mode to Festival as
its tts-mode. If the Emacs mode is stml or sgml the file is treated
as an sable file.  See section <a href="#SEC36">Emacs interface</a>.

</p><a name="IDX95"></a>
<a name="IDX96"></a>
<p>Many people experimenting with Sable (and TTS in general) often want all
the waveform output to be saved to be played at a later date.  The
simplest way to do this is using the `<tt>text2wave</tt>' script, It
respects the audo mode selection so 
</p><table><tr><td>&nbsp;</td><td><pre class="example">text2wave fred.sable -o fred.wav
</pre></td></tr></table><p>Note this renders the file a single waveform (done by concatenating
the waveforms for each utterance in the Sable file).  

</p><p>If you wish the waveform for each utterance in a file saved you can
cause the tts process to save the waveforms during synthesis.  A
call to
</p><table><tr><td>&nbsp;</td><td><pre class="example">festival&gt; (save_waves_during_tts)
</pre></td></tr></table><p>Any future call to <code>tts</code> will cause the waveforms to be saved in a
file `<tt>tts_file_xxx.wav</tt>' where `<tt>xxx</tt>' is a number.  A call to
<code>(save_waves_during_tts_STOP)</code> will stop saving the waves.  A
message is printed when the waveform is saved otherwise people forget
about this and wonder why their disk has filled up.

</p><p>This is done by inserting a function in <code>tts_hooks</code>
which saves the wave.  To do other things to each utterances during
TTS (such as saving the utterance structure), try redefining
the function <code>save_tts_output</code> (see <code>festival/lib/tts.scm</code>).

</p><hr size="6">
<a name="NOD33"></a>
<a name="SEC36"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC35" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC37" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC30" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC37" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 11. Emacs interface </h1>

<p>One easy method of using Festival is via an Emacs interface
that allows selection of text regions to be sent to Festival for
rendering as speech.  

</p><a name="IDX97"></a>
<a name="IDX98"></a>
<p>`<tt>festival.el</tt>' offers a new minor mode which offers
an extra menu (in emacs-19 and 20) with options for saying a selected 
region, or a whole buffer, as well as various general control 
functions.  To use this you must install `<tt>festival.el</tt>' in
a directory where Emacs can find it, then add to your 
`<tt>.emacs</tt>' in your home directory the following lines.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(autoload 'say-minor-mode &quot;festival&quot; &quot;Menu for using Festival.&quot; t)
(say-minor-mode t)
</pre></td></tr></table><p>Successive calls to <code>say-minor-mode</code> will toggle the minor
mode, switching the `<samp>say</samp>' menu on and off.

</p><p>Note that the optional voice selection offered by the language sub-menu
is not sensitive to actual voices supported by the your Festival
installation.  Hand customization is require in the `<tt>festival.el</tt>'
file.  Thus some voices may appear in your menu that your Festival
doesn't support and some voices may be supported by your Festival
that do not appear in the menu.

</p><p>When the Emacs Lisp function <code>festival-say-buffer</code> or the
menu equivalent is used the Emacs major mode is passed to Festival
as the text mode.

</p><hr size="6">
<a name="NOD34"></a>
<a name="SEC37"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC36" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC38" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC36" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC38" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 12. Phonesets </h1>

<p>The notion of phonesets is important to a number of different
subsystems within Festival.  Festival supports multiple phonesets
simultaneously and allows mapping between sets when necessary.  The
lexicons, letter to sound rules, waveform synthesizers, etc. all require
the definition of a phoneset before they will operate.

</p><p>A phoneset is a set of symbols which may be further defined in terms
of features, such as vowel/consonant, place of articulation
for consonants, type of vowel etc.  The set of features and
their values must be defined with the phoneset.  The definition
is used to ensure compatibility between sub-systems as well as
allowing groups of phones in various prediction systems (e.g.
duration)

</p><p>A phoneset definition has the form
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">  (defPhoneSet
     NAME
     FEATUREDEFS
     PHONEDEFS )
</pre></td></tr></table><p>The <var>NAME</var> is any unique symbol used e.g. <code>mrpa</code>, <code>darpa</code>,
etc.  <var>FEATUREDEFS</var> is a list of definitions each consisting of
a feature name and its possible values.  For example
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">   (
     (vc + -)             ;; vowel consonant
     (vlength short long diphthong schwa 0)  ;; vowel length 
     ...
   )
</pre></td></tr></table><p>The third section is a list of phone definitions themselves.  Each phone
definition consists of a phone name and the values for each feature in
the order the features were defined in the above section. 

</p><p>A typical example of a phoneset definition can be found in
`<tt>lib/mrpa_phones.scm</tt>'.

</p><a name="IDX99"></a>
<p>Note the phoneset should also include a definition for any silence
phones.  In addition to the definition of the set the silence phone(s)
themselves must also be identified to the system.  This is done through
the command <code>PhoneSet.silences</code>.  In the mrpa set this is done by
the command
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(PhoneSet.silences '(#))
</pre></td></tr></table><p>There may be more than one silence phone (e.g. breath, start silence etc.)
in any phoneset definition.  However the first phone in this set is
treated special and should be canonical silence.  Among other things,
it is this phone that is inserted by the pause prediction module.

</p><a name="IDX100"></a>
<p>In addition to declaring phonesets, alternate sets may be selected
by the command <code>PhoneSet.select</code>.

</p><a name="IDX101"></a>
<a name="IDX102"></a>
<p>Phones in different sets may be automatically mapped between using
their features.  This mapping is not yet as general as it could be,
but is useful when mapping between various phonesets of the same
language.  When a phone needs to be mapped from one set to another
the phone with matching features is selected.  This allows, at least
to some extent, lexicons, waveform synthesizers, duration modules etc.
to use different phonesets (though in general this is not advised).

</p><p>A list of currently defined phonesets is returned by the
function
</p><table><tr><td>&nbsp;</td><td><pre class="example">(PhoneSet.list)
</pre></td></tr></table><p>Note phonesets are often not defined until a voice is actually
loaded so this list is not the list of of sets that are distributed but
the list of sets that are used by currently loaded voices.

</p><p>The name, phones, features and silences of the current phoneset
may be accessedwith the function
</p><table><tr><td>&nbsp;</td><td><pre class="example">(PhoneSet.description nil)
</pre></td></tr></table><p>If the argument to this function is a list, only those parts of
the phoneset description named are returned.  For example
</p><table><tr><td>&nbsp;</td><td><pre class="example">(PhoneSet.description '(silences))
(PhoneSet.description '(silences phones))
</pre></td></tr></table>
<hr size="6">
<a name="NOD35"></a>
<a name="SEC38"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC37" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC39" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC37" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC47" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 13. Lexicons </h1>

<p>A <em>Lexicon</em> in Festival is a subsystem that provides
pronunciations for words.  It can consist of three distinct parts:
an addenda, typically short consisting of hand added words; a
compiled lexicon, typically large (10,000s of words) which sits on
disk somewhere; and a method for dealing with words not in either list.

</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC39">13.1 Lexical entries</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                Format of lexical entries
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC40">13.2 Defining lexicons</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Building new lexicons
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC41">13.3 Lookup process</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 Order of significance
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC42">13.4 Letter to sound rules</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Dealing with unknown words
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC43">13.5 Building letter to sound rules</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> Building rules from data
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC44">13.6 Lexicon requirements</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           What should be in the lexicon
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC45">13.7 Available lexicons</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Current available lexicons
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC46">13.8 Post-lexical rules</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Modification of words in context
</td></tr>
</table>

<hr size="6">
<a name="NOD36"></a>
<a name="SEC39"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC38" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC40" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC38" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC38" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC47" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 13.1 Lexical entries </h2>

<p>Lexical entries consist of three basic parts, a head word, a part of
speech and a pronunciation.  The headword is what you might normally
think of as a word e.g. `<samp>walk</samp>', `<samp>chairs</samp>' etc.  but it might be
any token.  

</p><a name="IDX103"></a>
<a name="IDX104"></a>
<a name="IDX105"></a>
<p>The part-of-speech field currently consist of a simple atom (or nil if
none is specified).  Of course there are many part of speech tag sets
and whatever you mark in your lexicon must be compatible with the
subsystems that use that information.  You can optionally set a part of
speech tag mapping for each lexicon.  The value should be a reverse
assoc-list of the following form
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(lex.set.pos.map 
   '((( punc fpunc) punc)
     (( nn nnp nns nnps ) n)))
</pre></td></tr></table><p>All part of speech tags not appearing in the left hand side of a pos map
are left unchanged.

</p><a name="IDX106"></a>
<p>The third field contains the actual pronunciation of the word.  This
is an arbitrary Lisp S-expression.  In many of the lexicons distributed
with Festival this entry has internal format, identifying syllable
structure, stress markigns and of course the phones themselves.  In
some of our other lexicons we simply list the phones with stress marking
on each vowel.

</p><p>Some typical example entries are

</p><table><tr><td>&nbsp;</td><td><pre class="lisp">( &quot;walkers&quot; n ((( w oo ) 1) (( k @ z ) 0)) )
( &quot;present&quot; v ((( p r e ) 0) (( z @ n t ) 1)) )
( &quot;monument&quot; n ((( m o ) 1) (( n y u ) 0) (( m @ n t ) 0)) )
</pre></td></tr></table>
<a name="IDX107"></a>
<p>Note you may have two entries with the same headword, but different
part of speech fields allow differentiation.  For example

</p><table><tr><td>&nbsp;</td><td><pre class="lisp">( &quot;lives&quot; n ((( l ai v z ) 1)) )
( &quot;lives&quot; v ((( l i v z ) 1)) )
</pre></td></tr></table>
<p>See section <a href="#SEC41">Lookup process</a>, for a description of how multiple entries with the
same headword are used during lookup.

</p><a name="IDX108"></a>
<p>By current conventions, single syllable function words should have no
stress marking, while single syllable content words should be stressed.

</p><p><em>NOTE:</em> the POS field may change in future to contain more complex
formats.  The same lexicon mechanism (but different lexicon) is
used for holding part of speech tag distributions for the POS prediction
module.

</p><hr size="6">
<a name="NOD37"></a>
<a name="SEC40"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC39" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC41" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC38" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC38" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC47" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 13.2 Defining lexicons </h2>

<p>As stated above, lexicons consist of three basic parts (compiled
form, addenda and unknown word method) plus some other declarations.

</p><p>Each lexicon in the system has a name which allows different lexicons to
be selected from efficiently when switching between voices during
synthesis.  The basic steps involved in a lexicon definition are as
follows.

</p><p>First a new lexicon must be created with a new name
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(lex.create &quot;cstrlex&quot;)
</pre></td></tr></table><p>A phone set must be declared for the lexicon, to allow both
checks on the entries themselves and to allow phone mapping between
different phone sets used in the system
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(lex.set.phoneset &quot;mrpa&quot;)
</pre></td></tr></table><p>The phone set must be already declared in the system.

</p><a name="IDX109"></a>
<p>A compiled lexicon, the construction of which is described below,
may be optionally specified
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(lex.set.compile.file &quot;/projects/festival/lib/dicts/cstrlex.out&quot;)
</pre></td></tr></table><a name="IDX110"></a>
<p>The method for dealing with unknown words, See section <a href="#SEC42">Letter to sound rules</a>, may
be set 
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(lex.set.lts.method 'lts_rules)
(lex.set.lts.ruleset 'nrl)
</pre></td></tr></table><p>In this case we are specifying the use of a set of letter to sound rules
originally developed by the U.S. Naval Research Laboratories.  The
default method is to give an error if a word is not found in the addenda
or compiled lexicon.  (This and other options are discussed more fully
below.)

</p><a name="IDX111"></a>
<a name="IDX112"></a>
<p>Finally addenda items may be added for words that are known to 
be common, but not in the lexicon and cannot reasonably be analysed by
the letter to sound rules.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(lex.add.entry 
  '( &quot;awb&quot; n ((( ei ) 1) ((d uh) 1) ((b @ l) 0) ((y uu) 0) ((b ii) 1))))
(lex.add.entry 
  '( &quot;cstr&quot; n ((( s ii ) 1) (( e s ) 1) (( t ii ) 1) (( aa ) 1)) ))
(lex.add.entry 
  '( &quot;Edinburgh&quot; n ((( e m ) 1) (( b r @ ) 0))) ))
</pre></td></tr></table><p>Using <code>lex.add.entry</code> again for the same word and part of speech
will redefine the current pronunciation.  Note these add entries to the
<em>current</em> lexicon so its a good idea to explicitly select the
lexicon before you add addenda entries, particularly if you are doing
this in your own `<tt>.festivalrc</tt>' file.

</p><p>For large lists, compiled lexicons are best.  The function
<code>lex.compile</code> takes two filename arguments, a file name containing
a list of lexical entries and an output file where the compiled lexicon
will be saved.

</p><p>Compilation can take some time and may require lots of memory, as all
entries are loaded in, checked and then sorted before being written out
again.  During compilation if some entry is malformed the reading
process halts with a not so useful message.  Note that if any of your entries
include quote or double quotes the entries will probably be misparsed
and cause such a weird error.  In such cases try setting
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(debug_output t)
</pre></td></tr></table><p>before compilation.  This will print out each entry as it is read in
which should help to narrow down where the error is.

</p><hr size="6">
<a name="NOD38"></a>
<a name="SEC41"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC40" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC42" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC38" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC38" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC47" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 13.3 Lookup process </h2>

<p>When looking up a word, either through the C++ interface, or
Lisp interface, a word is identified by its headword and part of
speech.  If no part of speech is specified, <code>nil</code> is assumed
which matches any part of speech tag.  

</p><p>The lexicon look up process first checks the addenda, if there is 
a full match (head word plus part of speech) it is returned.  If
there is an addenda entry whose head word matches and whose part
of speech is <code>nil</code> that entry is returned.

</p><p>If no match is found in the addenda, the compiled lexicon, if present,
is checked.  Again a match is when both head word and part of speech tag
match, or either the word being searched for has a part of speech
<code>nil</code> or an entry has its tag as <code>nil</code>.  Unlike the addenda,
if no full head word and part of speech tag match is found, the first
word in the lexicon whose head word matches is returned.  The rationale
is that the letter to sound rules (the next defence) are unlikely to be
better than an given alternate pronunciation for a the word but
different part of speech.  Even more so given that as there is an entry
with the head word but a different part of speech this word may have an
unusual pronunciation that the letter to sound rules will have no chance
in producing.

</p><p>Finally if the word is not found in the compiled lexicon it is
passed to whatever method is defined for unknown words.  This
is most likely a letter to sound module.  See section <a href="#SEC42">Letter to sound rules</a>.

</p><a name="IDX113"></a>
<a name="IDX114"></a>
<p>Optional pre- and post-lookup hooks can be specified for a lexicon.
As a single (or list of) Lisp functions.  The pre-hooks will
be called with two arguments (word and features) and should return
a pair (word and features).  The post-hooks will be given a 
lexical entry and should return a lexical entry.  The pre- and
post-hooks do nothing by default.

</p><a name="IDX115"></a>
<p>Compiled lexicons may be created from lists of lexical entries.
A compiled lexicon is <em>much</em> more efficient for look up than the
addenda.  Compiled lexicons use a binary search method while the
addenda is searched linearly.  Also it would take a prohibitively
long time to load in a typical full lexicon as an addenda.  If you
have more than a few hundred entries in your addenda you should
seriously consider adding them to your compiled lexicon.

</p><a name="IDX116"></a>
<a name="IDX117"></a>
<p>Because many publicly available lexicons do not have syllable markings
for entries the compilation method supports automatic syllabification.
Thus for lexicon entries for compilation, two forms for the
pronunciation field are supported: the standard full syllabified and
stressed form and a simpler linear form found in at least the BEEP and
CMU lexicons.  If the pronunciation field is a flat atomic list it is
assumed syllabification is required.

</p><a name="IDX118"></a>
<p>Syllabification is done by finding the minimum sonorant position between
vowels.  It is not guaranteed to be accurate but does give a solution
that is sufficient for many purposes.  A little work would probably
improve this significantly.  Of course syllabification requires the
entry's phones to be in the current phone set.  The sonorant values are
calculated from the <em>vc</em>, <em>ctype</em>, and <em>cvox</em> features
for the current phoneset.  See
`<tt>src/arch/festival/Phone.cc:ph_sonority()</tt>' for actual definition.

</p><p>Additionally in this flat structure vowels (atoms starting with a, e, i,
o or u) may have 1 2 or 0 appended marking stress.  This is again
following the form found in the BEEP and CMU lexicons.

</p><p>Some example entries in the flat form (taken from BEEP) are
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(&quot;table&quot; nil (t ei1 b l))
(&quot;suspicious&quot; nil (s @ s p i1 sh @ s))
</pre></td></tr></table>
<p>Also if syllabification is required there is an opportunity to run a set
of &quot;letter-to-sound&quot;-rules on the input (actually an arbitrary re-write
rule system).  If the variable <code>lex_lts_set</code> is set, the lts
ruleset of that name is applied to the flat input before
syllabification.  This allows simple predictable changes such as
conversion of final r into longer vowel for English RP from
American labelled lexicons.

</p><a name="IDX119"></a>
<p>A list of all matching entries in the addenda and the compiled lexicon
may be found by the function <code>lex.lookup_all</code>.  This function takes
a word and returns all matching entries irrespective of part of speech.

</p><a name="IDX120"></a>
<a name="IDX121"></a>
<p>You can optionally intercept the words as they are looked up, and after
they have been found through <code>pre_hooks</code> and <code>post_hooks</code> for
each lexicon.  This allows a function or list of functions to be applied
to a word and feature before lookup or to the resulting entry after
lookup.  The following example shows how to add voice specific entries
to a general lexicon without affecting other voices that use that
lexicon.

</p><p>For example suppose we were trying to use a Scottish English voice with
the US English (cmu) lexicon.  A number of entries will be
inappropriate but we can redefine some entries thus
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(set! cmu_us_awb::lexicon_addenda
      '(
	(&quot;edinburgh&quot; n (((eh d) 1) ((ax n) 0) ((b r ax) 0)))
	(&quot;poem&quot; n (((p ow) 1) ((y ax m) 0)))
	(&quot;usual&quot; n (((y uw) 1) ((zh ax l) 0)))
	(&quot;air&quot; n (((ey r) 1)))
	(&quot;hair&quot; n (((hh ey r) 1)))
	(&quot;fair&quot; n (((f ey r) 1)))
	(&quot;chair&quot; n (((ch ey r) 1)))))
</pre></td></tr></table><p>We can then define a function that checks to see if the word looked
up is in the speaker specific exception list and use that entry
instead.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(define (cmu_us_awb::cmu_lookup_post entry)
  &quot;(cmu_us_awb::cmu_lookup_post entry)
Speaker specific lexicon addeda.&quot;
  (let ((ne 
	 (assoc_string (car entry) cmu_us_awb::lexicon_addenda)))
    (if ne
	ne
	entry)))
</pre></td></tr></table><p>And then for the particular voice set up we need to
add both a selection part <em>and</em> a reset part.  Thus following
the FestVox conventions for voice set up.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(define (cmu_us_awb::select_lexicon)

    ...
    (lex.select &quot;cmu&quot;)
    ;; Get old var for reset and to append our function to is
    (set! cmu_us_awb::old_cmu_post_hooks 
       (lex.set.post_hooks nil))
    (lex.set.post_hooks
       (append cmu_us_awb::old_cmu_post_hooks
               (list cmu_us_awb::cmu_lookup_post)))
    ...
)

...

(define (cmu_us_awb::reset_lexicon)

  ...
  ;; reset CMU's post_hooks back to original
  (lex.set.post_hooks cmu_us_awb::old_cmu_post_hooks)
  ...

)
</pre></td></tr></table><p>The above isn't the most efficient way as the word is looked up first
then it is checked with the speaker specific list.

</p><p>The <code>pre_hooks</code> functions are called with two arguments, the
word and features, they should return a pair of word and features.

</p><hr size="6">
<a name="NOD39"></a>
<a name="SEC42"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC41" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC43" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC38" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC38" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC47" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 13.4 Letter to sound rules </h2>

<p>Each lexicon may define what action to take when a word cannot
be found in the addenda or the compiled lexicon.  There are
a number of options which will hopefully be added to as more
general letter to sound rule systems are added.

</p><a name="IDX122"></a>
<p>The method is set by the command
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(lex.set.lts.method METHOD)
</pre></td></tr></table><p>Where <var>METHOD</var> can be any of the following
</p><dl compact="compact">
<dt>`<samp> Error</samp>'</dt>
<dd><p>Throw an error when an unknown word is found (default).
</p></dd>
<dt>`<samp> lts_rules</samp>'</dt>
<dd><p>Use externally specified set of letter to sound rules (described 
below).  The name of the rule set to use is defined with the 
<code>lex.lts.ruleset</code> function.  This method runs one
set of rules on an exploded form of the word and assumes the rules
return a list of phonemes (in the appropriate set).  If multiple
instances of rules are required use the <code>function</code> method
described next.
</p></dd>
<dt>`<samp> none</samp>'</dt>
<dd><p>This returns an entry with a <code>nil</code> pronunciation field.  This will
only be valid in very special circumstances.
</p></dd>
<dt>`<samp> FUNCTIONNAME</samp>'</dt>
<dd><p>Call this as a LISP function function name.    This function
is given two arguments: the word and the part of speech.  It should
return a valid lexical entry.
</p></dd>
</dl>

<p>The basic letter to sound rule system is very simple but is
powerful enough to build reasonably complex letter to sound rules.
Although we've found trained LTS rules better than hand written 
ones (for complex languages) where no data is available and rules
must be hand written the following rule formalism is much easier to
use than that generated by the LTS training system (described
in the next section).

</p><a name="IDX123"></a>
<a name="IDX124"></a>
<p>The basic form of a rule is as follows
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">( LEFTCONTEXT [ ITEMS ] RIGHTCONTEXT = NEWITEMS )
</pre></td></tr></table><p>This interpretation is that if <var>ITEMS</var> appear in the specified right
and left context then the output string is to contain <var>NEWITEMS</var>.
Any of <var>LEFTCONTEXT</var>, <var>RIGHTCONTEXT</var> or <var>NEWITEMS</var> may be
empty.  Note that <var>NEWITEMS</var> is written to a different &quot;tape&quot; and hence
cannot feed further rules (within this ruleset).  An example is
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">( # [ c h ] C = k )
</pre></td></tr></table><p>The special character <code>#</code> denotes a word boundary, and the symbol
<code>C</code> denotes the set of all consonants, sets are declared before
rules.  This rule states that a <code>ch</code> at the start of a word
followed by a consonant is to be rendered as the <code>k</code> phoneme.
Symbols in contexts may be followed by the symbol <code>*</code> for zero or
more occurrences, or <code>+</code> for one or more occurrences.

</p><p>The symbols in the rules are treated as set names if they are declared
as such or as symbols in the input/output alphabets.  The symbols
may be more than one character long and the names are case sensitive.

</p><p>The rules are tried in order until one matches the first (or more)
symbol of the tape.  The rule is applied adding the right hand side to
the output tape.  The rules are again applied from the start of the list
of rules.

</p><p>The function used to apply a set of rules if given an atom will explode
it into a list of single characters, while if given a list will use it
as is.  This reflects the common usage of wishing to re-write the
individual letters in a word to phonemes but without excluding the
possibility of using the system for more complex manipulations,
such as multi-pass LTS systems and phoneme conversion.

</p><p>From lisp there are three basic access functions, there
are corresponding functions in the C/C++ domain.

</p><dl compact="compact">
<dt><code> (lts.ruleset NAME SETS RULES)</code></dt>
<dd><p>Define a new set of lts rules.  Where <code>NAME</code> is the name for this
rule, SETS is a list of set definitions of the form <code>(SETNAME e0 e1
...)</code>  and <code>RULES</code> are a list of rules as described above.
</p></dd>
<dt><code> (lts.apply WORD RULESETNAME)</code></dt>
<dd><p>Apply the set of rules named <code>RULESETNAME</code> to <code>WORD</code>.  If
<code>WORD</code> is a symbol it is exploded into a list of the individual
characters in its print name.  If <code>WORD</code> is a list it is used as
is.  If the rules cannot be successfully applied an error is given.  The
result of (successful) application is returned in a list.
</p></dd>
<dt><code> (lts.check_alpha WORD RULESETNAME)</code></dt>
<dd><p>The symbols in <code>WORD</code> are checked against the input alphabet of the
rules named <code>RULESETNAME</code>.  If they are all contained in that
alphabet <code>t</code> is returned, else <code>nil</code>.  Note this does not
necessarily mean the rules will successfully apply (contexts may restrict
the application of the rules), but it allows general checking like
numerals, punctuation etc, allowing application of appropriate rule
sets.
</p></dd>
</dl>

<p>The letter to sound rule system may be used directly from Lisp
and can easily be used to do relatively complex operations for 
analyzing words without requiring modification of the C/C++
system.  For example the Welsh letter to sound rule system consists
or three rule sets, first to explicitly identify epenthesis, then
identify stressed vowels, and finally rewrite this augmented
letter string to phonemes.  This is achieved by
the following function
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(define (welsh_lts word features)
  (let (epen str wel)
    (set! epen (lts.apply (downcase word) 'newepen))
    (set! str (lts.apply epen 'newwelstr))
    (set! wel (lts.apply str 'newwel))
    (list word
          nil
          (lex.syllabify.phstress wel))))
</pre></td></tr></table><p>The LTS method for the Welsh lexicon is set to <code>welsh_lts</code>, so this
function is called when a word is not found in the lexicon.  The
above function first downcases the word and then applies the rulesets in
turn, finally calling the syllabification process and returns a
constructed lexically entry.

</p><hr size="6">
<a name="NOD40"></a>
<a name="SEC43"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC42" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC44" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC38" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC38" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC47" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 13.5 Building letter to sound rules </h2>

<p>As writing letter to sound rules by hand is hard and very time
consuming, an alternative method is also available where a latter to
sound system may be built from a lexicon of the language.  This
technique has successfully been used from English (British and American),
French and German.  The difficulty and appropriateness of using
letter to sound rules is very language dependent,  

</p><p>The following outlines the processes involved in building a letter to
sound model for a language given a large lexicon of pronunciations.
This technique is likely to work for most European languages (including
Russian) but doesn't seem particularly suitable for very language
alphabet languages like Japanese and Chinese.  The process described
here is not (yet) fully automatic but the hand intervention required is
small and may easily be done even by people with only a very little
knowledge of the language being dealt with.

</p><p>The process involves the following steps
</p><ul>
<li> 
<p>Pre-processing lexicon into suitable training set
</p></li><li>
<p>Defining the set of allowable pairing of letters to phones.  (We intend
to do this fully automatically in future versions).
</p></li><li>
<p>Constructing the probabilities of each letter/phone pair.
</p></li><li>
<p>Aligning letters to an equal set of phones/_epsilons_.
</p></li><li> 
<p>Extracting the data by letter suitable for training.
</p></li><li>
<p>Building CART models for predicting phone from letters (and context).
</p></li><li>
<p>Building additional lexical stress assignment model (if necessary).
</p></li></ul>
<p>All except the first two stages of this are fully automatic.

</p><p>Before building a model its wise to think a little about what you want
it to do.  Ideally the model is an auxiluary to the lexicon so only
words not found in the lexicon will require use of the letter to sound
rules.  Thus only unusual forms are likely to require the rules.  More
precisely the most common words, often having the most non-standard
pronunciations, should probably be explicitly listed always.  It is
possible to reduce the size of the lexicon (sometimes drastically) by
removing all entries that the training LTS model correctly predicts.

</p><p>Before starting it is wise to consider removing some entries from the
lexicon before training, I typically will remove words under 4 letters
and if part of speech information is available I remove all function
words, ideally only training from nouns verbs and adjectives as these
are the most likely forms to be unknown in text.  It is useful to have
morphologically inflected and derived forms in the training set as it is
often such variant forms that not found in the lexicon even though their
root morpheme is.  Note that in many forms of text, proper names are the
most common form of unknown word and even the technique presented here
may not adequately cater for that form of unknown words (especially if
they unknown words are non-native names).  This is all stating that this
may or may not be appropriate for your task but the rules generated by
this learning process have in the examples we've done been much better
than what we could produce by hand writing rules of the form described
in the previous section.

</p><p>First preprocess the lexicon into a file of lexical entries to be used
for training, removing functions words and changing the head words to
all lower case (may be language dependent).  The entries should be of
the form used for input for Festival's lexicon compilation.  Specifical
the pronunciations should be simple lists of phones (no
syllabification).  Depending on the language, you may wish to remve the
stressing--for examples here we have though later tests suggest that we
should keep it in even for English.  Thus the training set should look
something like
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(&quot;table&quot; nil (t ei b l))
(&quot;suspicious&quot; nil (s @ s p i sh @ s))
</pre></td></tr></table><p>It is best to split the data into a training set and a test set 
if you wish to know how well your training has worked.  In our
tests we remove every tenth entry and put it in a test set.  Note this
will mean our test results are probably better than if we removed
say the last ten in every hundred.

</p><p>The second stage is to define the set of allowable letter to phone
mappings irrespective of context.  This can sometimes be initially done
by hand then checked against the training set.  Initially constract a
file of the form
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(require 'lts_build)
(set! allowables 
      '((a _epsilon_)
        (b _epsilon_)
        (c _epsilon_)
        ...
        (y _epsilon_)
        (z _epsilon_)
        (# #)))
</pre></td></tr></table><p>All letters that appear in the alphabet should (at least) map to
<code>_epsilon_</code>, including any accented characters that appear in that
language.  Note the last two hashes.  These are used by to denote
beginning and end of word and are automatically added during training,
they must appear in the list and should only map to themselves.

</p><p>To incrementally add to this allowable list run festival as
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">festival allowables.scm 
</pre></td></tr></table><p>and at the prompt type
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">festival&gt; (cummulate-pairs &quot;oald.train&quot;)
</pre></td></tr></table><p>with your train file.  This will print out each lexical entry
that couldn't be aligned with the current set of allowables.  At the
start this will be every entry.  Looking at these entries add 
to the allowables to make alignment work.  For example if the
following word fails
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(&quot;abate&quot; nil (ah b ey t)) 
</pre></td></tr></table><p>Add <code>ah</code> to the allowables for letter <code>a</code>, <code>b</code> to
<code>b</code>, <code>ey</code> to <code>a</code> and <code>t</code> to letter <code>t</code>.  After
doing that restart festival and call <code>cummulate-pairs</code> again.
Incrementally add to the allowable pairs until the number of failures
becomes accceptable.  Often there are entries for which there is no real
relationship between the letters and the pronunciation such as in
abbreviations and foreign words (e.g. &quot;aaa&quot; as &quot;t r ih p ax l ey&quot;).  For
the lexicons I've used the technique on less than 10 per thousand fail
in this way.

</p><p>It is worth while being consistent on defining your set of allowables.
(At least) two mappings are possible for the letter sequence
<code>ch</code>--having letter <code>c</code> go to phone <code>ch</code> and letter
<code>h</code> go to <code>_epsilon_</code> and also letter <code>c</code> go to phone
<code>_epsilon_</code> and letter <code>h</code> goes to <code>ch</code>.  However only
one should be allowed, we preferred <code>c</code> to <code>ch</code>.  

</p><p>It may also be the case that some letters give rise to more than one
phone.  For example the letter <code>x</code> in English is often pronunced as
the phone combination <code>k</code> and <code>s</code>.  To allow this, use the
multiphone <code>k-s</code>.  Thus the multiphone <code>k-s</code> will be predicted
for <code>x</code> in some context and the model will separate it into two
phones while it also ignoring any predicted <code>_epsilons_</code>.  Note that
multiphone units are relatively rare but do occur.  In English, letter
<code>x</code> give rise to a few, <code>k-s</code> in <code>taxi</code>, <code>g-s</code> in
<code>example</code>, and sometimes <code>g-zh</code> and <code>k-sh</code> in
<code>luxury</code>.  Others are <code>w-ah</code> in <code>one</code>, <code>t-s</code> in
<code>pizza</code>, <code>y-uw</code> in <code>new</code> (British), <code>ah-m</code> in
<code>-ism</code> etc.  Three phone multiphone are much rarer but may exist, they
are not supported by this code as is, but such entries should probably
be ignored.  Note the <code>-</code> sign in the multiphone examples is
significant and is used to indentify multiphones.

</p><p>The allowables for OALD end up being
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(set! allowables 
       '
      ((a _epsilon_ ei aa a e@ @ oo au o i ou ai uh e)
       (b _epsilon_ b )
       (c _epsilon_ k s ch sh @-k s t-s)
       (d _epsilon_ d dh t jh)
       (e _epsilon_ @ ii e e@ i @@ i@ uu y-uu ou ei aa oi y y-u@ o)
       (f _epsilon_ f v )
       (g _epsilon_ g jh zh th f ng k t)
       (h _epsilon_ h @ )
       (i _epsilon_ i@ i @ ii ai @@ y ai-@ aa a)
       (j _epsilon_ h zh jh i y )
       (k _epsilon_ k ch )
       (l _epsilon_ l @-l l-l)
       (m _epsilon_ m @-m n)
       (n _epsilon_ n ng n-y )
       (o _epsilon_ @ ou o oo uu u au oi i @@ e uh w u@ w-uh y-@)
       (p _epsilon_ f p v )
       (q _epsilon_ k )
       (r _epsilon_ r @@ @-r)
       (s _epsilon_ z s sh zh )
       (t _epsilon_ t th sh dh ch d )
       (u _epsilon_ uu @ w @@ u uh y-uu u@ y-u@ y-u i y-uh y-@ e)
       (v _epsilon_ v f )
       (w _epsilon_ w uu v f u)
       (x _epsilon_ k-s g-z sh z k-sh z g-zh )
       (y _epsilon_ i ii i@ ai uh y @ ai-@)
       (z _epsilon_ z t-s s zh )
       (# #)
       ))
</pre></td></tr></table><p>Note this is an exhaustive list and (deliberately) says nothing
about the contexts or frequency that these letter to phone pairs appear.
That information will be generated automatically from the training
set.

</p><p>Once the number of failed matches is signficantly low enough 
let <code>cummulate-pairs</code> run to completion.  This counts the number
of times each letter/phone pair occurs in allowable alignments.

</p><p>Next call
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">festival&gt; (save-table &quot;oald-&quot;)
</pre></td></tr></table><p>with the name of your lexicon.  This changes the cummulation
table into probabilities and saves it.

</p><p>Restart festival loading this new table
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">festival allowables.scm oald-pl-table.scm
</pre></td></tr></table><p>Now each word can be aligned to an equally-lengthed string of phones,
epsilon and multiphones.  
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">festival&gt; (aligndata &quot;oald.train&quot; &quot;oald.train.align&quot;)
</pre></td></tr></table><p>Do this also for you test set.

</p><p>This will produce entries like
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">aaronson _epsilon_ aa r ah n s ah n
abandon ah b ae n d ah n
abate ah b ey t _epsilon_
abbe ae b _epsilon_ iy
</pre></td></tr></table>
<p>The next stage is to build features suitable for `<tt>wagon</tt>' to
build models.  This is done by
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">festival&gt; (build-feat-file &quot;oald.train.align&quot; &quot;oald.train.feats&quot;)
</pre></td></tr></table><p>Again the same for the test set.

</p><p>Now you
need to constructrure a description file for `<tt>wagon</tt>' for
the given data.  The can be done using the script `<tt>make_wgn_desc</tt>'
provided with the speech tools

</p><p>Here is an example script for building the models, you will need
to modify it for your particualr database but it shows the basic
processes
</p><table><tr><td>&nbsp;</td><td><pre class="example">for i in a b c d e f g h i j k l m n o p q r s t u v w x y z 
do
   # Stop value for wagon
   STOP=2
   echo letter $i STOP $STOP
   # Find training set for letter $i
   cat oald.train.feats |
    awk '{if ($6 == &quot;'$i'&quot;) print $0}' &gt;ltsdataTRAIN.$i.feats
   # split training set to get heldout data for stepwise testing
   traintest ltsdataTRAIN.$i.feats
   # Extract test data for letter $i
   cat oald.test.feats |
    awk '{if ($6 == &quot;'$i'&quot;) print $0}' &gt;ltsdataTEST.$i.feats
   # run wagon to predict model
   wagon -data ltsdataTRAIN.$i.feats.train -test ltsdataTRAIN.$i.feats.test \
          -stepwise -desc ltsOALD.desc -stop $STOP -output lts.$i.tree
   # Test the resulting tree against
   wagon_test -heap 2000000 -data ltsdataTEST.$i.feats -desc ltsOALD.desc \
              -tree lts.$i.tree
done
</pre></td></tr></table><p>The script `<tt>traintest</tt>' splits the given file `<tt>X</tt>' into `<tt>X.train</tt>'
and `<tt>X.test</tt>' with every tenth line in `<tt>X.test</tt>' and the rest
in `<tt>X.train</tt>'.  

</p><p>This script can take a significnat amount of time to run, about 6 hours
on a Sun Ultra 140.

</p><p>Once the models are created the must be collected together into
a single list structure.  The trees generated by `<tt>wagon</tt>'
contain fully probability distributions at each leaf, at this time
this information can be removed as only the most probable will
actually be predicted.  This substantially reduces the size of the
tress.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(merge_models 'oald_lts_rules &quot;oald_lts_rules.scm&quot;)
</pre></td></tr></table><p>(<code>merge_models</code> is defined within `<tt>lts_build.scm</tt>')
The given file will contain a <code>set!</code> for the given variable
name to an assoc list of letter to trained tree.  Note the above
function naively assumes that the letters in the alphabet are
the 26 lower case letters of the English alphabet, you will need
to edit this adding accented letters if required.  Note that
adding &quot;'&quot; (single quote) as a letter is a little tricky in scheme
but can be done--the command <code>(intern &quot;'&quot;)</code> will give you 
the symbol for single quote.

</p><p>To test a set of lts models load the saved model and call 
the following function with the test align file
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">festival oald-table.scm oald_lts_rules.scm
festival&gt; (lts_testset &quot;oald.test.align&quot; oald_lts_rules)
</pre></td></tr></table><p>The result (after showing all the failed ones), will be a table showing
the results for each letter, for all letters and for complete words.
The failed entries may give some notion of how good or bad the result
is, sometimes it will be simple vowel diferences, long versus short,
schwa versus full vowel, other times it may be who consonants missing.
Remember the ultimate quality of the letter sound rules is how adequate
they are at providing <em>acceptable</em> pronunciations rather than 
how good the numeric score is.

</p><a name="IDX125"></a>
<a name="IDX126"></a>
<p>For some languages (e.g. English) it is necessary to also find a
stree pattern for unknown words.  Ultimately for this to work well
you need to know the morphological decomposition of the word.
At present we provide a CART trained system to predict stress
patterns for English.  If does get 94.6% correct for an unseen test
set but that isn't really very good.  Later tests suggest that
predicting stressed and unstressed phones directly is actually
better for getting whole words correct even though the models 
do slightly worse on a per phone basis <cite>black98</cite>.

</p><a name="IDX127"></a>
<a name="IDX128"></a>
<a name="IDX129"></a>
<p>As the lexicon may be a large part of the system we have also
experimented with removing entries from the lexicon if the letter to
sound rules system (and stree assignment system) can correct predict
them.  For OALD this allows us to half the size of the lexicon, it could
possibly allow more if a certain amount of fuzzy acceptance was allowed
(e.g. with schwa).  For other languages the gain here can be very
signifcant, for German and French we can reduce the lexicon by over 90%.
The function <code>reduce_lexicon</code> in `<tt>festival/lib/lts_build.scm</tt>'
was used to do this.  A diccussion of using the above technique as a
dictionary compression method is discussed in <cite>pagel98</cite>.  A
morphological decomposition algorithm, like that described in
<cite>black91</cite>, may even help more.

</p><p>The technique described in this section and its relative merits with
respect to a number of languages/lexicons and tasks is dicussed more
fully in <cite>black98</cite>.

</p><hr size="6">
<a name="NOD41"></a>
<a name="SEC44"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC43" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC45" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC38" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC38" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC47" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 13.6 Lexicon requirements </h2>

<p>For English there are a number of assumptions made about the lexicon
which are worthy of explicit mention.  If you are basically going to use
the existing token rules you should try to include at least the
following in any lexicon that is to work with them.

</p><ul>
<li>
<p>The letters of the alphabet, when a token is identified as an acronym it
is spelled out.  The tokenization assumes that the individual letters of
the alphabet are in the lexicon with their pronunciations.  They
should be identified as nouns.  (This is to distinguish <code>a</code> as
a determiner which can be schwa'd from <code>a</code> as a letter which 
cannot.)  The part of speech should be <code>nn</code> by default, but the
value of the variable <code>token.letter_pos</code> is used and may be
changed if this is not what is required.
</p></li><li> 
<p>One character symbols such as dollar, at-sign, percent etc.  Its
difficult to get a complete list and to know what the pronunciation of
some of these are (e.g hash or pound sign).  But the letter to sound
rules cannot deal with them so they need to be explicitly listed.  See
the list in the function <code>mrpa_addend</code> in
`<tt>festival/lib/dicts/oald/oaldlex.scm</tt>'.  This list should 
also contain the control characters and eight bit characters.
</p></li><li>
<a name="IDX130"></a>
<p>The possessive <code>'s</code> should be in your lexicon as schwa and voiced
fricative (<code>z</code>).  It should be in twice, once as part speech type
<code>pos</code> and once as <code>n</code> (used in plurals of numbers acronyms
etc. e.g 1950's).  <code>'s</code> is treated as a word and is separated from
the tokens it appears with.  The post-lexical rule (the function
<code>postlex_apos_s_check</code>) will delete the schwa and devoice the <code>z</code>
in appropriate contexts.  Note this post-lexical rule brazenly assumes
that the unvoiced fricative in the phoneset is <code>s</code>.  If it 
is not in your phoneset copy the function (it is in 
`<tt>festival/lib/postlex.scm</tt>') and change it for your phoneset
and use your version as a post-lexical rule.
</p></li><li>
<a name="IDX131"></a>
<p>Numbers as digits (e.g. &quot;1&quot;, &quot;2&quot;, &quot;34&quot;, etc.) should normally
<em>not</em> be in the lexicon.  The number conversion routines
convert numbers to words (i.e. &quot;one&quot;, &quot;two&quot;, &quot;thirty four&quot;, etc.).
</p></li><li>
<a name="IDX132"></a>
<p>The word &quot;unknown&quot; or whatever is in the variable
<code>token.unknown_word_name</code>.  This is used in a few obscure cases
when there just isn't anything that can be said (e.g. single characters
which aren't in the lexicon).  Some people have suggested it should be
possible to make this a sound rather than a word.  I agree, but Festival
doesn't support that yet.
</p></li></ul>

<hr size="6">
<a name="NOD42"></a>
<a name="SEC45"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC44" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC46" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC38" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC38" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC47" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 13.7 Available lexicons </h2>

<p>Currently Festival supports a number of different lexicons.  They are
all defined in the file `<tt>lib/lexicons.scm</tt>' each with a number of
common extra words added to their addendas.  They are
</p><dl compact="compact">
<dt>`<samp> CUVOALD</samp>'</dt>
<dd><a name="IDX133"></a>
<a name="IDX134"></a>
<p>The Computer Users Version of Oxford Advanced Learner's Dictionary is
available from the Oxford Text Archive
<a href="ftp://ota.ox.ac.uk/pub/ota/public/dicts/710">ftp://ota.ox.ac.uk/pub/ota/public/dicts/710</a>.  It contains about
70,000 entries and is a part of the BEEP lexicon.  It is more consistent
in its marking of stress though its syllable marking is not what works
best for our synthesis methods.  Many syllabic `<samp>l</samp>''s, `<samp>n</samp>''s,
and `<samp>m</samp>''s, mess up the syllabification algorithm, making results
sometimes appear over reduced.  It is however our current default
lexicon.  It is also the only lexicon with part of speech tags that
can be distributed (for non-commercial use).
</p></dd>
<dt>`<samp> CMU</samp>'</dt>
<dd><a name="IDX135"></a>
<p>This is automatically constructed from `<tt>cmu_dict-0.4</tt>' available
from many places on the net (see <code>comp.speech</code> archives).  It is
not in the mrpa phone set because it is American English pronunciation.
Although mappings exist between its phoneset (`<samp>darpa</samp>') and
`<samp>mrpa</samp>' the results for British English speakers are not very good.
However this is probably the biggest, most carefully specified lexicon
available.  It contains just under 100,000 entries.  Our distribution
has been modified to include part of speech tags on words we know to be
homographs.
</p></dd>
<dt>`<samp> mrpa</samp>'</dt>
<dd><a name="IDX136"></a>
<p>A version of the CSTR lexicon which has been floating about for years.
It contains about 25,000 entries.  A new updated free version of
this is due to be released soon.
</p></dd>
<dt>`<samp> BEEP</samp>'</dt>
<dd><a name="IDX137"></a>
<p>A British English rival for the `<tt>cmu_lex</tt>'.  BEEP has been made
available by Tony Robinson at Cambridge and is available in many
archives.  It contains 163,000 entries and has been converted to the
`<samp>mrpa</samp>' phoneset (which was a trivial mapping).  Although large, it
suffers from a certain randomness in its stress markings, making use of
it for synthesis dubious.
</p></dd>
</dl>

<p>All of the above lexicons have some distribution restrictions (though
mostly pretty light), but as they are mostly freely available we provide
programs that can convert the originals into Festival's format.

</p><a name="IDX138"></a>
<p>The MOBY lexicon has recently been released into the public domain and 
will be converted into our format soon.

</p><hr size="6">
<a name="NOD43"></a>
<a name="SEC46"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC45" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC47" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC38" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC38" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC47" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 13.8 Post-lexical rules </h2>

<p>It is the lexicon's job to produce a pronunciation of a given word.
However in most languages the most natural pronunciation of a word
cannot be found in isolation from the context in which it is to be
spoken.  This includes such phenomena as reduction, phrase final
devoicing and r-insertion.  In Festival this is done by post-lexical
rules.

</p><p><code>PostLex</code> is a module which is run after accent assignment
but before duration and F0 generation.  This is because knowledge
of accent position is necessary for vowel reduction and other
post lexical phenomena and changing the segmental items will
affect durations.

</p><p>The <code>PostLex</code> first applies a set of built in rules (which could be
done in Scheme but for historical reasons are still in C++).  It then
applies the functions set in the hook <code>postlex_rules_hook</code>.  These
should be a set of functions that take an utterance and apply
appropriate rules.  This should be set up on a per voice basis.

</p><p>Although a rule system could be devised for post-lexical sound rules it
is unclear what the scope of them should be, so we have left it
completely open.  Our vowel reduction model uses a CART decision tree to
predict which syllables should be reduced, while the &quot;'s&quot; rule is very
simple (shown in `<tt>festival/lib/postlex.scm</tt>').

</p><a name="IDX139"></a>
<a name="IDX140"></a>
<p>The <code>'s</code> in English may be pronounced in a number of different
ways depending on the preceding context.  If the preceding consonant
is a fricative or affricative and not a palatal labio-dental or
dental a schwa is required (e.g. <code>bench's</code>) otherwise
no schwa is required (e.g. <code>John's</code>).  Also if the previous
phoneme is unvoiced the &quot;s&quot; is rendered as an &quot;s&quot; while in all
other cases it is rendered as a &quot;z&quot;.

</p><p>For our English voices we have a lexical entry for &quot;'s&quot; as a
schwa followed by a &quot;z&quot;.  We use a post lexical rule function called
<code>postlex_apos_s_check</code> to modify the basic given form when
required.  After lexical lookup the segment relation contains the
concatenation of segments directly from lookup in the lexicon.
Post lexical rules are applied after that.

</p><p>In the following rule we check each segment to see if it is part of a
word labelled &quot;'s&quot;, if so we check to see if are we currently looking at the
schwa or the z part, and test if modification is required
</p><table><tr><td>&nbsp;</td><td><pre class="example">(define (postlex_apos_s_check utt)
  &quot;(postlex_apos_s_check UTT)
Deal with possesive s for English (American and British).  Delete
schwa of 's if previous is not a fricative or affricative, and
change voiced to unvoiced s if previous is not voiced.&quot;
  (mapcar
   (lambda (seg)
     (if (string-equal &quot;'s&quot; (item.feat 
                             seg &quot;R:SylStructure.parent.parent.name&quot;))
         (if (string-equal &quot;a&quot; (item.feat seg 'ph_vlng))
             (if (and (member_string (item.feat seg 'p.ph_ctype) 
                                     '(f a))
                      (not (member_string
                            (item.feat seg &quot;p.ph_cplace&quot;) 
                            '(d b g))))
                 t;; don't delete schwa
                 (item.delete seg))
             (if (string-equal &quot;-&quot; (item.feat seg &quot;p.ph_cvox&quot;))
                 (item.set_name seg &quot;s&quot;)))));; from &quot;z&quot;
   (utt.relation.items utt 'Segment))
  utt)
</pre></td></tr></table>
<hr size="6">
<a name="NOD44"></a>
<a name="SEC47"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC46" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC48" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC38" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC55" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 14. Utterances </h1>

<p>The utterance structure lies at the heart of Festival.  This chapter
describes its basic form and the functions available
to manipulate it.

</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC48">14.1 Utterance structure</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         internal structure of utterances
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC49">14.2 Utterance types</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Type defined synthesis actions
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC50">14.3 Example utterance types</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     Some example utterances
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC51">14.4 Utterance modules</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC52">14.5 Accessing an utterance</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">      getting the data from the structure
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC53">14.6 Features</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Features and features names
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC54">14.7 Utterance I/O</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Saving and loading utterances
</td></tr>
</table>

<hr size="6">
<a name="NOD45"></a>
<a name="SEC48"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC47" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC49" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC47" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC47" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC55" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 14.1 Utterance structure </h2>

<p>Festival's basic object for synthesis is the <em>utterance</em>.  An
represents some chunk of text that is to be rendered as speech.  In
general you may think of it as a sentence but in many cases it wont
actually conform to the standard linguistic syntactic form of a
sentence.  In general the process of text to speech is to take an
utterance which contains a simple string of characters and convert it
step by step, filling out the utterance structure with more information
until a waveform is built that says what the text contains.

</p><p>The processes involved in conversion are, in general, as follows
</p><dl compact="compact">
<dt><em> Tokenization</em></dt>
<dd><p>Converting the string of characters into a list of tokens.  Typically
this means whitespace separated tokesn of the original text string.
</p></dd>
<dt><em> Token identification</em></dt>
<dd><p>identification of general types for the tokens, usually this is trivial
but requires some work to identify tokens of digits as years, dates,
numbers etc.
</p></dd>
<dt><em> Token to word</em></dt>
<dd><p>Convert each tokens to zero or more words, expanding numbers,
abbreviations etc.
</p></dd>
<dt><em> Part of speech</em></dt>
<dd><p>Identify the syntactic part of speech for the words.
</p></dd>
<dt><em> Prosodic phrasing</em></dt>
<dd><p>Chunk utterance into prosodic phrases.
</p></dd>
<dt><em> Lexical lookup</em></dt>
<dd><p>Find the pronucnation of each word from a lexicon/letter to sound
rule system including phonetic and syllable structure.
</p></dd>
<dt><em> Intonational accents</em></dt>
<dd><p>Assign intonation accents to approrpiate syllables.
</p></dd>
<dt><em> Assign duration</em></dt>
<dd><p>Assign duration to each phone in the utterance.
</p></dd>
<dt><em> Generate F0 contour (tune)</em></dt>
<dd><p>Generate tune based on accents etc.
</p></dd>
<dt><em> Render waveform</em></dt>
<dd><p>Render waveform from phones, duration and F) target values, this
itself may take several steps including unit selection (be they
diphones or other sized units), imposition of dsesired prosody
(duration and F0) and waveform reconstruction.
</p></dd>
</dl>
<p>The number of steps and what actually happens may vary and is dependent
on the particular voice selected and the utterance's <em>type</em>,
see below.

</p><p>Each of these steps in Festival is achived by a <em>module</em> which
will typically add new information to the utterance structure.

</p><a name="IDX141"></a>
<a name="IDX142"></a>
<a name="IDX143"></a>
<p>An utterance structure consists of a set of <em>items</em> which may be
part of one or more <em>relations</em>.  Items represent things like words
and phones, though may also be used to represent less concrete objects
like noun phrases, and nodes in metrical trees.  An item contains a set
of features, (name and value).  Relations are typically simple lists of
items or trees of items.  For example the the <code>Word</code> relation is a
simple list of items each of which represent a word in the utterance.
Those words will also be in other relations, such as the
<em>SylStructure</em> relation where the word will be the top of a tree
structure containing its syllables and segments.

</p><p>Unlike previous versions of the system items (then called stream items)
are not in any particular relations (or stream).  And are merely part of
the relations they are within.  Importantly this allows much more general
relations to be made over items that was allowed in the previous 
system.  This new architecture is the continuation of our goal
of providing a general efficient structure for representing complex
interrelated utterance objects.

</p><a name="IDX144"></a>
<p>The architecture is fully general and new items and relations may
be defined at run time, such that new modules may use any relations
they wish. However within our standard English (and other voices)
we have used a specific set of relations ass follows.
</p><dl compact="compact">
<dt><em> Token</em></dt>
<dd><p>a list of trees.  This is first formed as a list of tokens found
in a character text string.  Each root's daughters are the <em>Word</em>'s
that the token is related to.
</p></dd>
<dt><em> Word</em></dt>
<dd><p>a list of words.  These items will also appear as daughters (leaf nodes)
of the <code>Token</code> relation.  They may also appear in the <code>Syntax</code>
relation (as leafs) if the parser is used.  They will also be leafs
of the <code>Phrase</code> relation.
</p></dd>
<dt><em> Phrase</em></dt>
<dd><p>a list of trees.  This is a list of phrase roots whose daughters are
the <code>Word's</code> within those phrases.
</p></dd>
<dt><em> Syntax</em></dt>
<dd><p>a single tree.  This, if the probabilistic parser is called, is a syntactic
binary branching tree over the members of the <code>Word</code> relation.
</p></dd>
<dt><em> SylStructure</em></dt>
<dd><p>a list of trees.  This links the <code>Word</code>, <code>Syllable</code> and 
<code>Segment</code> relations.  Each <code>Word</code> is the root of a tree
whose immediate daughters are its syllables and their daughters in
turn as its segments.
</p></dd>
<dt><em> Syllable</em></dt>
<dd><p>a list of syllables.  Each member will also be in a the
<code>SylStructure</code> relation.  In that relation its parent will be the
word it is in and its daughters will be the segments that are in it.
Syllables are also in the <code>Intonation</code> relation giving links to
their related intonation events.
</p></dd>
<dt><em> Segment</em></dt>
<dd><p>a list of segments (phones).  Each member (except silences) will be leaf
nodes in the <code>SylStructure</code> relation.  These may also be in the
<code>Target</code> relation linking them to F0 target points.
</p></dd>
<dt><em> IntEvent</em></dt>
<dd><p>a list of intonation events (accents and boundaries).  These are related
to syllables through the <code>Intonation</code> relation as leafs on that
relation.  Thus their parent in the <code>Intonation</code> relation is the
syllable these events are attached to.
</p></dd>
<dt><em> Intonation</em></dt>
<dd><p>a list of trees relating syllables to intonation events.  Roots of
the trees in <code>Intonation</code> are <code>Syllables</code> and their daughters
are <code>IntEvents</code>.
</p></dd>
<dt><em> Wave</em></dt>
<dd><p>a single item with a feature called <code>wave</code> whose value
is the generated waveform.
</p></dd>
</dl>
<p>This is a non-exhaustive list some modules may add other relations
and not all utterance may have all these relations, but the above
is the general case.

</p><hr size="6">
<a name="NOD46"></a>
<a name="SEC49"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC48" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC50" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC47" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC47" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC55" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 14.2 Utterance types </h2>

<p>The primary purpose of types is to define which modules are to be
applied to an utterance.  <code>UttTypes</code> are defined in
`<tt>lib/synthesis.scm</tt>'.  The function <code>defUttType</code> defines which
modules are to be applied to an utterance of that type.  The function
<code>utt.synth</code> is called applies this list of module to an utterance
before waveform synthesis is called.

</p><p>For example when a <code>Segment</code> type Utterance is synthesized it needs
only have its values loaded into a <code>Segment</code> relation and a
<code>Target</code> relation, then the low level waveform synthesis module
<code>Wave_Synth</code> is called.  This is defined as follows
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(defUttType Segments
  (Initialize utt)
  (Wave_Synth utt))
</pre></td></tr></table><p>A more complex type is <code>Text</code> type utterance which requires many
more modules to be called before a waveform can be synthesized
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(defUttType Text
  (Initialize utt)
  (Text utt)
  (Token utt)
  (POS utt)
  (Phrasify utt)
  (Word utt)
  (Intonation utt)
  (Duration utt)
  (Int_Targets utt)
  (Wave_Synth utt)
)
</pre></td></tr></table><a name="IDX145"></a>
<p>The <code>Initialize</code> module should normally be called for all
types.  It loads the necessary relations from the input form
and deletes all other relations (if any exist) ready for synthesis.

</p><p>Modules may be directly defined as C/C++ functions and declared with a
Lisp name or simple functions in Lisp that check some global parameter
before calling a specific module (e.g. choosing between different
intonation modules).

</p><p>These types are used when calling the function 
<code>utt.synth</code> and individual modules may be called explicitly by
hand if required.

</p><a name="IDX146"></a>
<a name="IDX147"></a>
<p>Because we expect waveform synthesis methods to themselves become
complex with a defined set of functions to select, join, and modify
units we now support an addition notion of <code>SynthTypes</code> like
<code>UttTypes</code> these define a set of functions to apply
to an utterance.  These may be defined using the <code>defSynthType</code>
function.  For example
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(defSynthType Festival
  (print &quot;synth method Festival&quot;)
  
  (print &quot;select&quot;)
  (simple_diphone_select utt)

  (print &quot;join&quot;)
  (cut_unit_join utt)

  (print &quot;impose&quot;)
  (simple_impose utt)
  (simple_power utt)

  (print &quot;synthesis&quot;)
  (frames_lpc_synthesis utt)
  )
</pre></td></tr></table><p>A <code>SynthType</code> is selected by naming as the value of the
parameter <code>Synth_Method</code>.

</p><a name="IDX148"></a>
<a name="IDX149"></a>
<a name="IDX150"></a>
<a name="IDX151"></a>
<a name="IDX152"></a>
<p>Duration the application of the function <code>utt.synth</code> there are
three hooks applied.  This allows addition control of the synthesis
process.  <code>before_synth_hooks</code> is applied before any modules are
applied.  <code>after_analysis_hooks</code> is applied at the start of
<code>Wave_Synth</code> when all text, linguistic and prosodic processing have
been done.  <code>after_synth_hooks</code> is applied after all modules have
been applied.  These are useful for things such as, altering the volume
of a voice that happens to be quieter than others, or for example
outputing information for a talking head before waveform synthesis
occurs so preparation of the facial frames and synthesizing the waveform
may be done in parallel.  (see `<tt>festival/examples/th-mode.scm</tt>' for
an example use of these hooks for a talking head text mode.)

</p><hr size="6">
<a name="NOD47"></a>
<a name="SEC50"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC49" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC51" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC47" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC47" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC55" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 14.3 Example utterance types </h2>

<p>A number of utterance types are currently supported.  It is easy to add
new ones but the standard distribution includes the following.

</p><dl compact="compact">
<dt><code> Text</code></dt>
<dd><a name="IDX153"></a>
<p>Raw text as a string.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(Utterance Text &quot;This is an example&quot;)
</pre></td></tr></table></dd>
<dt><code> Words</code></dt>
<dd><a name="IDX154"></a>
<p>A list of words
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(Utterance Words (this is an example))
</pre></td></tr></table><p>Words may be atomic or lists if further features need to be specified.
For example to specify a word and its part of speech you
can use
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(Utterance Words (I (live (pos v)) in (Reading (pos n) (tone H-H%))))
</pre></td></tr></table><p>Note: the use of the tone feature requires an intonation mode that 
supports it.

</p><p>Any feature and value named in the input will be added to the Word
item.
</p></dd>
<dt><code> Phrase</code></dt>
<dd><p>This allows explicit phrasing and features on Tokens to be specified.
The input consists of a list of phrases each contains a list of tokens.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(Utterance
 Phrase
 ((Phrase ((name B))
   I saw the man
   (in ((EMPH 1)))
   the park)
  (Phrase ((name BB))
   with the telescope)))
</pre></td></tr></table><p>ToBI tones and accents may also be specified on Tokens but these will
only take effect if the selected intonation method uses them.
</p></dd>
<dt><code> Segments</code></dt>
<dd><a name="IDX155"></a>
<p>This allows specification of segments, durations and F0 target
values.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(Utterance 
 Segments
 ((# 0.19 )
  (h 0.055 (0 115))
  (@ 0.037 (0.018 136))
  (l 0.064 )
  (ou 0.208 (0.0 134) (0.100 135) (0.208 123))
  (# 0.19)))
</pre></td></tr></table><p>Note the times are in <em>seconds</em> NOT milliseconds.  The format of
each segment entry is segment name, duration in seconds, and list of
target values.  Each target value consists of a pair of point into the
segment (in seconds) and F0 value in Hz.
</p></dd>
<dt><code> Phones</code></dt>
<dd><a name="IDX156"></a>
<p>This allows a simple specification of a list of phones.  Synthesis
specifies fixed durations (specified in <code>FP_duration</code>, default 100
ms) and monotone intonation (specified in <code>FP_F0</code>, default 120Hz).
This may be used for simple checks for waveform synthesizers etc.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(Utterance Phones (# h @ l ou #))
</pre></td></tr></table><a name="IDX157"></a>
<p>Note the function <code>SayPhones</code> allows synthesis and playing of
lists of phones through this utterance type.
</p></dd>
<dt><code> Wave</code></dt>
<dd><a name="IDX158"></a>
<p>A waveform file.  Synthesis here simply involves loading
the file.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(Utterance Wave fred.wav)
</pre></td></tr></table></dd>
</dl>
<a name="IDX159"></a>
<a name="IDX160"></a>
<p>Others are supported, as defined in `<tt>lib/synthesis.scm</tt>' but are
used internally by various parts of the system.  These include
<code>Tokens</code> used in TTS and <code>SegF0</code> used by <code>utt.resynth</code>.

</p><hr size="6">
<a name="NOD48"></a>
<a name="SEC51"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC50" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC52" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC47" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC47" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC55" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 14.4 Utterance modules </h2>

<p>The module is the basic unit that does the work of synthesis.  Within
Festival there are duration modules, intonation modules, wave synthesis
modules etc.  As stated above the utterance type defines the set of
modules which are to be applied to the utterance.  These modules in turn
will create relations and items so that ultimately a waveform is
generated, if required.

</p><a name="IDX161"></a>
<p>Many of the chapters in this manual are solely concerned with particular
modules in the system.  Note that many modules have internal choices,
such as which duration method to use or which intonation method to
use.  Such general choices are often done through the <code>Parameter</code>
system.  Parameters may be set for different features like
<code>Duration_Method</code>, <code>Synth_Method</code> etc.  Formerly the values
for these parameters were atomic values but now they may be the
functions themselves.  For example, to select the Klatt duration rules
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(Parameter.set 'Duration_Method Duration_Klatt)
</pre></td></tr></table><p>This allows new modules to be added without requiring changes to
the central Lisp functions such as <code>Duration</code>, <code>Intonation</code>,
and <code>Wave_Synth</code>.

</p><hr size="6">
<a name="NOD49"></a>
<a name="SEC52"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC51" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC53" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC47" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC47" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC55" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 14.5 Accessing an utterance </h2>

<p>There are a number of standard functions that allow one to access parts
of an utterance and traverse through it.

</p><a name="IDX162"></a>
<a name="IDX163"></a>
<p>Functions exist in Lisp (and of course C++) for accessing an utterance.
The Lisp access functions are
</p><dl compact="compact">
<dt>`<samp> (utt.relationnames UTT)</samp>'</dt>
<dd><p>returns a list of the names of the relations currently created in <code>UTT</code>.
</p></dd>
<dt>`<samp> (utt.relation.items UTT RELATIONNAME)</samp>'</dt>
<dd><p>returns a list of all items in <code>RELATIONNAME</code> in <code>UTT</code>.  This
is nil if no relation of that name exists.  Note for tree relation will
give the items in pre-order. 
</p></dd>
<dt>`<samp> (utt.relation_tree UTT RELATIONNAME)</samp>'</dt>
<dd><p>A Lisp tree presentation of the items <code>RELATIONNAME</code> in <code>UTT</code>.
The Lisp bracketing reflects the tree structure in the relation.
</p></dd>
<dt>`<samp> (utt.relation.leafs UTT RELATIONNAME)</samp>'</dt>
<dd><p>A list of all the leafs of the items in <code>RELATIONNAME</code> in
<code>UTT</code>.  Leafs are defined as those items with no daughters within
that relation.  For simple list relations <code>utt.relation.leafs</code> and
<code>utt.relation.items</code> will return the same thing.
</p></dd>
<dt>`<samp> (utt.relation.first UTT RELATIONNAME)</samp>'</dt>
<dd><p>returns the first item in <code>RELATIONNAME</code>.  Returns <code>nil</code>
if this relation contains no items
</p></dd>
<dt>`<samp> (utt.relation.last UTT RELATIONNAME)</samp>'</dt>
<dd><p>returns the last (the most next) item in <code>RELATIONNAME</code>.  Returns
<code>nil</code> if this relation contains no items
</p></dd>
<dt>`<samp> (item.feat ITEM FEATNAME)</samp>'</dt>
<dd><p>returns the value of feature <code>FEATNAME</code> in <code>ITEM</code>.  <code>FEATNAME</code>
may be a feature name, feature function name, or pathname (see below).
allowing reference to other parts of the utterance this item is in.
</p></dd>
<dt>`<samp> (item.features ITEM)</samp>'</dt>
<dd><p>Returns an assoc list of feature-value pairs of all local features on
this item.
</p></dd>
<dt>`<samp> (item.name ITEM)</samp>'</dt>
<dd><p>Returns the name of this <code>ITEM</code>.  This could also be accessed
as <code>(item.feat ITEM 'name)</code>.
</p></dd>
<dt>`<samp> (item.set_name ITEM NEWNAME)</samp>'</dt>
<dd><p>Sets name on <code>ITEM</code> to be <code>NEWNAME</code>.  This is equivalent to
<code>(item.set_feat ITEM 'name NEWNAME)</code>
</p></dd>
<dt>`<samp> (item.set_feat ITEM FEATNAME FEATVALUE)</samp>'</dt>
<dd><p>set the value of <code>FEATNAME</code> to <code>FEATVALUE</code> in <code>ITEM</code>.
<code>FEATNAME</code> should be a simple name and not refer to next,
previous or other relations via links.
</p></dd>
<dt>`<samp> (item.relation ITEM RELATIONNAME)</samp>'</dt>
<dd><p>Return the item as viewed from <code>RELATIONNAME</code>, or <code>nil</code> if
<code>ITEM</code> is not in that relation.
</p></dd>
<dt>`<samp> (item.relationnames ITEM)</samp>'</dt>
<dd><p>Return a list of relation names that this item is in.
</p></dd>
<dt>`<samp> (item.relationname ITEM)</samp>'</dt>
<dd><p>Return the relation name that this item is currently being viewed as.
</p></dd>
<dt>`<samp> (item.next ITEM)</samp>'</dt>
<dd><p>Return the next item in <code>ITEM</code>'s current relation, or <code>nil</code>
if there is no next.
</p></dd>
<dt>`<samp> (item.prev ITEM)</samp>'</dt>
<dd><p>Return the previous item in <code>ITEM</code>'s current relation, or <code>nil</code>
if there is no previous.
</p></dd>
<dt>`<samp> (item.parent ITEM)</samp>'</dt>
<dd><p>Return the parent of <code>ITEM</code> in <code>ITEM</code>'s current relation, or
<code>nil</code> if there is no parent.
</p></dd>
<dt>`<samp> (item.daughter1 ITEM)</samp>'</dt>
<dd><p>Return the first daughter of <code>ITEM</code> in <code>ITEM</code>'s current relation, or
<code>nil</code> if there are no daughters.
</p></dd>
<dt>`<samp> (item.daughter2 ITEM)</samp>'</dt>
<dd><p>Return the second daughter of <code>ITEM</code> in <code>ITEM</code>'s current relation, or
<code>nil</code> if there is no second daughter.
</p></dd>
<dt>`<samp> (item.daughtern ITEM)</samp>'</dt>
<dd><p>Return the last daughter of <code>ITEM</code> in <code>ITEM</code>'s current relation, or
<code>nil</code> if there are no daughters.
</p></dd>
<dt>`<samp> (item.leafs ITEM)</samp>'</dt>
<dd><p>Return a list of all lefs items (those with no daughters) dominated
by this item.
</p></dd>
<dt>`<samp> (item.next_leaf ITEM)</samp>'</dt>
<dd><p>Find the next item in this relation that has no daughters.  Note this 
may traverse up the tree from this point to search for such an item.

</p></dd>
</dl>

<p>As from 1.2 the utterance structure may be fully manipulated from
Scheme.  Relations and items may be created and deleted, as easily
as they can in C++;
</p><dl compact="compact">
<dt>`<samp> (utt.relation.present UTT RELATIONNAME)</samp>'</dt>
<dd><p>returns <code>t</code> if relation named <code>RELATIONNAME</code> is present, <code>nil</code>
otherwise.
</p></dd>
<dt>`<samp> (utt.relation.create UTT RELATIONNAME)</samp>'</dt>
<dd><p>Creates a new relation called <code>RELATIONNAME</code>.  If this relation
already exists it is deleted first and items in the relation are
derefenced from it (deleting the items if they are no longer referenced
by any relation).  Thus create relation guarantees an empty relation.
</p></dd>
<dt>`<samp> (utt.relation.delete UTT RELATIONNAME)</samp>'</dt>
<dd><p>Deletes the relation called <code>RELATIONNAME</code> in utt.  All items in
that relation are derefenced from the relation and if they are no
longer in any relation the items themselves are deleted.
</p></dd>
<dt>`<samp> (utt.relation.append UTT RELATIONNAME ITEM)</samp>'</dt>
<dd><p>Append <code>ITEM</code> to end of relation named <code>RELATIONNAME</code> in
<code>UTT</code>.  Returns <code>nil</code> if there is not relation named
<code>RELATIONNAME</code> in <code>UTT</code> otherwise returns the item
appended.  This new item becomes the last in the top list.
<code>ITEM</code> item may be an item itself (in this or another relation)
or a LISP description of an item, which consist of a list containing
a name and a set of feature vale pairs.  It <code>ITEM</code> is <code>nil</code>
or inspecified an new empty item is added.  If <code>ITEM</code> is already
in this relation it is dereferenced from its current position (and
an empty item re-inserted).
</p></dd>
<dt>`<samp> (item.insert ITEM1 ITEM2 DIRECTION)</samp>'</dt>
<dd><p>Insert <code>ITEM2</code> into <code>ITEM1</code>'s relation in the direction
specified by <code>DIRECTION</code>.  <code>DIRECTION</code> may take the
value, <code>before</code>, <code>after</code>, <code>above</code> and <code>below</code>.
If unspecified, <code>after</code> is assumed.  Note it is not recommended
to insert above and below and the functions <code>item.insert_parent</code>
and <code>item.append_daughter</code> should normally be used for tree building.
Inserting using <code>before</code> and <code>after</code> within daughters is
perfectly safe.
</p></dd>
<dt>`<samp> (item.append_daughter PARENT DAUGHTER)</samp>'</dt>
<dd><p>Append <code>DAUGHTER</code>, an item or a description of an item to
the item <code>PARENT</code> in the <code>PARENT</code>'s relation.
</p></dd>
<dt>`<samp> (item.insert_parent DAUGHTER NEWPARENT)</samp>'</dt>
<dd><p>Insert a new parent above <code>DAUGHTER</code>.  <code>NEWPARENT</code> may
be a item or the description of an item.
</p></dd>
<dt>`<samp> (item.delete ITEM)</samp>'</dt>
<dd><p>Delete this item from all relations it is in.  All daughters of this
item in each relations are also removed from the relation (which may in
turn cause them to be deleted if they cease to be referenced by any
other relation.  
</p></dd>
<dt>`<samp> (item.relation.remove ITEM)</samp>'</dt>
<dd><p>Remove this item from this relation, and any of its daughters.  Other
relations this item are in remain untouched.
</p></dd>
<dt>`<samp> (item.move_tree FROM TO)</samp>'</dt>
<dd><p>Move the item <code>FROM</code> to the position of <code>TO</code> in <code>TO</code>'s
relation.  <code>FROM</code> will often be in the same relation as <code>TO</code>
but that isn't necessary.  The contents of <code>TO</code> are dereferenced.
its daughters are saved then descendants of <code>FROM</code> are
recreated under the new <code>TO</code>, then <code>TO</code>'s previous
daughters are derefenced.   The order of this is important as <code>FROM</code>
may be part of <code>TO</code>'s descendants.  Note that if <code>TO</code>
is part of <code>FROM</code>'s descendants no moving occurs and <code>nil</code>
is returned.  For example to remove all punction terminal nodes in
the Syntax relation the call would be something like
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(define (syntax_relation_punc p)
  (if (string-equal &quot;punc&quot; (item.feat (item.daughter2 p) &quot;pos&quot;))
      (item.move_tree (item.daughter1 p) p)
  (mapcar syntax_remove_punc (item.daughters p))))
</pre></td></tr></table></dd>
<dt>`<samp> (item.exchange_trees ITEM1 ITEM2)</samp>'</dt>
<dd><p>Exchange <code>ITEM1</code> and <code>ITEM2</code> and their descendants in
<code>ITEM2</code>'s relation.  If <code>ITEM1</code> is within <code>ITEM2</code>'s
descendants or vice versa <code>nil</code> is returns and no exchange takes
place.  If <code>ITEM1</code> is not in <code>ITEM2</code>'s relation, no
exchange takes place.
</p></dd>
</dl>

<p>Daughters of a node are actually represented as a list whose first
daughter is double linked to the parent.  Although being aware of
this structure may be useful it is recommended that all access go through
the tree specific functions <code>*.parent</code> and <code>*.daughter*</code> 
which properly deal with the structure, thus is the internal structure
ever changes in the future only these tree access function need be
updated.

</p><p>With the above functions quite elaborate utterance manipulations can
be performed.  For example in post-lexical rules where modifications
to the segments are required based on the words and their context.
See section <a href="#SEC46">Post-lexical rules</a>, for an example of using various
utterance access functions.

</p><hr size="6">
<a name="NOD50"></a>
<a name="SEC53"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC52" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC54" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC47" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC47" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC55" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 14.6 Features </h2>

<p>In previous versions items had a number of predefined features.  This is
no longer the case and all features are optional.  Particularly the
<code>start</code> and <code>end</code> features are no longer fixed, though those
names are still used in the relations where yjeu are appropriate.
Specific functions are provided for the <code>name</code> feature but they are
just short hand for normal feature access.  Simple features directly access
the features in the underlying <code>EST_Feature</code> class in an item.

</p><p>In addition to simple features there is a mechanism for relating
functions to names, thus accessing a feature may actually call a
function.  For example the features <code>num_syls</code> is defined as a
feature function which will count the number of syllables in the 
given word, rather than simple access a pre-existing feature.  Feature
functions are usually dependent on the particular realtion the
item is in, e.g. some feature functions are only appropriate for 
items in the <code>Word</code> relation, or only appropriate for those in the 
<code>IntEvent</code> relation.

</p><p>The third aspect of feature names is a path component.  These are
parts of the name (preceding in <code>.</code>) that indicated some
trversal of the utterance structure.  For example the features
<code>name</code> will access the name feature on the given item.  The
feature <code>n.name</code> will return the name feature on the next item
(in that item's relation).  A number of basic direction
operators are defined.
</p><dl compact="compact">
<dt><code> n.</code></dt>
<dd><p>next
</p></dd>
<dt><code> p.</code></dt>
<dd><p>previous
</p></dd>
<dt><code> nn.</code></dt>
<dd><p>next next
</p></dd>
<dt><code> pp.</code></dt>
<dd><p>previous
</p></dd>
<dt><code> parent.</code></dt>
<dt><code> daughter1.</code></dt>
<dd><p>first daughter
</p></dd>
<dt><code> daughter2.</code></dt>
<dd><p>second daughter
</p></dd>
<dt><code> daughtern.</code></dt>
<dd><p>last daughter
</p></dd>
<dt><code> first.</code></dt>
<dd><p>most previous item
</p></dd>
<dt><code> last.</code></dt>
<dd><p>most next item
</p></dd>
</dl>
<p>Also you may specific traversal to another relation relation, though
the <code>R:&lt;relationame&gt;.</code> operator.  For example given an Item
in the syllable relation <code>R:SylStructure.parent.name</code> would
give the name of word the syllable is in.

</p><p>Some more complex examples are as follows, assuming we are starting
form an item in the <code>Syllable</code> relation.
</p><dl compact="compact">
<dt>`<samp> stress</samp>'</dt>
<dd><p>This item's lexical stress
</p></dd>
<dt>`<samp> n.stress</samp>'</dt>
<dd><p>The next syllable's lexical stress
</p></dd>
<dt>`<samp> p.stress</samp>'</dt>
<dd><p>The previous syllable's lexical stress
</p></dd>
<dt>`<samp> R:SylStructure.parent.name</samp>'</dt>
<dd><p>The word this syllable is in
</p></dd>
<dt>`<samp> R:SylStructure.parent.R:Word.n.name</samp>'</dt>
<dd><p>The word next to the word this syllable is in
</p></dd>
<dt>`<samp> n.R:SylStructure.parent.name</samp>'</dt>
<dd><p>The word the next syllable is in
</p></dd>
<dt>`<samp> R:SylStructure.daughtern.ph_vc</samp>'</dt>
<dd><p>The phonetic feature <code>vc</code> of the final segment in this syllable.
</p></dd>
</dl>
<p>A list of all feature functions is given in an appendix of this
document. See section <a href="#SEC141">Feature functions</a>.  New functions may also be added
in Lisp.

</p><p>In C++ feature values are of class <em>EST_Val</em> which may be a string,
int, or a float (or any arbitrary object).  In Scheme this distinction
cannot not always be made and sometimes when you expect an int you
actually get a string.  Care should be take to ensure the right matching
functions are use in Scheme.  It is recommended you use
<code>string-append</code> or <code>string-match</code> as they will always work.

</p><p>If a pathname does not identify a valid path for the particular
item (e.g. there is no next) <code>&quot;0&quot;</code> is returned.

</p><a name="IDX164"></a>
<a name="IDX165"></a>
<p>When collecting data from speech databases it is often useful to collect
a whole set of features from all utterances in a database.  These
features can then be used for building various models (both CART tree
models and linear regression modules use these feature names),

</p><p>A number of functions exist to help in this task.  For example
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(utt.features utt1 'Word '(name pos p.pos n.pos))
</pre></td></tr></table><p>will return a list of word, and part of speech context for each
word in the utterance.  

</p><p>See section <a href="#SEC117">Extracting features</a>, for an example of extracting sets
of features from a database for use in building stochastic models.

</p><hr size="6">
<a name="NOD51"></a>
<a name="SEC54"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC53" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC55" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC47" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC47" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC55" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 14.7 Utterance I/O </h2>

<p>A number of functions are available to allow an utterance's
structure to be made available for other programs.

</p><a name="IDX166"></a>
<a name="IDX167"></a>
<p>The whole structure, all relations, items and features may be
saved in an ascii format using the function <code>utt.save</code>.  This
file may be reloaded using the <code>utt.load</code> function.  Note the
waveform is not saved using the form.

</p><a name="IDX168"></a>
<a name="IDX169"></a>
<a name="IDX170"></a>
<a name="IDX171"></a>
<a name="IDX172"></a>
<a name="IDX173"></a>
<p>Individual aspects of an utterance may be selectively saved.  The
waveform itself may be saved using the function <code>utt.save.wave</code>.
This will save the waveform in the named file in the format specified
in the <code>Parameter</code> <code>Wavefiletype</code>.  All formats supported by
the Edinburgh Speech Tools are valid including <code>nist</code>, <code>esps</code>,
<code>sun</code>, <code>riff</code>, <code>aiff</code>, <code>raw</code> and <code>ulaw</code>.  Note
the functions <code>utt.wave.rescale</code> and <code>utt.wave.resample</code> may
be used to change the gain and sample frequency of the waveform before
saving it.  A waveform may be imported into an existing utterance with
the function <code>utt.import.wave</code>.  This is specifically designed to
allow external methods of waveform synthesis.  However if you just wish
to play an external wave or make it into an utterance you should
consider the utterance <code>Wave</code> type.

</p><a name="IDX174"></a>
<a name="IDX175"></a>
<a name="IDX176"></a>
<p>The segments of an utterance may be saved in a file using the function
<code>utt.save.segs</code> which saves the segments of the named utterance in
xlabel format.  Any other stream may also be saved using the more
general <code>utt.save.relation</code> which takes the additional argument of
a relation name.  The names of each item and the end feature of each
item are saved in the named file, again in Xlabel format, other features
are saved in extra fields.  For more elaborated saving methods you can
easily write a Scheme function to save data in an utterance in whatever
format is required.  See the file `<tt>lib/mbrola.scm</tt>' for an example.

</p><a name="IDX177"></a>
<a name="IDX178"></a>
<p>A simple function to allow the displaying of an utterance in
Entropic's Xwaves tool is provided by the function <code>display</code>.
It simply saves the waveform and the segments and sends appropriate
commands to (the already running) Xwaves and xlabel programs.

</p><a name="IDX179"></a>
<a name="IDX180"></a>
<p>A function to synthesize an externally specified utterance is provided
for by <code>utt.resynth</code> which takes two filename arguments, an xlabel
segment file and an F0 file.  This function loads, synthesizes and plays
an utterance synthesized from these files.  The loading is provided by
the underlying function <code>utt.load.segf0</code>.

</p><hr size="6">
<a name="NOD52"></a>
<a name="SEC55"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC54" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC56" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC47" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC61" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 15. Text analysis </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC56">15.1 Tokenizing</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    Splitting text into tokens
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC57">15.2 Token to word rules</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC58">15.3 Homograph disambiguation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  &quot;Wed 5 may wind US Sen up&quot;
</td></tr>
</table>

<hr size="6">
<a name="NOD53"></a>
<a name="SEC56"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC55" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC57" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC55" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC55" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC61" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 15.1 Tokenizing </h2>

<p>A crucial stage in text processing is the initial tokenization of text.
A <em>token</em> in Festival is an atom separated with whitespace from a
text file (or string).  If punctuation for the current language is
defined, characters matching that punctuation are removed from the
beginning and end of a token and held as features of the token.  The
default list of characters to be treated as white space is defined as
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(defvar token.whitespace &quot; \t\n\r&quot;)
</pre></td></tr></table><p>While the default set of punctuation characters is
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(defvar token.punctuation &quot;\&quot;'`.,:;!?(){}[]&quot;)
(defvar token.prepunctuation &quot;\&quot;'`({[&quot;)
</pre></td></tr></table><p>These are declared in `<tt>lib/token.scm</tt>' but may be changed
for different languages, text modes etc.

</p><hr size="6">
<a name="NOD54"></a>
<a name="SEC57"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC56" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC58" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC55" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC55" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC61" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 15.2 Token to word rules </h2>

<p>Tokens are further analysed into lists of words.  A word
is an atom that can be given a pronunciation by the lexicon (or
letter to sound rules).  A token may give rise to a number
of words or none at all.

</p><p>For example the basic tokens
</p><table><tr><td>&nbsp;</td><td><pre class="example">This pocket-watch was made in 1983.
</pre></td></tr></table><p>would give a word relation of
</p><table><tr><td>&nbsp;</td><td><pre class="example">this pocket watch was made in nineteen eighty three
</pre></td></tr></table>
<p>Becuase the relationship between tokens and word in some cases is
complex, a user function may be specified for translating tokens into
words.  This is designed to deal with things like numbers, email
addresses, and other non-obvious pronunciations of tokens as zero or
more words.  Currently a builtin function
<code>builtin_english_token_to_words</code> offers much of the necessary
functionality for English but a user may further customize this.

</p><p>If the user defines a function <code>token_to_words</code> which takes two
arguments: a token item and a token name, it will be called by the
<code>Token_English</code> and <code>Token_Any</code> modules.  A substantial
example is given as <code>english_token_to_words</code> in
`<tt>festival/lib/token.scm</tt>'.

</p><p>An example of this function is in
`<tt>lib/token.scm</tt>'.  It is quite elaborate and covers most of the
common multi-word tokens in English including, numbers, money symbols,
Roman numerals, dates, times, plurals of symbols, number ranges,
telephone number and various other symbols.

</p><p>Let us look at the treatment of one particular phenomena which shows
the use of these rules.  Consider the expression &quot;$12 million&quot; which
should be rendered as the words &quot;twelve million dollars&quot;.  Note the word
&quot;dollars&quot; which is introduced by the &quot;$&quot; sign, ends up after the end of
the expression.  There are two cases we need to deal with as there are
two tokens.  The first condition in the <code>cond</code> checks if the
current token name is a money symbol, while the second condition check
that following word is a magnitude (million, billion, trillion, zillion
etc.)  If that is the case the &quot;$&quot; is removed and the remaining numbers
are pronounced, by calling the builtin token to word function.  The
second condition deals with the second token.  It confirms the previous
is a money value (the same regular expression as before) and then
returns the word followed by the word &quot;dollars&quot;.  If it is neither of
these forms then the builtin function is called.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(define (token_to_words token name)
&quot;(token_to_words TOKEN NAME)
Returns a list of words for NAME from TOKEN.&quot;
 (cond
  ((and (string-matches name &quot;\\$[0-9,]+\\(\\.[0-9]+\\)?&quot;)
        (string-matches (item.feat token &quot;n.name&quot;) &quot;.*illion.?&quot;))
   (builtin_english_token_to_words token (string-after name &quot;$&quot;)))
  ((and (string-matches (item.feat token &quot;p.name&quot;)
                          &quot;\\$[0-9,]+\\(\\.[0-9]+\\)?&quot;)
        (string-matches name &quot;.*illion.?&quot;))
   (list 
    name
    &quot;dollars&quot;))
  (t
   (builtin_english_token_to_words token name))))
</pre></td></tr></table><p>It is valid to make some conditions return no words, though some care
should be taken with that, as punctuation information may no longer be
available to later processing if there are no words related to
a token.

</p><hr size="6">
<a name="NOD55"></a>
<a name="SEC58"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC57" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC59" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC55" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC55" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC61" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 15.3 Homograph disambiguation </h2>

<p>Not all tokens can be rendered as words easily.  Their context may affect
the way they are to be pronounced.  For example in the 
utterance
</p><table><tr><td>&nbsp;</td><td><pre class="example">On May 5 1985, 1985 people moved to Livingston.
</pre></td></tr></table><p>the tokens &quot;1985&quot; should be pronounced differently, the first as
a year, &quot;nineteen eighty five&quot; while the second as a quantity &quot;one
thousand nine hundred and eighty five&quot;.  Numbers may also be pronounced
as ordinals as in the &quot;5&quot; above, it should be &quot;fifth&quot; rather than
&quot;five&quot;.

</p><p>Also, the pronunciation of certain words cannot simply be found from
their orthographic form alone.  Linguistic part of speech tags help to
disambiguate a large class of homographs, e.g. &quot;lives&quot;.  A part of
speech tagger is included in Festival and discussed in <a href="#SEC61">POS tagging</a>.  But even part of speech isn't sufficient in a number of
cases.  Words such as &quot;bass&quot;, &quot;wind&quot;, &quot;bow&quot; etc cannot by distinguished
by part of speech alone, some semantic information is also required.  As
full semantic analysis of text is outwith the realms of Festival's
capabilities some other method for disambiguation is required.

</p><p>Following the work of <cite>yarowsky96</cite> we have included a method
for identified tokens to be further labelled with extra tags to
help identify their type.  Yarowsky uses <em>decision lists</em> to
identify different types for homographs.  Decision lists are
a restricted form of decision trees which have some advantages
over full trees, they are easier to build and Yarowsky has shown
them to be adequate for typical homograph resolution.

</p><hr size="6">
<a name="SEC59"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC58" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC60" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC55" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC58" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC61" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 15.3.1 Using disambiguators </h3>

<p>Festival offers a method for assigning a <code>token_pos</code> feature to
each token.  It does so using Yarowsky-type disambiguation techniques.
A list of disambiguators can be provided in the variable
<code>token_pos_cart_trees</code>.  Each disambiguator consists of a regular
expression and a CART tree (which may be a decision list as they have the
same format).  If a token matches the regular expression the CART tree
is applied to the token and the resulting class is assigned 
to the token via the feature <code>token_pos</code>.  This is done
by the <code>Token_POS</code> module.

</p><p>For example, the follow disambiguator distinguishes &quot;St&quot; (street and saint)
and &quot;Dr&quot; (doctor and drive).
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">   (&quot;\\([dD][Rr]\\|[Ss][tT]\\)&quot;
    ((n.name is 0)
     ((p.cap is 1)
      ((street))
      ((p.name matches &quot;[0-9]*\\(1[sS][tT]\\|2[nN][dD]\\|3[rR][dD]\\|[0-9][tT][hH]\\)&quot;)
       ((street))
       ((title))))
     ((punc matches &quot;.*,.*&quot;)
      ((street))
      ((p.punc matches &quot;.*,.*&quot;)
       ((title))
       ((n.cap is 0)
        ((street))
        ((p.cap is 0)
         ((p.name matches &quot;[0-9]*\\(1[sS][tT]\\|2[nN][dD]\\|3[rR][dD]\\|[0-9][tT][hH]\\)&quot;)
          ((street))
          ((title)))
         ((pp.name matches &quot;[1-9][0-9]+&quot;)
          ((street))
          ((title)))))))))
</pre></td></tr></table><p>Note that these only assign values for the feature <code>token_pos</code> and
do nothing more.  You must have a related token to word rule that
interprets this feature value and does the required translation.  For
example the corresponding token to word rule for the above disambiguator
is
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">  ((string-matches name &quot;\\([dD][Rr]\\|[Ss][tT]\\)&quot;)
   (if (string-equal (item.feat token &quot;token_pos&quot;) &quot;street&quot;)
       (if (string-matches name &quot;[dD][rR]&quot;)
           (list &quot;drive&quot;)
           (list &quot;street&quot;))
       (if (string-matches name &quot;[dD][rR]&quot;)
           (list &quot;doctor&quot;)
           (list &quot;saint&quot;))))
</pre></td></tr></table>
<hr size="6">
<a name="SEC60"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC59" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC61" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC55" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC58" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC61" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 15.3.2 Building disambiguators </h3>

<p>Festival offers some support for building disambiguation trees.  The
basic method is to find all occurrences of a homographic token in a large
text database, label each occurrence into classes, extract appropriate
context features for these tokens and finally build an classification tree
or decision list based on the extracted features.

</p><p>The extraction and building of trees is not yet a fully automated
process in Festival but the file `<tt>festival/examples/toksearch.scm</tt>'
shows some basic Scheme code we use for extracting tokens from very
large collections of text.

</p><p>The function <code>extract_tokens</code> does the real work.  It reads the
given file, token by token into a token stream.  Each token is tested
against the desired tokens and if there is a match the named features
are extracted.  The token stream will be extended to provide the
necessary context.  Note that only some features will make any sense in
this situation.  There is only a token relation so referring to words,
syllables etc. is not productive.

</p><p>In this example databases are identified by a file that lists all
the files in the text databases.  Its name is expected to be
`<tt>bin/DBNAME.files</tt>' where <code>DBNAME</code> is the name of
the database.  The file should contain a list
of filenames in the database e.g for the Gutenberg texts the
file `<tt>bin/Gutenberg.files</tt>' contains
</p><table><tr><td>&nbsp;</td><td><pre class="example">gutenberg/etext90/bill11.txt
gutenberg/etext90/const11.txt
gutenberg/etext90/getty11.txt
gutenberg/etext90/jfk11.txt
...
</pre></td></tr></table>
<p>Extracting the tokens is typically done in two passes.  The first pass
extracts the context (I've used 5 tokens either side).  It extracts 
the file and position, so the token is identified, and the word
in context.

</p><p>Next those examples should be labelled with a small set of classes
which identify the type of the token.  For example for a token
like &quot;Dr&quot; whether it is a person's title or a street identifier.
Note that hand-labelling can be laborious, though it is surprising
how few tokens of particular types actually exist in 62 million
words.

</p><p>The next task is to extract the tokens with the features that will best
distinguish the particular token.  In our &quot;Dr&quot; case this will involve
punctuation around the token, capitalisation of surrounding tokens etc.
After extracting the distinguishing tokens you must line up the labels
with these extracted features.  It would be easier to extract both the
context and the desired features at the same time but experience shows
that in labelling, more appropriate features come to mind that will
distinguish classes better and you don't want to have to label twice.

</p><p>Once a set of features consisting of the label and features is created
it is easy to use `<tt>wagon</tt>' to create the corresponding decision tree
or decision list.  `<tt>wagon</tt>' supports both decision trees and decision
lists, it may be worth experimenting to find out which give the best
results on some held out test data.  It appears that decision trees are
typically better, but are often much larger, and the size does not
always justify the the sometimes only slightly better results.

</p><hr size="6">
<a name="NOD56"></a>
<a name="SEC61"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC60" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC62" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC55" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC62" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 16. POS tagging </h1>

<p>Part of speech tagging is a fairly well-defined process.  Festival
includes a part of speech tagger following the HMM-type taggers as found
in the Xerox tagger and others (e.g. <cite>DeRose88</cite>).  Part of speech
tags are assigned, based on the probability distribution of tags given a
word, and from ngrams of tags.  These models are externally specified
and a Viterbi decoder is used to assign part of speech tags at run time.

</p><p>So far this tagger has only been used for English but there
is nothing language specific about it.  The module <code>POS</code>
assigns the tags.  It accesses the following variables for
parameterization.
</p><dl compact="compact">
<dt><code> pos_lex_name</code></dt>
<dd><p>The name of a &quot;lexicon&quot; holding reverse probabilities of words
given a tag (indexed by word).  If this is unset or has the
value <code>NIL</code> no part of speech tagging takes place.
</p></dd>
<dt><code> pos_ngram_name</code></dt>
<dd><p>The name of a loaded ngram model of part of speech tags (loaded
by <code>ngram.load</code>).
</p></dd>
<dt><code> pos_p_start_tag</code></dt>
<dd><p>The name of the most likely tag before the start of an utterance.
This is typically the tag for sentence final punctuation marks.
</p></dd>
<dt><code> pos_pp_start_tag</code></dt>
<dd><p>The name of the most likely tag two before the start of an utterance.
For English the is typically a simple noun, but for other languages
it might be a verb.  If the ngram model is bigger than three
this tag is effectively repeated for the previous left contexts.
</p></dd>
<dt><code> pos_map</code></dt>
<dd><p>We have found that it is often better to use a rich tagset for
prediction of part of speech tags but that in later use (phrase breaks
and dictionary lookup) a much more constrained tagset is better.  Thus
mapping of the predicted tagset to a different tagset is supported.
<code>pos_map</code> should be a a list of pairs consisting of a list of tags
to be mapped and the new tag they are to be mapped to.
</p></dd>
</dl>

<p>Note is it important to have the part of speech tagger match 
the tags used in later parts of the system, particularly the
lexicon.  Only two of our lexicons used so far have
(mappable) part of speech labels.

</p><p>An example of the part of speech tagger for English can be found in
`<tt>lib/pos.scm</tt>'.

</p><hr size="6">
<a name="NOD57"></a>
<a name="SEC62"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC61" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC63" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC61" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC63" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 17. Phrase breaks </h1>

<p>There are two methods for predicting phrase breaks in Festival, one
simple and one sophisticated.  These two methods are selected through
the parameter <code>Phrase_Method</code> and phrasing is achieved by the
module <code>Phrasify</code>.

</p><p>The first method is by CART tree.  If parameter <code>Phrase_Method</code> is
<code>cart_tree</code>, the CART tree in the variable <code>phrase_cart_tree</code>
is applied to each word to see if a break should be inserted or not.
The tree should predict categories <code>BB</code> (for big break), <code>B</code>
(for break) or <code>NB</code> (for no break).  A simple example of a tree to
predict phrase breaks is given in the file `<tt>lib/phrase.scm</tt>'.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(set! simple_phrase_cart_tree
'
((R:Token.parent.punc in (&quot;?&quot; &quot;.&quot; &quot;:&quot;))
  ((BB))
  ((R:Token.parent.punc in (&quot;'&quot; &quot;\&quot;&quot; &quot;,&quot; &quot;;&quot;))
   ((B))
   ((n.name is 0)
    ((BB))
    ((NB))))))
</pre></td></tr></table>
<p>The second and more elaborate method of phrase break prediction is used
when the parameter <code>Phrase_Method</code> is <code>prob_models</code>.  In this
case a probabilistic model using probabilities of a break after a word
based on the part of speech of the neighbouring words and the previous
word.  This is combined with a ngram model of the distribution of breaks
and non-breaks using a Viterbi decoder to find the optimal phrasing of
the utterance.  The results using this technique are good and even show
good results on unseen data from other researchers' phrase break tests
(see <cite>black97b</cite>).  However sometimes it does sound wrong,
suggesting there is still further work required.

</p><p>Parameters for this module are set through the feature list held
in the variable <code>phr_break_params</code>, and example of which 
for English is set in <code>english_phr_break_params</code> in 
the file `<tt>lib/phrase.scm</tt>'.  The features names and meaning are

</p><dl compact="compact">
<dt><code> pos_ngram_name</code></dt>
<dd><p>The name of a loaded ngram that gives probability distributions of B/NB
given previous, current and next part of speech.
</p></dd>
<dt><code> pos_ngram_filename</code></dt>
<dd><p>The filename containing <code>pos_ngram_name</code>.
</p></dd>
<dt><code> break_ngram_name</code></dt>
<dd><p>The name of a loaded ngram of B/NB distributions.  This is typically
a 6 or 7-gram.
</p></dd>
<dt><code> break_ngram_filename</code></dt>
<dd><p>The filename containing <code>break_ngram_name</code>.
</p></dd>
<dt><code> gram_scale_s</code></dt>
<dd><p>A weighting factor for breaks in the break/non-break ngram.  Increasing
the value insertes more breaks, reducing it causes less breaks to be
inserted.
</p></dd>
<dt><code> phrase_type_tree</code></dt>
<dd><p>A CART tree that is used to predict type of break given the predict
break position.  This (rather crude) technique is current used to
distinguish major and minor breaks.
</p></dd>
<dt><code> break_tags</code></dt>
<dd><p>A list of the break tags (typically <code>(B NB)</code>).
</p></dd>
<dt><code> pos_map</code></dt>
<dd><p>A part of speech map used to map the <code>pos</code> feature of words
into a smaller tagset used by the phrase predictor.
</p></dd>
</dl>

<hr size="6">
<a name="NOD58"></a>
<a name="SEC63"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC62" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC64" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC62" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC70" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 18. Intonation </h1>

<p>A number of different intonation modules are available with
varying levels of control.  In general intonation is generated
in two steps.
</p><ol>
<li><p> Prediction of accents (and/or end tones) on a per
syllable basis.
</p></li><li><p> Prediction of F0 target values, this must be done after
durations are predicted.
</p></li></ol>

<p>Reflecting this split there are two main intonation modules that call
sub-modules depending on the desired intonation methods.  The
<code>Intonation</code> and <code>Int_Targets</code> modules are defined in Lisp
(`<tt>lib/intonation.scm</tt>') and call sub-modules which are (so far) in
C++.

</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC64">18.1 Default intonation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  Effectively none at all.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC65">18.2 Simple intonation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   Accents and hats.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC66">18.3 Tree intonation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     Accents and Tones, and F0 prediction by LR
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC67">18.4 Tilt intonation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     Using the Tilt intonation model
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC68">18.5 General intonation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  A programmable intonation module
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC69">18.6 Using ToBI</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          A ToBI by rule example
</td></tr>
</table>

<hr size="6">
<a name="NOD59"></a>
<a name="SEC64"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC63" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC65" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC63" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC63" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC70" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 18.1 Default intonation </h2>

<p>This is the simplest form of intonation and offers the modules
<code>Intonation_Default</code> and <code>Intonation_Targets_Default</code>.  The
first of which actually does nothing at all.
<code>Intonation_Targets_Default</code> simply creates a target at the start
of the utterance, and one at the end.  The values of which, by default
are 130 Hz and 110 Hz.  These values may be set through the 
parameter <code>duffint_params</code> for example the following will
general a monotone at 150Hz.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(set! duffint_params '((start 150) (end 150)))
(Parameter.set 'Int_Method 'DuffInt)
(Parameter.set 'Int_Target_Method Int_Targets_Default)
</pre></td></tr></table>
<hr size="6">
<a name="NOD60"></a>
<a name="SEC65"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC64" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC66" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC63" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC63" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC70" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 18.2 Simple intonation </h2>

<p>This module uses the CART tree in <code>int_accent_cart_tree</code> to predict
if each syllable is accented or not.  A predicted value of <code>NONE</code>
means no accent is generated by the corresponding <code>Int_Targets_Simple</code>
function.  Any other predicted value will cause a `hat' accent to be
put on that syllable.

</p><p>A default <code>int_accent_cart_tree</code> is available in the value
<code>simple_accent_cart_tree</code> in `<tt>lib/intonation.scm</tt>'.  It simply
predicts accents on the stressed syllables on content words in
poly-syllabic words, and on the only syllable in single syllable content
words.  Its form is
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(set! simple_accent_cart_tree
 '
  ((R:SylStructure.parent.gpos is content)
   ((stress is 1)
    ((Accented))
    ((position_type is single)
     ((Accented))
     ((NONE))))
   ((NONE))))
</pre></td></tr></table>
<p>The function <code>Int_Targets_Simple</code> uses parameters in the a-list
in variable <code>int_simple_params</code>.  There are two interesting
parameters <code>f0_mean</code> which gives the mean F0 for this speaker
(default 110 Hz) and <code>f0_std</code> is the standard deviation of
F0 for this speaker (default 25 Hz).  This second value is used
to determine the amount of variation to be put in the generated
targets.

</p><a name="IDX181"></a>
<p>For each Phrase in the given utterance an F0 is generated starting at
<code>f0_code+(f0_std*0.6)</code> and declines <code>f0_std</code> Hz over the
length of the phrase until the last syllable whose end is set to
<code>f0_code-f0_std</code>.  An imaginary line called <code>baseline</code> is
drawn from start to the end (minus the final extra fall), For each
syllable that is accented (i.e. has an IntEvent related to it) three
targets are added.  One at the start, one in mid vowel, and one at the
end.  The start and end are at position <code>baseline</code> Hz (as declined
for that syllable) and the mid vowel is set to <code>baseline+f0_std</code>.

</p><p>Note this model is not supposed to be complex or comprehensive but it
offers a very quick and easy way to generate something other than a
fixed line F0.  Something similar to this has been for Spanish and Welsh
without (too many) people complaining.  However it is not designed as a
serious intonation module.

</p><hr size="6">
<a name="NOD61"></a>
<a name="SEC66"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC65" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC67" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC63" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC63" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC70" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 18.3 Tree intonation </h2>

<p>This module is more flexible.  Two different CART trees can be used to
predict `accents' and `endtones'.  Although at present this module is
used for an implementation of the ToBI intonation labelling system it
could be used for many different types of intonation system.

</p><p>The target module for this method uses a Linear Regression model to
predict start mid-vowel and end targets for each syllable using
arbitrarily specified features.  This follows the work described in
<cite>black96</cite>.  The LR models are held as as described below
See section <a href="#SEC114">Linear regression</a>.  Three models are used in the variables
<code>f0_lr_start</code>, <code>f0_lr_mid</code> and <code>f0_lr_end</code>.

</p><hr size="6">
<a name="NOD62"></a>
<a name="SEC67"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC66" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC68" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC63" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC63" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC70" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 18.4 Tilt intonation </h2>

<p>Tilt description to be inserted.

</p><hr size="6">
<a name="NOD63"></a>
<a name="SEC68"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC67" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC69" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC63" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC63" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC70" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 18.5 General intonation </h2>

<p>As there seems to be a number of intonation theories that predict
F0 contours by rule (possibly using trained parameters) this
module aids the external specification of such rules for a wide
class of intonation theories (through primarily those that might
be referred to as the ToBI group).  This is designed to be multi-lingual
and offer a quick way to port often pre-existing rules into Festival
without writing new C++ code.

</p><p>The accent prediction part uses the same mechanisms as the Simple
intonation method described above, a decision tree for
accent prediction, thus the tree in the variable
<code>int_accent_cart_tree</code> is used on each syllable to predict
an <code>IntEvent</code>.

</p><p>The target part calls a specified Scheme function which returns
a list of target points for a syllable.  In this way any arbitrary
tests may be done to produce the target points.  For example
here is a function which returns three target points
for each syllable with an <code>IntEvent</code> related to it (i.e. 
accented syllables).
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(define (targ_func1 utt syl)
  &quot;(targ_func1 UTT STREAMITEM)
Returns a list of targets for the given syllable.&quot;
  (let ((start (item.feat syl 'syllable_start))
        (end (item.feat syl 'syllable_end)))
    (if (equal? (item.feat syl &quot;R:Intonation.daughter1.name&quot;) &quot;Accented&quot;)
        (list
         (list start 110)
         (list (/ (+ start end) 2.0) 140)
         (list end 100)))))
</pre></td></tr></table><p>This function may be identified as the function to call by
the following setup parameters.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(Parameter.set 'Int_Method 'General)
(Parameter.set 'Int_Target_Method Int_Targets_General)

(set! int_general_params
      (list 
       (list 'targ_func targ_func1)))
</pre></td></tr></table>
<hr size="6">
<a name="NOD64"></a>
<a name="SEC69"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC68" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC70" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC63" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC63" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC70" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 18.6 Using ToBI </h2>

<p>An example implementation of a ToBI to F0 target module is included in
`<tt>lib/tobi_rules.scm</tt>' based on the rules described in <cite>jilka96</cite>.
This uses the general intonation method discussed in the previous
section.  This is designed to be useful to people who are experimenting
with ToBI (<cite>silverman92</cite>), rather than general text to speech.

</p><p>To use this method you need to load `<tt>lib/tobi_rules.scm</tt>' and
call <code>setup_tobi_f0_method</code>.  The default is in a male's
pitch range, i.e. for <code>voice_rab_diphone</code>.  You can change
it for other pitch ranges by changing the folwoing variables.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(Parameter.set 'Default_Topline 110)
(Parameter.set 'Default_Start_Baseline 87)
(Parameter.set 'Default_End_Baseline 83)
(Parameter.set 'Current_Topline (Parameter.get 'Default_Topline))
(Parameter.set 'Valley_Dip 75)
</pre></td></tr></table>
<p>An example using this from STML is given in `<tt>examples/tobi.stml</tt>'.
But it can also be used from Scheme.  For example before
defining an utterance you should execute the following either
from teh command line on in some setup file
</p><table><tr><td>&nbsp;</td><td><pre class="example">(voice_rab_diphone)
(require 'tobi_rules)
(setup_tobi_f0_method)
</pre></td></tr></table><p>In order to allow specification of accents, tones, and break levels
you must use an utterance type that allows such specification.  For
example
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(Utterance 
 Words
 (boy
  (saw ((accent H*)))
   the
   (girl ((accent H*)))
   in the 
   (park ((accent H*) (tone H-)))
   with the 
   (telescope ((accent H*) (tone H-H%)))))

(Utterance Words 
 (The
  (boy ((accent L*)))
  saw
  the
  (girl ((accent H*) (tone L-)))
  with 
  the
  (telescope ((accent H*) (tone H-H%))))))
</pre></td></tr></table><p>You can display the the synthesized form of these utterance in
Xwaves.  Start an Xwaves and an Xlabeller and call the function
<code>display</code> on the synthesized utterance.

</p><hr size="6">
<a name="NOD65"></a>
<a name="SEC70"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC69" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC71" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC63" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC75" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 19. Duration </h1>

<p>A number of different duration prediction modules are available with
varying levels of sophistication.

</p><p>Segmental duration prediction is done by the module <code>Duration</code>
which calls different actual methods depending on the parameter
<code>Duration_Method</code>.

</p><a name="IDX182"></a>
<p>All of the following duration methods may be further affected by both a
global duration stretch and a per word one.

</p><p>If the parameter <code>Duration_Stretch</code> is set, all absolute durations
predicted by any of the duration methods described here are multiplied by
the parameter's value.  For example
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(Parameter.set 'Duration_Stretch 1.2)
</pre></td></tr></table><p>will make everything speak more slowly.

</p><a name="IDX183"></a>
<p>In addition to the global stretch method, if the feature
<code>dur_stretch</code> on the related <code>Token</code> is set it will also be
used as a multiplicative factor on the duration produced by the selected
method.  That is <code>R:Syllable.parent.parent.R:Token.parent.dur_stretch</code>.
There is a lisp function <code>duration_find_stretch</code> wchi will return
the combined gloabel and local duration stretch factor for a given
segment item.

</p><p>Note these global and local methods of affecting the duration produced
by models are crude and should be considered hacks.  Uniform
modification of durations is not what happens in real speech.  These
parameters are typically used when the underlying duration method is
lacking in some way.  However these can be useful.

</p><p>Note it is quite easy to implement new duration methods in Scheme
directly.

</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC71">19.1 Default durations</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   Fixed length durations
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC72">19.2 Average durations</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC73">19.3 Klatt durations</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     Klatt rules from book.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC74">19.4 CART durations</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">      Tree based durations
</td></tr>
</table>

<hr size="6">
<a name="NOD66"></a>
<a name="SEC71"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC70" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC72" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC70" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC70" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC75" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 19.1 Default durations </h2>

<p>If parameter <code>Duration_Method</code> is set to <code>Default</code>, the
simplest duration model is used.  All segments are 100 milliseconds
(this can be modified by <code>Duration_Stretch</code>, and/or the localised
Token related <code>dur_stretch</code> feature).

</p><hr size="6">
<a name="NOD67"></a>
<a name="SEC72"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC71" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC73" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC70" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC70" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC75" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 19.2 Average durations </h2>

<p>If parameter <code>Duration_Method</code> is set to <code>Averages</code>
then segmental durations are set to their averages.  The variable
<code>phoneme_durations</code> should be an a-list of phones and averages
in seconds.  The file `<tt>lib/mrpa_durs.scm</tt>' has an example for
the mrpa phoneset.

</p><p>If a segment is found that does not appear in the list a default
duration of 0.1 seconds is assigned, and a warning message generated.

</p><hr size="6">
<a name="NOD68"></a>
<a name="SEC73"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC72" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC74" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC70" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC70" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC75" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 19.3 Klatt durations </h2>

<p>If parameter <code>Duration_Method</code> is set to <code>Klatt</code> the duration
rules from the Klatt book (<cite>allen87</cite>, chapter 9).  This method
requires minimum and inherent durations for each phoneme in the
phoneset.  This information is held in the variable
<code>duration_klatt_params</code>.  Each member of this list is a
three-tuple, of phone name, inherent duration and minimum duration.  An
example for the mrpa phoneset is in `<tt>lib/klatt_durs.scm</tt>'.

</p><hr size="6">
<a name="NOD69"></a>
<a name="SEC74"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC73" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC75" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC70" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC70" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC75" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 19.4 CART durations </h2>

<p>Two very similar methods of duration prediction by CART tree
are supported.  The first, used when parameter <code>Duration_Method</code>
is <code>Tree</code> simply predicts durations directly for each segment.
The tree is set in the variable <code>duration_cart_tree</code>.

</p><p>The second, which seems to give better results, is used when parameter
<code>Duration_Method</code> is <code>Tree_ZScores</code>. In this second model the
tree predicts zscores (number of standard deviations from the mean)
rather than duration directly.  (This follows <cite>campbell91</cite>, but we
don't deal in syllable durations here.)  This method requires means and
standard deviations for each phone.  The variable
<code>duration_cart_tree</code> should contain the zscore prediction tree and
the variable <code>duration_ph_info</code> should contain a list of phone,
mean duration, and standard deviation for each phone in the phoneset.

</p><p>An example tree trained from 460 sentences spoken by Gordon is
in `<tt>lib/gswdurtreeZ</tt>'.  Phone means and standard deviations
are in `<tt>lib/gsw_durs.scm</tt>'.

</p><p>After prediction the segmental duration is calculated by
the simple formula
</p><table><tr><td>&nbsp;</td><td><pre class="example">duration = mean + (zscore * standard deviation)
</pre></td></tr></table>
<p>For some other duration models that affect an inherent duration by
some factor this method has been used.  If the tree predicts factors
rather than zscores and the <code>duration_ph_info</code> entries
are phone, 0.0, inherent duration. The above formula will generate the
desired result.  Klatt and Klatt-like rules can be implemented in the
this way without adding a new method.

</p><hr size="6">
<a name="NOD70"></a>
<a name="SEC75"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC74" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC76" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC70" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC84" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 20. UniSyn synthesizer </h1>

<p>Since 1.3 a new general synthesizer module has been included.  This
designed to replace the older diphone synthesizer described in the
next chapter.   A redesign was made in order to have a generalized
waveform synthesizer, singla processing module that could be used
even when the units being concatenated are not diphones.  Also at
this stage the full diphone (or other) database pre-processing
functions were added to the Speech Tool library.

</p><hr size="6">
<a name="SEC76"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC75" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC77" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC75" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC75" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC84" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 20.1 UniSyn database format </h2>

<p>The Unisyn synthesis modules can use databases in two basic
formats, <em>separate</em> and <em>grouped</em>.  Separate is when
all files (signal, pitchmark and coefficient files) are accessed
individually during synthesis.  This is the standard use during
databse development.  Group format is when a database is collected
together into a single special file containing all information
necessary for waveform synthesis.  This format is designed to
be used for distribution and general use of the database.

</p><p>A database should consist of a set of waveforms, (which may be
translated into a set of coefficients if the desired the signal
processing method requires it), a set of pitchmarks and an index.  The
pitchmarks are necessary as most of our current signal processing are
pitch synchronous.  

</p><hr size="6">
<a name="SEC77"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC76" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC78" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC75" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC76" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC84" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.1.1 Generating pitchmarks </h3>

<p>Pitchmarks may be derived from laryngograph files using the our
proved program `<tt>pitchmark</tt>' distributed with the speech
tools.  The actual parameters to this program are still a bit of
an art form.  The first major issue is which direction the lar
files.  We have seen both, though it does seem to be CSTR's ones
are most often upside down while others (e.g. OGI's) are the right way
up.  The <code>-inv</code> argument to `<tt>pitchmark</tt>' is specifically
provided to cater for this.  There other issues in getting the
pitchmarks aligned.  The basic command for generating pitchmarks
is
</p><table><tr><td>&nbsp;</td><td><pre class="example">pitchmark -inv lar/file001.lar -o pm/file001.pm -otype est \
     -min 0.005 -max 0.012 -fill -def 0.01 -wave_end
</pre></td></tr></table><p>The `<tt>-min</tt>', `<tt>-max</tt>' and `<tt>-def</tt>' (fill values for unvoiced
regions), may need to be changed depending on the speaker pitch
range.  The above is suitable for a male speaker.  The `<tt>-fill</tt>'
option states that unvoiced sections should be filled with equally
spaced pitchmarks.

</p><hr size="6">
<a name="SEC78"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC77" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC79" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC75" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC76" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC84" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.1.2 Generating LPC coefficients </h3>

<p>LPC coefficients are generated using the `<tt>sig2fv</tt>' command.  Two
stages are required, generating the LPC coefficients and generating
the residual.  The prototypical commands for these are
</p><table><tr><td>&nbsp;</td><td><pre class="example">sig2fv wav/file001.wav -o lpc/file001.lpc -otype est -lpc_order 16 \
    -coefs &quot;lpc&quot; -pm pm/file001.pm -preemph 0.95 -factor 3 \
    -window_type hamming
sigfilter wav/file001.wav -o lpc/file001.res -otype nist \
    -lpcfilter lpc/file001.lpc -inv_filter
</pre></td></tr></table><a name="IDX184"></a>
<p>For some databases you may need to normalize the power.  Properly
normalizing power is difficult but we provide a simple function which may
do the jobs acceptably.  You should do this on the waveform before
lpc analysis (and ensure you also do the residual extraction on the normalized
waveform rather than the original.
</p><table><tr><td>&nbsp;</td><td><pre class="example">ch_wave -scaleN 0.5 wav/file001.wav -o file001.Nwav
</pre></td></tr></table><p>This normalizes the power by maximizing the signal first then multiplying
it by the given factor.  If the database waveforms are clean (i.e.
no clicks) this can give reasonable results.

</p><hr size="6">
<a name="SEC79"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC78" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC80" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC75" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC75" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC84" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 20.2 Generating a diphone index </h2>

<p>The diphone index consists of a short header following by an
ascii list of each diphone, the file it comes from followed by its 
start middle and end times in seconds.  For most databases this
files needs to be generated by some database specific script.

</p><p>An example header is
</p><table><tr><td>&nbsp;</td><td><pre class="example">EST_File index
DataType ascii
NumEntries 2005
IndexName rab_diphone
EST_Header_End
</pre></td></tr></table><p>The most notable part is the number of entries, which you should note
can get out of sync with the actual number of entries if you hand
edit entries.  I.e. if you add an entry and the system still 
can't find it check that the number of entries is right.

</p><p>The entries themselves may take on one of two forms, full
entries or index entries.  Full entries consist of a diphone
name, where the phones are separated by &quot;-&quot;; a file name 
which is used to index into the pitchmark, LPC and waveform file;
and the start, middle (change over point between phones) and end
of the phone in the file in seconds of the diphone.  For example
</p><table><tr><td>&nbsp;</td><td><pre class="example">r-uh    edx_1001        0.225   0.261   0.320
r-e     edx_1002        0.224   0.273   0.326
r-i     edx_1003        0.240   0.280   0.321
r-o     edx_1004        0.212   0.253   0.320
</pre></td></tr></table><p>The second form of entry is an index entry which 
simply states that reference to that diphone should actually be made
to another.  For example
</p><table><tr><td>&nbsp;</td><td><pre class="example">aa-ll   &amp;aa-l
</pre></td></tr></table><p>This states that the diphone <code>aa-ll</code> should actually use the
diphone <code>aa-l</code>.  Note they are a number of ways to specify
alternates for missing diphones an this method is best used for fixing
single or small classes of missing or broken diphones.  Index
entries may appear anywhere in the file but can't be nested.

</p><p>Some checks are made one reading this index to ensure times etc
are reasonable but multiple entries for the same diphone are not, in
that case the later one will be selected.

</p><hr size="6">
<a name="SEC80"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC79" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC81" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC75" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC75" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC84" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 20.3 Database declaration </h2>

<p>There two major types of database <em>grouped</em> and <em>ungrouped</em>.
Grouped databases come as a single file containing the diphone index,
coeficinets and residuals for the diphones.  This is the standard way
databases are distributed as voices in Festoval.  Ungrouped
access diphones from individual files and is designed as a method
for debugging and testing databases before distribution.  Using
ungrouped dataabse is slower but allows quicker changes to the index,
and associated coefficient files and residuals without rebuilding the
group file.

</p><a name="IDX185"></a>
<p>A database is declared to the system through the command
<code>us_diphone_init</code>.  This function takes a parameter list of
various features used for setting up a database.  The features are
</p><dl compact="compact">
<dt><code> name</code></dt>
<dd><p>An atomic name for this database, used in selecting it from the current
set of laded database.
</p></dd>
<dt><code> index_file</code></dt>
<dd><p>A filename name containing either a diphone index, as descripbed above,
or a group file.  The feature <code>grouped</code> defines the distinction
between this being a group of simple index file.
</p></dd>
<dt><code> grouped</code></dt>
<dd><p>Takes the value <code>&quot;true&quot;</code> or <code>&quot;false&quot;</code>.  This defined
simple index or if the index file is a grouped file.
</p></dd>
<dt><code> coef_dir</code></dt>
<dd><p>The directory containing the coefficients, (LPC or just pitchmarks in
the PSOLA case).  
</p></dd>
<dt><code> sig_dir</code></dt>
<dd><p>The directory containing the signal files (residual for LPC, full waveforms
for PSOLA).
</p></dd>
<dt><code> coef_ext</code></dt>
<dd><p>The extension for coefficient files, typically <code>&quot;.lpc&quot;</code> for LPC
file and <code>&quot;.pm&quot;</code> for pitchmark files.
</p></dd>
<dt><code> sig_ext</code></dt>
<dd><p>The extension for signal files, typically <code>&quot;.res&quot;</code> for LPC residual
files and <code>&quot;.wav&quot;</code> for waveform files.
</p></dd>
<dt><code> default_diphone</code></dt>
<dd><a name="IDX186"></a>
<p>The diphone to be used when the requested one doesn't exist.  No matter
how careful you are you should always include a default diphone for
distributed diphone database.   Synthesis will throw an error if 
no diphone is found and there is no default.  Although it is usually
an error when this is required its better to fill in something than
stop synthesizing.  Typical values for this are silence to silence
or schwa to schwa.
</p></dd>
<dt><code> alternates_left</code></dt>
<dd><a name="IDX187"></a>
<a name="IDX188"></a>
<p>A list of pairs showing the alternate phone names for the left phone in
a diphone pair.  This is list is used to rewrite the diphone name when
the directly requested one doesn't exist.  This is the recommended
method for dealing with systematic holes in a diphone database.
</p></dd>
<dt><code> alternates_right</code></dt>
<dd><p>A list of pairs showing the alternate phone names for the right phone in
a diphone pair.  This is list is used to rewrite the diphone name when
the directly requested one doesn't exist.  This is the recommended
method for dealing with systematic holes in a diphone database.
</p></dd>
</dl>

<p>An example database definition is 
</p><table><tr><td>&nbsp;</td><td><pre class="example">(set! rab_diphone_dir &quot;/projects/festival/lib/voices/english/rab_diphone&quot;)
(set! rab_lpc_group 
      (list
       '(name &quot;rab_lpc_group&quot;)
       (list 'index_file 
             (path-append rab_diphone_dir &quot;group/rablpc16k.group&quot;))
       '(alternates_left ((i ii) (ll l) (u uu) (i@ ii) (uh @) (a aa)
                                 (u@ uu) (w @) (o oo) (e@ ei) (e ei)
                                 (r @)))
       '(alternates_right ((i ii) (ll l) (u uu) (i@ ii) 
                                  (y i) (uh @) (r @) (w @)))
       '(default_diphone @-@@)
       '(grouped &quot;true&quot;)))
(us_dipohone_init rab_lpc_group)
</pre></td></tr></table>
<hr size="6">
<a name="SEC81"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC80" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC82" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC75" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC75" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC84" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 20.4 Making groupfiles </h2>

<p>The function <code>us_make_group_file</code> will make a group file 
of the currently selected US diphone database.  It loads in all diphone
sin the dtabaase and saves them in the named file.  An optional
second argument allows specification of how the group file will
be saved.   These options are as a feature list.  There
are three possible options
</p><dl compact="compact">
<dt><code> track_file_format</code></dt>
<dd><p>The format for the coefficient files.  By default this is
<code>est_binary</code>, currently the only other alternative is <code>est_ascii</code>.
</p></dd>
<dt><code> sig_file_format</code></dt>
<dd><p>The format for the signal parts of the of the database.  By default
this is <code>snd</code> (Sun's Audio format).  This was choosen as it has
the smallest header and supports various sample formats.  Any format
supported by the Edinburgh Speech Tools is allowed.
</p></dd>
<dt><code> sig_sample_format</code></dt>
<dd><p>The format for the samples in the signal files.  By default this
is <code>mulaw</code>.  This is suitable when the signal files are LPC
residuals.  LPC residuals have a much smaller dynamic range that 
plain PCM files.  Because <code>mulaw</code> representation is half the size
(8 bits) of standard PCM files (16bits) this significantly reduces
the size of the group file while only marginally altering the quality of
synthesis (and from experiments the effect is not perceptible).  However
when saving group files where the signals are not LPC residuals (e.g.
in PSOLA) using this default <code>mulaw</code> is not recommended and
<code>short</code> should probably be used.
</p></dd>
</dl>

<hr size="6">
<a name="SEC82"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC81" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC83" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC75" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC75" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC84" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 20.5 UniSyn module selection </h2>

<p>In a voice selection a UniSyn database may be selected as follows
</p><table><tr><td>&nbsp;</td><td><pre class="example">  (set! UniSyn_module_hooks (list rab_diphone_const_clusters ))
  (set! us_abs_offset 0.0)
  (set! window_factor 1.0)
  (set! us_rel_offset 0.0)
  (set! us_gain 0.9)

  (Parameter.set 'Synth_Method 'UniSyn)
  (Parameter.set 'us_sigpr 'lpc)
  (us_db_select rab_db_name)
</pre></td></tr></table><p>The <code>UniSyn_module_hooks</code> are run before synthesis, see the next
selection about diphone name selection.  At present only <code>lpc</code>
is supported by the UniSyn module, though potentially there may be
others.

</p><a name="IDX189"></a>
<a name="IDX190"></a>
<p>An optional implementation of TD-PSOLA <cite>moulines90</cite> has been
written but fear of legal problems unfortunately prevents it being in
the public distribution, but this policy should not be taken as
acknowledging or not acknowledging any alleged patent violation.

</p><hr size="6">
<a name="SEC83"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC82" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC84" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC75" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC75" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC84" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 20.6 Diphone selection </h2>

<p>Diphone names are constructed for each phone-phone pair in the Segment
relation in an utterance.  If a segment has the feature in forming a
diphone name UniSyn first checks for the feature <code>us_diphone_left</code>
(or <code>us_diphone_right</code> for the right hand part of the diphone) then
if that doesn't exist the feature <code>us_diphone</code> then if that doesn't
exist the feature <code>name</code>.  Thus is is possible to specify diphone
names which are not simply the concatenation of two segment names.

</p><p>This feature is used to specify consonant cluster diphone names
for our English voices.  The hook <code>UniSyn_module_hooks</code> is run 
before selection and we specify a function to add <code>us_diphone_*</code>
features as appropriate.  See the function <code>rab_diphone_fix_phone_name</code>
in `<tt>lib/voices/english/rab_diphone/festvox/rab_diphone.scm</tt>' for
an example.

</p><p>Once the diphone name is created it is used to select the diphone from
the database.  If it is not found the name is converted using the list
of <code>alternates_left</code> and <code>alternates_right</code> as specified in
the database declaration.  If that doesn't specify a diphone in the
database.  The <code>default_diphone</code> is selected, and a warning is
printed.  If no default diphone is specified or the default diphone
doesn't exist in the database an error is thrown.

</p><hr size="6">
<a name="NOD71"></a>
<a name="SEC84"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC83" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC85" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC75" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC91" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 21. Diphone synthesizer </h1>

<p><em>NOTE:</em> use of this diphone synthesis is depricated and it
will probably be removed from future versions, all of its functionality
has been replaced by the UniSyn synthesizer.  It is not
compiled by default, if required add <code>ALSO_INCLUDE += diphone</code>
to your `<tt>festival/config/config</tt>' file.

</p><a name="IDX191"></a>
<p>A basic diphone synthesizer offers a method
for making speech from segments, durations and intonation
targets.  This module was mostly written by Alistair Conkie
but the base diphone format is compatible with previous CSTR 
diphone synthesizers.

</p><p>The synthesizer offers residual excited LPC based synthesis (<cite>hunt89</cite>)
and PSOLA (TM) (<cite>moulines90</cite>) (PSOLA is not available for
distribution).

</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC85">21.1 Diphone database format</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  Format of basic dbs
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC86">21.2 LPC databases</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         Building and using LPC files.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC87">21.3 Group files</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Efficient binary formats
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC88">21.4 Diphone_Init</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Loading diphone databases
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC89">21.5 Access strategies</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     Various access methods
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC90">21.6 Diphone selection</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     Mapping phones to special diphone names
</td></tr>
</table>

<hr size="6">
<a name="NOD72"></a>
<a name="SEC85"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC84" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC86" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC84" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC84" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC91" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 21.1 Diphone database format </h2>

<p>A diphone database consists of a <em>dictionary file</em>, a set
of <em>waveform files</em>, and a set of <em>pitch mark files</em>.  These
files are the same format as the previous CSTR (Osprey) synthesizer.

</p><p>The dictionary file consist of one entry per line.  Each entry
consists of five fields: a diphone name of the form <var>P1-P2</var>, a
filename (without extension), a floating point start position in the
file in milliseconds, a mid position in milliseconds (change in phone),
and an end position in milliseconds.  Lines starting with a semi-colon
and blank lines are ignored.  The list may be in any order.

</p><p>For example a partial list of phones may look like.
</p><table><tr><td>&nbsp;</td><td><pre class="example">ch-l  r021   412.035  463.009  518.23  
jh-l  d747   305.841  382.301  446.018 
h-l   d748   356.814  403.54   437.522 
#-@   d404   233.628  297.345  331.327 
@-#   d001   836.814  938.761  1002.48 
</pre></td></tr></table>
<p>Waveform files may be in any form, as long as every file is the same
type, headered or unheadered as long as the format is supported the
speech tools wave reading functions.  These may be standard linear PCM
waveform files in the case of PSOLA or LPC coefficients and residual
when using the residual LPC synthesizer. <a href="#SEC86">LPC databases</a>

</p><p>Pitch mark files consist a simple list of positions in milliseconds
(plus places after the point) in order, one per line of each pitch mark
in the file.  For high quality diphone synthesis these should be derived
from laryngograph data.  During unvoiced sections pitch marks should be
artificially created at reasonable intervals (e.g. 10 ms).  In the
current format there is no way to determine the &quot;real&quot; pitch marks from
the &quot;unvoiced&quot; pitch marks.

</p><p>It is normal to hold a diphone database in a directory with
a number of sub-directories namely `<tt>dic/</tt>' contain
the dictionary file, `<tt>wave/</tt>' for the waveform files, typically
of whole nonsense words (sometimes this directory is called 
`<tt>vox/</tt>' for historical reasons) and `<tt>pm/</tt>' for
the pitch mark files.  The filename in the dictionary entry should
be the same for waveform file and the pitch mark file (with different
extensions).

</p><hr size="6">
<a name="NOD73"></a>
<a name="SEC86"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC85" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC87" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC84" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC84" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC91" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 21.2 LPC databases </h2>

<p>The standard method for diphone resynthesis in the released system is
residual excited LPC (<cite>hunt89</cite>).  The actual method of resynthesis
isn't important to the database format, but if residual LPC synthesis
is to be used then it is necessary to make the LPC coefficient
files and their corresponding residuals.

</p><p>Previous versions of the system used a &quot;host of hacky little scripts&quot;
to this but now that the Edinburgh Speech Tools supports LPC analysis
we can provide a walk through for generating these.

</p><p>We assume that the waveform file of nonsense words are in a directory
called `<tt>wave/</tt>'.  The LPC coefficients and residuals will be, in
this example, stored in `<tt>lpc16k/</tt>' with extensions `<tt>.lpc</tt>' and
`<tt>.res</tt>' respectively.

</p><p>Before starting it is worth considering power normalization.  We have
found this important on all of the databases we have collected so far.
The <code>ch_wave</code> program, part of the speech tools, with the optional
<code>-scaleN 0.4</code> may be used if a more complex method is not
available.

</p><p>The following shell command generates the files
</p><table><tr><td>&nbsp;</td><td><pre class="example">for i in wave/*.wav
do
   fname=`basename $i .wav`
   echo $i
   lpc_analysis -reflection -shift 0.01 -order 18 -o lpc16k/$fname.lpc \
       -r lpc16k/$fname.res -otype htk -rtype nist $i
done
</pre></td></tr></table><p>It is said that the LPC order should be sample rate divided by one
thousand plus 2.  This may or may not be appropriate and if you are
particularly worried about the database size it is worth experimenting.

</p><p>The program `<tt>lpc_analysis</tt>', found in `<tt>speech_tools/bin</tt>',
can be used to generate the LPC coefficients and residual.  Note
these should be reflection coefficients so they may be quantised
(as they are in group files).

</p><p>The coefficients and residual files produced by different LPC analysis
programs may start at different offsets.  For example the Entropic's ESPS
functions generate LPC coefficients that are offset by one frame shift
(e.g. 0.01 seconds).  Our own `<tt>lpc_analysis</tt>' routine has no offset.
The <code>Diphone_Init</code> parameter list allows these offsets to be
specified.  Using the above function to generate the LPC files the
description parameters should include
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">  (lpc_frame_offset 0)
  (lpc_res_offset 0.0)
</pre></td></tr></table><p>While when generating using ESPS routines the description should be
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">  (lpc_frame_offset 1)
  (lpc_res_offset 0.01)
</pre></td></tr></table><p>The defaults actually follow the ESPS form, that is <code>lpc_frame_offset</code>
is 1 and <code>lpc_res_offset</code> is equal to the frame shift, if they are
not explicitly mentioned.

</p><p>Note the biggest problem we have in implementing the residual excited
LPC resynthesizer was getting the right part of the residual to line up
with the right LPC coefficients describing the pitch mark.  Making
errors in this degrades the synthesized waveform notably, but not
seriously, making it difficult to determine if it is an offset problem or
some other bug.

</p><p>Although we have started investigating if extracting pitch synchronous
LPC parameters rather than fixed shift parameters gives better
performance, we haven't finished this work.  `<tt>lpc_analysis</tt>'
supports pitch synchronous analysis but the raw &quot;ungrouped&quot;
access method does not yet.  At present the LPC parameters are
extracted at a particular pitch mark by interpolating over the 
closest LPC parameters.  The &quot;group&quot; files hold these interpolated
parameters pitch synchronously.

</p><p>The American English voice `<tt>kd</tt>' was created using the speech
tools `<tt>lpc_analysis</tt>' program and its set up should
be looked at if you are going to copy it.  The British English voice
`<tt>rb</tt>' was constructed using ESPS routines.

</p><hr size="6">
<a name="NOD74"></a>
<a name="SEC87"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC86" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC88" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC84" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC84" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC91" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 21.3 Group files </h2>

<p>Databases may be accessed directly but this is usually too inefficient
for any purpose except debugging.  It is expected that <em>group
files</em> will be built which contain a binary representation of the
database.  A group file is a compact efficient representation of the
diphone database.  Group files are byte order independent, so may be
shared between machines of different byte orders and word sizes.
Certain information in a group file may be changed at load time so a
database name, access strategy etc. may be changed from what was set
originally in the group file.

</p><p>A group file contains the basic parameters, the diphone index, the
signal (original waveform or LPC residual), LPC coefficients, and the
pitch marks.  It is all you need for a run-time synthesizer.  
Various compression mechanisms are supported to allow smaller databases
if desired.  A full English LPC plus residual database at 8k ulaw
is about 3 megabytes, while a full 16 bit version at 16k is about
8 megabytes.

</p><p>Group files are created with the <code>Diphone.group</code> command which
takes a database name and an output filename as an argument.  Making
group files can take some time especially if they are large.  The
<code>group_type</code> parameter specifies <code>raw</code> or <code>ulaw</code>
for encoding signal files.  This can significantly reduce the size
of databases.

</p><p>Group files may be partially loaded (see access strategies) at
run time for quicker start up and to minimise run-time
memory requirements.

</p><hr size="6">
<a name="NOD75"></a>
<a name="SEC88"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC87" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC89" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC84" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC84" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC91" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 21.4 Diphone_Init </h2>

<p>The basic method for describing a database is through the <code>Diphone_Init</code>
command.  This function takes a single argument, a list of
pairs of parameter name and value.  The parameters are
</p><dl compact="compact">
<dt><code> name</code></dt>
<dd><p>An atomic name for this database.
</p></dd>
<dt><code> group_file</code></dt>
<dd><p>The filename of a group file, which may itself contain parameters
describing itself
</p></dd>
<dt><code> type</code></dt>
<dd><p>The default value is <code>pcm</code>, but for distributed voices
this is always <code>lpc</code>.
</p></dd>
<dt><code> index_file</code></dt>
<dd><p>A filename containing the diphone dictionary.
</p></dd>
<dt><code> signal_dir</code></dt>
<dd><p>A directory (slash terminated) containing the pcm waveform files.
</p></dd>
<dt><code> signal_ext</code></dt>
<dd><p>A dot prefixed extension for the pcm waveform files.
</p></dd>
<dt><code> pitch_dir</code></dt>
<dd><p>A directory (slash terminated) containing the pitch mark files.
</p></dd>
<dt><code> pitch_ext</code></dt>
<dd><p>A dot prefixed extension for the pitch files
</p></dd>
<dt><code> lpc_dir</code></dt>
<dd><p>A directory (slash terminated) containing the LPC coefficient files
and residual files.
</p></dd>
<dt><code> lpc_ext</code></dt>
<dd><p>A dot prefixed extension for the LPC coefficient files
</p></dd>
<dt><code> lpc_type</code></dt>
<dd><p>The type of LPC file (as supported by the speech tools)
</p></dd>
<dt><code> lpc_frame_offset</code></dt>
<dd><p>The number of frames &quot;missing&quot; from the beginning of the file.
Often LPC parameters are offset by one frame.
</p></dd>
<dt><code> lpc_res_ext</code></dt>
<dd><p>A dot prefixed extension for the residual files
</p></dd>
<dt><code> lpc_res_type</code></dt>
<dd><p>The type of the residual files, this is a standard waveform type
as supported by the speech tools.
</p></dd>
<dt><code> lpc_res_offset</code></dt>
<dd><p>Number of seconds &quot;missing&quot; from the beginning of the residual file.
Some LPC analysis technique do not generate a residual until after one
frame.
</p></dd>
<dt><code> samp_freq</code></dt>
<dd><p>Sample frequency of signal files
</p></dd>
<dt><code> phoneset</code></dt>
<dd><p>Phoneset used, must already be declared.
</p></dd>
<dt><code> num_diphones</code></dt>
<dd><p>Total number of diphones in database.  If specified this must be
equal or bigger than the number of entries in the index file.
If it is not specified the square of the number of phones in the
phoneset is used.
</p></dd>
<dt><code> sig_band</code></dt>
<dd><p>number of sample points around actual diphone to take from file.
This should be larger than any windowing used on the signal,
and/or up to the pitch marks outside the diphone signal.
</p></dd>
<dt><code> alternates_after</code></dt>
<dd><p>List of pairs of phones stating replacements for the second
part of diphone when the basic diphone is not found in the 
diphone database.
</p></dd>
<dt><code> alternates_before</code></dt>
<dd><p>List of pairs of phones stating replacements for the first
part of diphone when the basic diphone is not found in the 
diphone database.
</p></dd>
<dt><code> default_diphone</code></dt>
<dd><p>When unexpected combinations occur and no appropriate diphone can be
found this diphone should be used.  This should be specified for all
diphone databases that are to be robust.  We usually us the silence to
silence diphone.  No mater how carefully you designed your diphone set,
conditions when an unknown diphone occur seem to <em>always</em> happen.
If this is not set and a diphone is requested that is not in the
database an error occurs and synthesis will stop.
</p></dd>
</dl>

<p>Examples of both general set up, making group files and general
use are in 
</p><table><tr><td>&nbsp;</td><td><pre class="example">`<tt>lib/voices/english/rab_diphone/festvox/rab_diphone.scm</tt>'
</pre></td></tr></table>
<hr size="6">
<a name="NOD76"></a>
<a name="SEC89"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC88" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC90" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC84" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC84" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC91" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 21.5 Access strategies </h2>

<p>Three basic accessing strategies are available when using
diphone databases.  They are designed to optimise access time, start up
time and space requirements.

</p><dl compact="compact">
<dt><code> direct </code></dt>
<dd><p>Load all signals at database init time. This is the slowest startup but
the fastest to access.  This is ideal for servers.  It is also useful
for small databases that can be loaded quickly.  It is reasonable for
many group files.
</p></dd>
<dt><code> dynamic</code></dt>
<dd><p>Load signals as they are required.  This has much faster
start up and will only gradually use up memory as the diphones
are actually used.  Useful for larger databases, and for non-group
file access.
</p></dd>
<dt><code> ondemand</code></dt>
<dd><p>Load the signals as they are requested but free them if they are not
required again immediately.  This is slower access but requires low
memory usage.  In group files the re-reads are quite cheap as the
database is well cached and a file description is already open for the
file.
</p></dd>
</dl>
<p>Note that in group files pitch marks (and LPC coefficients) are
always fully loaded (cf. <code>direct</code>), as they are typically
smaller.  Only signals (waveform files or residuals) are potentially
dynamically loaded.

</p><hr size="6">
<a name="NOD77"></a>
<a name="SEC90"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC89" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC91" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC84" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC84" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC91" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 21.6 Diphone selection </h2>

<p>The appropriate diphone is selected based on the name of the phone
identified in the segment stream.  However for better diphone synthesis
it is useful to augment the diphone database with other diphones in
addition to the ones directly from the phoneme set.  For example dark
and light l's, distinguishing consonants from their consonant cluster
form and their isolated form.  There are however two methods to identify
this modification from the basic name.

</p><a name="IDX192"></a>
<a name="IDX193"></a>
<p>When the diphone module is called the hook <code>diphone_module_hooks</code>
is applied.  That is a function of list of functions which will be
applied to the utterance.  Its main purpose is to allow the conversion
of the basic name into an augmented one.  For example converting a basic
<code>l</code> into a dark l, denoted by <code>ll</code>.  The functions given in
<code>diphone_module_hooks</code> may set the feature
<code>diphone_phone_name</code> which if set will be used rather than the
<code>name</code> of the segment.

</p><p>For example suppose we wish to use a dark l (<code>ll</code>) rather than
a normal l for all l's that appear in the coda of a syllable.
First we would define a function to which identifies this condition
and adds the addition feature <code>diphone_phone_name</code> identify
the name change.  The following function would
achieve this
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(define (fix_dark_ls utt)
&quot;(fix_dark_ls UTT)
Identify ls in coda position and relabel them as ll.&quot;
  (mapcar
   (lambda (seg) 
     (if (and (string-equal &quot;l&quot; (item.name seg))
              (string-equal &quot;+&quot; (item.feat seg &quot;p.ph_vc&quot;))
              (item.relation.prev seg &quot;SylStructure&quot;))
      (item.set_feat seg &quot;diphone_phone_name&quot; &quot;ll&quot;)))
   (utt.relation.items utt 'Segment))
  utt)
</pre></td></tr></table><p>Then when we wish to use this for a particular voice we need to
add
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(set! diphone_module_hooks (list fix_dark_ls))
</pre></td></tr></table><p>in the voice selection function.

</p><p>For a more complex example including consonant cluster identification
see the American English voice `<tt>ked</tt>' in
`<tt>festival/lib/voices/english/ked/festvox/kd_diphone.scm</tt>'.  The
function <code>ked_diphone_fix_phone_name</code> carries out a number of
mappings.

</p><p>The second method for changing a name is during actual look up of a
diphone in the database.  The list of alternates is given by the
<code>Diphone_Init</code> function.  These are used when the specified diphone
can't be found.  For example we often allow mappings of dark l,
<code>ll</code> to <code>l</code> as sometimes the dark l diphone doesn't actually
exist in the database.

</p><hr size="6">
<a name="NOD78"></a>
<a name="SEC91"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC90" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC92" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC84" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC95" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 22. Other synthesis methods </h1>

<p>Festival supports a number of other synthesis systems

</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC92">22.1 LPC diphone synthesizer</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  A small LPC synthesizer (Donovan diphones)
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC93">22.2 MBROLA</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   Interface to MBROLA
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC94">22.3 Synthesizers in development</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                
</td></tr>
</table>

<hr size="6">
<a name="NOD79"></a>
<a name="SEC92"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC91" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC93" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC91" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC91" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC95" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 22.1 LPC diphone synthesizer </h2>

<p>A very simple, and very efficient LPC diphone synthesizer using
the &quot;donovan&quot; diphones is also supported.  This synthesis method
is primarily the work of Steve Isard and later Alistair Conkie.
The synthesis quality is not as good as the residual excited LPC
diphone synthesizer but has the advantage of being much smaller.
The donovan diphone database is under 800k.

</p><p>The diphones are loaded through the <code>Donovan_Init</code> function
which takes the name of the dictionary file and the diphone file
as arguments, see the following for details
</p><table><tr><td>&nbsp;</td><td><pre class="example">lib/voices/english/don_diphone/festvox/don_diphone.scm
</pre></td></tr></table>
<hr size="6">
<a name="NOD80"></a>
<a name="SEC93"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC92" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC94" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC91" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC91" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC95" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 22.2 MBROLA </h2>

<p>As an example of how Festival may use a completely external synthesis
method we support the free system MBROLA.  MBROLA is both a diphone
synthesis technique and an actual system that constructs waveforms from
segment, duration and F0 target information.  For details see the MBROLA
home page at <a href="http://tcts.fpms.ac.be/synthesis/mbrola.html">http://tcts.fpms.ac.be/synthesis/mbrola.html</a>.  MBROLA
already supports a number of diphone sets including French, Spanish,
German and Romanian.

</p><p>Festival support for MBROLA is in the file `<tt>lib/mbrola.scm</tt>'.
It is all in Scheme.  The function <code>MBROLA_Synth</code> is called
when parameter <code>Synth_Method</code> is <code>MBROLA</code>.  The
function simply saves the segment, duration and target information
from the utterance, calls the external `<tt>mbrola</tt>' program with the
selected diphone database, and reloads the generated waveform
back into the utterance.

</p><p>An MBROLA-ized version of the Roger diphoneset is available from the
MBROLA site.  The simple Festival end is distributed as part of
the system in `<tt>festvox_en1.tar.gz</tt>'.
The following variables are used by the process
</p><dl compact="compact">
<dt><code> mbrola_progname</code></dt>
<dd><p>the pathname of the mbrola executable.
</p></dd>
<dt><code> mbrola_database</code></dt>
<dd><p>the name of the database to use.  This variable is switched between
different speakers.
</p></dd>
</dl>

<hr size="6">
<a name="NOD81"></a>
<a name="SEC94"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC93" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC95" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC91" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC91" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC95" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 22.3 Synthesizers in development </h2>

<p>In addition to the above synthesizers Festival also
supports CSTR's older PSOLA synthesizer written by Paul Taylor.
But as the newer diphone synthesizer produces similar quality
output and is a newer (and hence a cleaner) implementation
further development of the older module is unlikely.

</p><a name="IDX194"></a>
<p>An experimental unit seleciton synthesis module is included in
`<tt>modules/clunits/</tt>' it is an implementation of <cite>black97c</cite>.  It
is included for people wishing to continue reserach in the area rather
than as a fully usable waveform synthesis engine.  Although it sometimes
gives excellent results it also sometimes gives amazingly bad ones too.
We included this as an example of one possible framework for selection-based
synthesis.  

</p><p>As one of our funded projects is to specifically develop new selection
based synthesis algorithms we expect to include more models within later
versions of the system.

</p><p>Also, now that Festival has been released other groups are working
on new synthesis techniques in the system.  Many of these will
become available and where possible we will give pointers from
the Festival home page to them.  Particularly there is an alternative
residual excited LPC module implemented at the Center for Spoken
Language Understanding (CSLU) at the Oregon Graduate Institute (OGI).

</p><hr size="6">
<a name="NOD82"></a>
<a name="SEC95"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC94" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC96" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC91" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC96" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 23. Audio output </h1>

<p>If you have never heard any audio ever on your machine then you must
first work out if you have the appropriate hardware.  If you do, you
also need the appropriate software to drive it.  Festival can directly
interface with a number of audio systems or use external
methods for playing audio.  

</p><p>The currently supported audio methods are
</p><dl compact="compact">
<dd><a name="IDX195"></a>
<a name="IDX196"></a>
</dd>
<dt>`<samp> NAS</samp>'</dt>
<dd><p>NCD's NAS, is a network transparent audio system (formerly called
netaudio).  If you already run servers on your machines you
simply need to ensure your <code>AUDIOSERVER</code> environment variable
is set (or your <code>DISPLAY</code> variable if your audio output device is the
same as your X Windows display).
You may set NAS as your audio output method by the command
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(Parameter.set 'Audio_Method 'netaudio)
</pre></td></tr></table><a name="IDX197"></a>
<a name="IDX198"></a>
</dd>
<dt>`<samp> /dev/audio</samp>'</dt>
<dd><p>On many systems `<tt>/dev/audio</tt>' offers a simple low level method for
audio output.  It is limited to mu-law encoding at 8KHz.  Some
implementations of `<tt>/dev/audio</tt>' allow other sample rates and sample
types but as that is non-standard this method only uses the common
format.  Typical systems that offer these are Suns, Linux and FreeBSD
machines.  You may set direct `<tt>/dev/audio</tt>' access as your audio
method by the command
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(Parameter.set 'Audio_Method 'sunaudio)
</pre></td></tr></table><a name="IDX199"></a>
<a name="IDX200"></a>
</dd>
<dt>`<samp> /dev/audio (16bit)</samp>'</dt>
<dd><p>Later Sun Microsystems workstations support 16 bit
linear audio at various sample rates.  Support for this form
of audio output is supported.  It is a compile time option (as
it requires include files that only exist on Sun machines.  If
your installation supports it (check the members of the list
<code>*modules*</code>) you can select 16 bit audio output on
Suns by the command
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(Parameter.set 'Audio_Method 'sun16audio)
</pre></td></tr></table><p>Note this will send it to the local machine where the festival binary
is running, this might not be the one you are sitting next to--that's
why we recommend netaudio.  A hacky solution to playing audio on a local
machine from a remote machine without using netaudio is described
in <a href="#SEC12">Installation</a>
</p></dd>
<dt>`<samp> /dev/dsp (voxware)</samp>'</dt>
<dd><a name="IDX201"></a>
<a name="IDX202"></a>
<a name="IDX203"></a>
<a name="IDX204"></a>
<p>Both FreeBSD and Linux have a very similar audio interface through
`<tt>/dev/dsp</tt>'.  There is compile time support for these in the speech
tools and when compiled with that option Festival may utilise it.
Check the value of the variable <code>*modules*</code> to see which audio
devices are directly supported.  On FreeBSD, if supported, you
may select local 16 bit linear audio by the command
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(Parameter.set 'Audio_Method 'freebsd16audio)
</pre></td></tr></table><p>While under Linux, if supported, you may use the command
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(Parameter.set 'Audio_Method 'linux16audio)
</pre></td></tr></table><p>Some earlier (and smaller machines) only have 8bit audio even though
they include a `<tt>/dev/dsp</tt>' (Soundblaster PRO for example).  This was
not dealt with properly in earlier versions of the system but now the
support automatically checks to see the sample width supported and uses
it accordingly.  8 bit at higher frequencies that 8K sounds better than
straight 8k ulaw so this feature is useful.

</p><a name="IDX205"></a>
<a name="IDX206"></a>
</dd>
<dt>`<samp> mplayer</samp>'</dt>
<dd><p>Under Windows NT or 95 you can use the `<tt>mplayer</tt>' command which
we have found requires special treatement to get its parameters right.
Rather than using <code>Audio_Command</code> you can select this on 
Windows machine with the following command
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(Parameter.set 'Audio_Method 'mplayeraudio)
</pre></td></tr></table><p>Alternatively built-in audio output is available with
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(Parameter.set 'Audio_Method 'win32audio)
</pre></td></tr></table><a name="IDX207"></a>
<a name="IDX208"></a>
</dd>
<dt>`<samp> SGI IRIX</samp>'</dt>
<dd><p>Builtin audio output is now available for SGI's IRIX 6.2 using
the command
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(Parameter.set 'Audio_Method 'irixaudio)
</pre></td></tr></table><a name="IDX209"></a>
</dd>
<dt>`<samp> Audio Command</samp>'</dt>
<dd><p>Alternatively the user can provide a command that can play an audio
file.  Festival will execute that command in an environment where the
shell variables <code>SR</code> is set to the sample rate (in Hz) and
<code>FILE</code> which, by default, is the name of an unheadered raw, 16bit
file containing the synthesized waveform in the byte order of the
machine Festival is running on.  You can specify your audio play command
and that you wish Festival to execute that command through the following
command
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(Parameter.set 'Audio_Command &quot;sun16play -f $SR $FILE&quot;)
(Parameter.set 'Audio_Method 'Audio_Command)
</pre></td></tr></table><p>On SGI machines under IRIX the equivalent would be
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(Parameter.set 'Audio_Command 
           &quot;sfplay -i integer 16 2scomp rate $SR end $FILE&quot;)
(Parameter.set 'Audio_Method 'Audio_Command)
</pre></td></tr></table></dd>
</dl>
<p>The <code>Audio_Command</code> method of playing waveforms Festival supports
two additional audio parameters. <code>Audio_Required_Rate</code> allows you
to use Festival's internal sample rate conversion function to any desired
rate.  Note this may not be as good as playing the waveform at the
sample rate it is originally created in, but as some hardware devices
are restrictive in what sample rates they support, or have naive
resample functions this could be optimal.  The second additional
audio parameter is <code>Audio_Required_Format</code> which can be
used to specify the desired output forms of the file.  The default
is unheadered raw, but this may be any of the values supported by 
the speech tools (including nist, esps, snd, riff, aiff, audlab, raw
and, if you really want it, ascii).  For example suppose you
have a program that only plays sun headered files at 16000 KHz you can
set up audio output as
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(Parameter.set 'Audio_Method 'Audio_Command)
(Parameter.set 'Audio_Required_Rate 16000)
(Parameter.set 'Audio_Required_Format 'snd)
(Parameter.set 'Audio_Command &quot;sunplay $FILE&quot;)
</pre></td></tr></table>
<a name="IDX210"></a>
<p>Where the audio method supports it, you can specify an alternative audio
device for machines that have more than one audio device.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(Parameter.set 'Audio_Device &quot;/dev/dsp2&quot;)
</pre></td></tr></table>
<a name="IDX211"></a>
<a name="IDX212"></a>
<p>If Netaudio is not available and you need to play audio on a
machine different from teh one Festival is running on we have
had reports that `<tt>snack</tt>' (<a href="http://www.speech.kth.se/snack/">http://www.speech.kth.se/snack/</a>)
is a possible solution.  It allows remote play but importnatly
also supports Windows 95/NT based clients.

</p><a name="IDX213"></a>
<a name="IDX214"></a>
<p>Because you do not want to wait for a whole file to be synthesized
before you can play it, Festival also offers an <em>audio spooler</em>
that allows the playing of audio files while continuing to synthesize
the following utterances.  On reasonable workstations this allows the
breaks between utterances to be as short as your hardware allows them
to be.

</p><p>The audio spooler may be started by selecting asynchronous 
mode
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(audio_mode 'async)
</pre></td></tr></table><p>This is switched on by default be the function <code>tts</code>.
You may put Festival back into synchronous mode (i.e. the <code>utt.play</code>
command will wait until the audio has finished playing before returning).
by the command
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(audio_mode 'sync)
</pre></td></tr></table><p>Additional related commands are
</p><dl compact="compact">
<dt><code> (audio_mode 'close)</code></dt>
<dd><p>Close the audio server down but wait until it is cleared.  This is
useful in scripts etc. when you wish to only exit when all audio is
complete.
</p></dd>
<dt><code> (audio_mode 'shutup)</code></dt>
<dd><p>Close the audio down now, stopping the current file being played and
any in the queue.  Note that this may take some time to take effect 
depending on which audio method you use.  Sometimes there can be
100s of milliseconds of audio in the device itself which cannot
be stopped.
</p></dd>
<dt><code> (audio_mode 'query)</code></dt>
<dd><p>Lists the size of each waveform currently in the queue.
</p></dd>
</dl>

<hr size="6">
<a name="NOD83"></a>
<a name="SEC96"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC95" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC97" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC95" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC109" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 24. Voices </h1>

<p>This chapter gives some general suggestions about adding new voices to
Festival.  Festival attempts to offer an environment where new voices
and languages can easily be slotted in to the system.

</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC97">24.1 Current voices</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 Currently available voices
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC98">24.2 Building a new voice</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#SEC108">24.3 Defining a new voice</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
</table>

<hr size="6">
<a name="NOD84"></a>
<a name="SEC97"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC96" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC98" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC96" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC96" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC109" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 24.1 Current voices </h2>

<p>Currently there are a number of voices available in Festival and we
expect that number to increase. Each is elected via a function of the
name `<samp>voice_*</samp>' which sets up the waveform synthesizer, phone set,
lexicon, duration and intonation models (and anything else necessary)
for that speaker.  These voice setup functions are defined in
`<tt>lib/voices.scm</tt>'.

</p><p>The current voice functions are
</p><dl compact="compact">
<dt><code> voice_rab_diphone</code></dt>
<dd><p>A British English male RP speaker, Roger.  This uses the UniSyn residual
excited LPC diphone synthesizer.  The lexicon is the computer users
version of Oxford Advanced Learners' Dictionary, with letter to sound
rules trained from that lexicon.  Intonation is provided by a ToBI-like
system using a decision tree to predict accent and end tone position.
The F0 itself is predicted as three points on each syllable, using
linear regression trained from the Boston University FM database (f2b)
and mapped to Roger's pitch range.  Duration is predicted by decision
tree, predicting zscore durations for segments trained from the 460
Timit sentence spoken by another British male speaker.
</p></dd>
<dt><code> voice_ked_diphone</code></dt>
<dd><p>An American English male speaker, Kurt.  Again this uses the UniSyn
residual excited LPC diphone synthesizer.  This uses the CMU lexicon,
and letter to sound rules trained from it.  Intonation as with Roger is
trained from the Boston University FM Radio corpus.  Duration for this
voice also comes from that database.
</p></dd>
<dt><code> voice_kal_diphone</code></dt>
<dd><p>An American English male speaker.  Again this uses the UniSyn residual
excited LPC diphone synthesizer.  And like ked, uses the CMU lexicon,
and letter to sound rules trained from it.  Intonation as with Roger is
trained from the Boston University FM Radio corpus.  Duration for this
voice also comes from that database.  This voice was built in two days
work and is at least as good as ked due to us understanding the process
better.  The diphone labels were autoaligned with hand correction.
</p></dd>
<dt><code> voice_don_diphone</code></dt>
<dd><p>Steve Isard's LPC based diphone synthesizer, Donovan diphones.  The
other parts of this voice, lexicon, intonation, and duration are the
same as <code>voice_rab_diphone</code> described above.  The
quality of the diphones is not as good as the other voices because it
uses spike excited LPC.  Although the quality is not as good it
is much faster and the database is much smaller than the others.
</p></dd>
<dt><code> voice_el_diphone</code></dt>
<dd><p>A male Castilian Spanish speaker, using the Eduardo Lopez diphones.
Alistair Conkie and Borja Etxebarria did much to make this.  It has
improved recently but is not as comprehensive as our English voices.
</p></dd>
<dt><code> voice_gsw_diphone</code></dt>
<dd><p>This offers a male RP speaker, Gordon, famed for many previous CSTR
synthesizers, using the standard diphone module.  Its higher
levels are very similar to the Roger voice above.  This voice
is not in the standard distribution, and is unlikely to be added
for commercial reasons, even though it sounds better than Roger.
</p></dd>
<dt><code> voice_en1_mbrola</code></dt>
<dd><p>The Roger diphone set using the same front end as <code>voice_rab_diphone</code>
but uses the MBROLA diphone synthesizer for waveform synthesis.  The
MBROLA synthesizer and Roger diphone database (called <code>en1</code>)
is not distributed by CSTR but is available for non-commercial use
for free from <a href="http://tcts.fpms.ac.be/synthesis/mbrola.html">http://tcts.fpms.ac.be/synthesis/mbrola.html</a>.
We do however provide the Festival part of the voice in 
`<tt>festvox_en1.tar.gz</tt>'.
</p></dd>
<dt><code> voice_us1_mbrola</code></dt>
<dd><p>A female Amercian English voice using our standard US English front end and the
<code>us1</code> database for the MBROLA diphone synthesizer for waveform
synthesis.  The MBROLA synthesizer and the <code>us1</code> diphone database
is not distributed by CSTR but is available for
non-commercial use for free from
<a href="http://tcts.fpms.ac.be/synthesis/mbrola.html">http://tcts.fpms.ac.be/synthesis/mbrola.html</a>.  We
provide the Festival part of the voice in `<tt>festvox_us1.tar.gz</tt>'.
</p></dd>
<dt><code> voice_us2_mbrola</code></dt>
<dd><p>A male Amercian English voice using our standard US English front end and the
<code>us2</code> database for the MBROLA diphone synthesizer for waveform
synthesis.  The MBROLA synthesizer and the <code>us2</code> diphone database
is not distributed by CSTR but is available for
non-commercial use for free from
<a href="http://tcts.fpms.ac.be/synthesis/mbrola.html">http://tcts.fpms.ac.be/synthesis/mbrola.html</a>.  We
provide the Festival part of the voice in `<tt>festvox_us2.tar.gz</tt>'.
</p></dd>
<dt><code> voice_us3_mbrola</code></dt>
<dd><p>Another male Amercian English voice using our standard US English front
end and the <code>us2</code> database for the MBROLA diphone synthesizer for
waveform synthesis.  The MBROLA synthesizer and the <code>us2</code> diphone
database is not distributed by CSTR but is available for non-commercial
use for free from <a href="http://tcts.fpms.ac.be/synthesis/mbrola.html">http://tcts.fpms.ac.be/synthesis/mbrola.html</a>.
We provide the Festival part of the voice in `<tt>festvox_us1.tar.gz</tt>'.
</p></dd>
</dl>
<a name="IDX215"></a>
<p>Other voices will become available through time.  Groups other than CSTR
are working on new voices.  Particularly OGI's CSLU have release a
number of American English voices, two Mexican Spanish voices and two German
voices.  All use OGI's their own residual excited LPC
synthesizer which is distributed as a plug-in for Festival.
(see <a href="http://www.cse.ogi.edu/CSLU/research/TTS">http://www.cse.ogi.edu/CSLU/research/TTS</a> for
details).

</p><p>Other languages are being worked on including German, Basque, Welsh,
Greek and Polish already have been developed and could be release soon.
CSTR has a set of Klingon diphones though the text anlysis for Klingon
still requires some work (If anyone has access to a good Klingon
continous speech corpora please let us know.)

</p><p>Pointers and examples of voices developed at CSTR and elsewhere will
be posted on the Festival home page.

</p><hr size="6">
<a name="NOD85"></a>
<a name="SEC98"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC97" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC99" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC96" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC96" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC109" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 24.2 Building a new voice </h2>

<p>This section runs through the definition of a new voice in Festival.
Although this voice is simple (it is a simplified version of the
distributed spanish voice) it shows all the major parts that must be
defined to get Festival to speak in a new voice.  Thanks go to Alistair
Conkie for helping me define this but as I don't speak Spanish there are
probably many mistakes.  Hopefully its pedagogical use is better than
its ability to be understood in Castille.

</p><p>A much more detailed document on building voices in Festival has been
written and is recommend reading for any one attempting to add a new
voice to Festival <cite>black99</cite>.  The information here is a little
sparse though gives the basic requirements.

</p><p>The general method for defining a new voice is to define the
parameters for all the various sub-parts e.g. phoneset, duration
parameter intonation parameters etc., then defined a function
of the form <code>voice_NAME</code> which when called will actually
select the voice.

</p><hr size="6">
<a name="SEC99"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC98" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC100" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC96" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC98" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC109" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.2.1 Phoneset </h3>

<p>For most new languages and often for new dialects, a new
phoneset is required.  It is really the basic building
block of a voice and most other parts are defined in terms
of this set, so defining it first is a good start.
</p><table><tr><td>&nbsp;</td><td><pre class="example">(defPhoneSet
  spanish
  ;;;  Phone Features
  (;; vowel or consonant
   (vc + -)  
   ;; vowel length: short long diphthong schwa
   (vlng s l d a 0)
   ;; vowel height: high mid low
   (vheight 1 2 3 -)
   ;; vowel frontness: front mid back
   (vfront 1 2 3 -)
   ;; lip rounding
   (vrnd + -)
   ;; consonant type: stop fricative affricative nasal liquid
   (ctype s f a n l 0)
   ;; place of articulation: labial alveolar palatal labio-dental
   ;;                         dental velar
   (cplace l a p b d v 0)
   ;; consonant voicing
   (cvox + -)
   )
  ;; Phone set members (features are not! set properly)
  (
   (#  - 0 - - - 0 0 -)
   (a  + l 3 1 - 0 0 -)
   (e  + l 2 1 - 0 0 -)
   (i  + l 1 1 - 0 0 -)
   (o  + l 3 3 - 0 0 -)
   (u  + l 1 3 + 0 0 -)
   (b  - 0 - - + s l +)
   (ch - 0 - - + a a -)
   (d  - 0 - - + s a +)
   (f  - 0 - - + f b -)
   (g  - 0 - - + s p +)
   (j  - 0 - - + l a +)
   (k  - 0 - - + s p -)
   (l  - 0 - - + l d +)
   (ll - 0 - - + l d +)
   (m  - 0 - - + n l +)
   (n  - 0 - - + n d +)
   (ny - 0 - - + n v +)
   (p  - 0 - - + s l -)
   (r  - 0 - - + l p +)
   (rr - 0 - - + l p +)
   (s  - 0 - - + f a +)
   (t  - 0 - - + s t +)
   (th - 0 - - + f d +)
   (x  - 0 - - + a a -)
  )
)
(PhoneSet.silences '(#))
</pre></td></tr></table><a name="IDX216"></a>
<p>Note some phonetic features may be wrong.

</p><hr size="6">
<a name="SEC100"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC99" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC101" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC96" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC98" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC109" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.2.2 Lexicon and LTS </h3>

<p>Spanish is a language whose pronunciation can almost completely be
predicted from its orthography so in this case we do not need a
list of words and their pronunciations and can do most of the work
with letter to sound rules.

</p><a name="IDX217"></a>
<p>Let us first make a lexicon structure as follows
</p><table><tr><td>&nbsp;</td><td><pre class="example">(lex.create &quot;spanish&quot;)
(lex.set.phoneset &quot;spanish&quot;)
</pre></td></tr></table><p>However if we did just want a few entries to test our system without
building any letter to sound rules we could add entries directly to
the addenda.  For example
</p><table><tr><td>&nbsp;</td><td><pre class="example">(lex.add.entry
   '(&quot;amigos&quot; nil (((a) 0) ((m i) 1) (g o s))))
</pre></td></tr></table><p>A letter to sound rule system for Spanish is quite simple 
in the format supported by Festival.  The following is a good
start to a full set.
<a name="IDX218"></a>
</p><table><tr><td>&nbsp;</td><td><pre class="example">(lts.ruleset
;  Name of rule set
 spanish
;  Sets used in the rules
(
  (LNS l n s )
  (AEOU a e o u )
  (AEO a e o )
  (EI e i )
  (BDGLMN b d g l m n )
)
;  Rules
(
 ( [ a ] = a )
 ( [ e ] = e )
 ( [ i ] = i )
 ( [ o ] = o )
 ( [ u ] = u )
 ( [ &quot;'&quot; a ] = a1 )   ;; stressed vowels
 ( [ &quot;'&quot; e ] = e1 )
 ( [ &quot;'&quot; i ] = i1 )
 ( [ &quot;'&quot; o ] = o1 )
 ( [ &quot;'&quot; u ] = u1 )
 ( [ b ] = b )
 ( [ v ] = b )
 ( [ c ] &quot;'&quot; EI = th )
 ( [ c ] EI = th )
 ( [ c h ] = ch )
 ( [ c ] = k )
 ( [ d ] = d )
 ( [ f ] = f )
 ( [ g ] &quot;'&quot; EI = x )
 ( [ g ] EI = x )
 ( [ g u ] &quot;'&quot; EI = g )
 ( [ g u ] EI = g )
 ( [ g ] = g )
 ( [ h u e ] = u e )
 ( [ h i e ] = i e )
 ( [ h ] =  )
 ( [ j ] = x )
 ( [ k ] = k )
 ( [ l l ] # = l )
 ( [ l l ] = ll )
 ( [ l ] = l )
 ( [ m ] = m )
 ( [ ~ n ] = ny )
 ( [ n ] = n )
 ( [ p ] = p )
 ( [ q u ] = k )
 ( [ r r ] = rr )
 ( # [ r ] = rr )
 ( LNS [ r ] = rr )
 ( [ r ] = r )
 ( [ s ] BDGLMN = th )
 ( [ s ] = s )
 ( # [ s ] C = e s )
 ( [ t ] = t )
 ( [ w ] = u )
 ( [ x ] = k s )
 ( AEO [ y ] = i )
 ( # [ y ] # = i )
 ( [ y ] = ll )
 ( [ z ] = th )
))
</pre></td></tr></table><p>We could simply set our lexicon to use the above letter to sound
system with the following command
</p><table><tr><td>&nbsp;</td><td><pre class="example">(lex.set.lts.ruleset 'spanish)
</pre></td></tr></table><p>But this would not deal with upper case letters.  Instead of
writing new rules for upper case letters we can define that
a Lisp function be called when looking up a word and intercept
the lookup with our own function.  First we state that unknown
words should 
call a function, and then define the function we wish called.
The actual link to ensure our function will be called is done
below at lexicon selection time
</p><table><tr><td>&nbsp;</td><td><pre class="example">(define (spanish_lts word features)
  &quot;(spanish_lts WORD FEATURES)
Using letter to sound rules build a spanish pronunciation of WORD.&quot;
  (list word
        nil
        (lex.syllabify.phstress (lts.apply (downcase word) 'spanish))))
(lex.set.lts.method spanish_lts)
</pre></td></tr></table><p>In the function we downcase the word and apply the LTS rule to it.
Next we syllabify it and return the created lexical entry.

</p><hr size="6">
<a name="SEC101"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC100" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC102" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC96" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC98" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC109" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.2.3 Phrasing </h3>

<p>Without detailed labelled databases we cannot build statistical models
of phrase breaks, but we can simply build a phrase break model based
on punctuation.  The following is a CART tree to predict simple breaks,
from punctuation.
</p><table><tr><td>&nbsp;</td><td><pre class="example">(set! spanish_phrase_cart_tree
'
((lisp_token_end_punc in (&quot;?&quot; &quot;.&quot; &quot;:&quot;))
  ((BB))
  ((lisp_token_end_punc in (&quot;'&quot; &quot;\&quot;&quot; &quot;,&quot; &quot;;&quot;))
   ((B))
   ((n.name is 0)  ;; end of utterance
    ((BB))
    ((NB))))))
</pre></td></tr></table>

<hr size="6">
<a name="SEC102"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC101" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC103" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC96" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC98" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC109" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.2.4 Intonation </h3>

<p>For intonation there are number of simple options without requiring
training data.  For this example we will simply use a hat pattern on all
stressed syllables in content words and on single syllable content
words. (i.e.  <code>Simple</code>) Thus we need an accent prediction CART
tree.
</p><table><tr><td>&nbsp;</td><td><pre class="example">(set! spanish_accent_cart_tree
 '
  ((R:SylStructure.parent.gpos is content)
   ((stress is 1)
    ((Accented))
    ((position_type is single)
     ((Accented))
     ((NONE))))
   ((NONE))))
</pre></td></tr></table><p>We also need to specify the pitch range of our speaker.  We will
be using a male Spanish diphone database of the follow range
</p><table><tr><td>&nbsp;</td><td><pre class="example">(set! spanish_el_int_simple_params
    '((f0_mean 120) (f0_std 30)))
</pre></td></tr></table>
<hr size="6">
<a name="SEC103"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC102" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC104" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC96" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC98" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC109" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.2.5 Duration </h3>

<p>We will use the trick mentioned above for duration prediction.
Using the zscore CART tree method, we will actually use it to 
predict factors rather than zscores.  

</p><p>The tree predicts longer durations in stressed syllables and in
clause initial and clause final syllables.
</p><table><tr><td>&nbsp;</td><td><pre class="example">(set! spanish_dur_tree
 '
   ((R:SylStructure.parent.R:Syllable.p.syl_break &gt; 1 ) ;; clause initial
    ((R:SylStructure.parent.stress is 1)
     ((1.5))
     ((1.2)))
    ((R:SylStructure.parent.syl_break &gt; 1)   ;; clause final
     ((R:SylStructure.parent.stress is 1)
      ((2.0))
      ((1.5)))
     ((R:SylStructure.parent.stress is 1)
      ((1.2))
      ((1.0))))))
</pre></td></tr></table><p>In addition to the tree we need durations for each phone in the
set
</p><table><tr><td>&nbsp;</td><td><pre class="example">(set! spanish_el_phone_data
'(
   (# 0.0 0.250)
   (a 0.0 0.090)
   (e 0.0 0.090)
   (i 0.0 0.080)
   (o 0.0 0.090)
   (u 0.0 0.080)
   (b 0.0 0.065)
   (ch 0.0 0.135)
   (d 0.0 0.060)
   (f 0.0 0.100)
   (g 0.0 0.080)
   (j 0.0 0.100)
   (k 0.0 0.100)
   (l 0.0 0.080)
   (ll 0.0 0.105)
   (m 0.0 0.070)
   (n 0.0 0.080)
   (ny 0.0 0.110)
   (p 0.0 0.100)
   (r 0.0 0.030)
   (rr 0.0 0.080)
   (s 0.0 0.110)
   (t 0.0 0.085)
   (th 0.0 0.100)
   (x 0.0 0.130)
))
</pre></td></tr></table>
<hr size="6">
<a name="SEC104"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC103" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC105" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC96" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC98" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC109" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.2.6 Waveform synthesis </h3>

<p>There are a number of choices for waveform synthesis currently
supported.  MBROLA supports Spanish, so we could use that.  But their
Spanish diphones in fact use a slightly different phoneset so we would
need to change the above definitions to use it effectively.  Here we will
use a diphone database for Spanish recorded by Eduardo Lopez when he was
a Masters student some years ago.

</p><p>Here we simply load our pre-built diphone database
</p><table><tr><td>&nbsp;</td><td><pre class="example">(us_diphone_init
   (list
    '(name &quot;el_lpc_group&quot;)
    (list 'index_file 
          (path-append spanish_el_dir &quot;group/ellpc11k.group&quot;))
    '(grouped &quot;true&quot;)
    '(default_diphone &quot;#-#&quot;)))
</pre></td></tr></table>
<hr size="6">
<a name="SEC105"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC104" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC106" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC96" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC98" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC109" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.2.7 Voice selection function </h3>

<p>The standard way to define a voice in Festival is to define
a function of the form <code>voice_NAME</code> which selects
all the appropriate parameters.  Because the definition 
below follows the above definitions we know that everything 
appropriate has been loaded into Festival and hence we
just need to select the appropriate a parameters.

</p><table><tr><td>&nbsp;</td><td><pre class="example">(define (voice_spanish_el)
&quot;(voice_spanish_el)
Set up synthesis for Male Spanish speaker: Eduardo Lopez&quot;
  (voice_reset)
  (Parameter.set 'Language 'spanish)  
  ;; Phone set
  (Parameter.set 'PhoneSet 'spanish)
  (PhoneSet.select 'spanish)
  (set! pos_lex_name nil)
  ;; Phrase break prediction by punctuation
  (set! pos_supported nil)
  ;; Phrasing
  (set! phrase_cart_tree spanish_phrase_cart_tree)
  (Parameter.set 'Phrase_Method 'cart_tree)
  ;; Lexicon selection
  (lex.select &quot;spanish&quot;)
  ;; Accent prediction
  (set! int_accent_cart_tree spanish_accent_cart_tree)
  (set! int_simple_params spanish_el_int_simple_params)
  (Parameter.set 'Int_Method 'Simple)
  ;; Duration prediction
  (set! duration_cart_tree spanish_dur_tree)
  (set! duration_ph_info spanish_el_phone_data)
  (Parameter.set 'Duration_Method 'Tree_ZScores)
  ;; Waveform synthesizer: diphones
  (Parameter.set 'Synth_Method 'UniSyn)
  (Parameter.set 'us_sigpr 'lpc)
  (us_db_select 'el_lpc_group)

  (set! current-voice 'spanish_el)
)

(provide 'spanish_el)
</pre></td></tr></table>
<hr size="6">
<a name="SEC106"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC105" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC107" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC96" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC98" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC109" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.2.8 Last remarks </h3>

<p>We save the above definitions in a file `<tt>spanish_el.scm</tt>'.  Now we
can declare the new voice to Festival.  See section <a href="#SEC108">Defining a new voice</a>,
for a description of methods for adding new voices.  For testing
purposes we can explciitly load the file `<tt>spanish_el.scm</tt>'

</p><p>The voice is now available for use in festival.
</p><table><tr><td>&nbsp;</td><td><pre class="example">festival&gt; (voice_spanish_el)
spanish_el
festival&gt; (SayText &quot;hola amigos&quot;)
&lt;Utterance 0x04666&gt;
</pre></td></tr></table>
<p>As you can see adding a new voice is not very difficult.  Of course
there is quite a lot more than the above to add a high quality robust
voice to Festival.  But as we can see many of the basic tools that we
wish to use already exist.  The main difference between the above voice
and the English voices already in Festival are that their models are
better trained from databases.  This produces, in general, better
results, but the concepts behind them are basically the same.  All
of those trainable methods may be parameterized with data for
new voices.

</p><p>As Festival develops, more modules will be added with better support for
training new voices so in the end we hope that adding in high quality
new voices is actually as simple as (or indeed simpler than) the above
description.

</p><hr size="6">
<a name="SEC107"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC106" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC108" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC96" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC98" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC109" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.2.9 Resetting globals </h3>

<p>Because the version of Scheme used in Festival only has a single flat
name space it is unfortunately too easy for voices to set some global
which accidentally affects all other voices selected after it.  Because
of this problem we have introduced a convention to try to minimise the
possibility of this becoming a problem.  Each voice function
defined should always call <code>voice_reset</code> at the start.  This
will reset any globals and also call a tidy up function provided by
the previous voice function.  

</p><p>Likewise in your new voice function you should provide a tidy up
function to reset any non-standard global variables you set.  The
function <code>current_voice_reset</code> will be called by
<code>voice_reset</code>.  If the value of <code>current_voice_reset</code> is
<code>nil</code> then it is not called.  <code>voice_reset</code> sets
<code>current_voice_reset</code> to <code>nil</code>, after calling it.

</p><p>For example suppose some new voice requires the audio device to 
be directed to a different machine.  In this example we make
the giant's voice go through the netaudio machine <code>big_speakers</code>
while the standard voice go through <code>small_speakers</code>.

</p><p>Although we can easily select the machine <code>big_speakers</code> as out
when our <code>voice_giant</code> is called, we also need to set it back when
the next voice is selected, and don't want to have to modify every other
voice defined in the system.  Let us first define two functions to
selection the audio output.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(define (select_big)
  (set! giant_previous_audio (getenv &quot;AUDIOSERVER&quot;))
  (setenv &quot;AUDIOSERVER&quot; &quot;big_speakers&quot;))

(define (select_normal)
  (setenv &quot;AUDIOSERVER&quot; giant_previous_audio))
</pre></td></tr></table><p>Note we save the previous value of <code>AUDIOSERVER</code> rather than simply
assuming it was <code>small_speakers</code>.

</p><p>Our definition of <code>voice_giant</code> definition of <code>voice_giant</code>
will look something like
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(define (voice_giant)
&quot;comment comment ...&quot;
   (voice_reset)  ;; get into a known state
   (select_big)
   ;;; other giant voice parameters
   ...

   (set! current_voice_rest select_normal)
   (set! current-voice 'giant))
</pre></td></tr></table><p>The obvious question is which variables should a voice reset.
Unfortunately there is not a definitive answer to that.  To a certain
extent I don't want to define that list as there will be many variables
that will by various people in Festival which are not in the original
distribution and we don't want to restrict them.  The longer term answer
is some for of partitioning of the Scheme name space perhaps having
voice local variables (cf. Emacs buffer local variables).  But
ultimately a voice may set global variables which could redefine the
operation of later selected voices and there seems no real way to stop
that, and keep the generality of the system.

</p><a name="IDX219"></a>
<p>Note the convention of setting the global <code>current-voice</code> as
the end of any voice definition file.  We do not enforce this
but probabaly should.  The variable <code>current-voice</code> at
any time should identify the current voice, the voice
description information (described below) will relate this name
to properties identifying it.

</p><hr size="6">
<a name="NOD86"></a>
<a name="SEC108"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC107" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC109" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC96" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC96" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC109" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 24.3 Defining a new voice </h2>

<p>As there are a number of voices available for Festival and they may or
may not exists in different installations we have tried to make it
as simple as possible to add new voices to the system without having
to change any of the basic distribution.  In fact if the voices
use the following standard method for describing themselves it
is merely a matter of unpacking them in order for them to be used
by the system.

</p><a name="IDX220"></a>
<p>The variable <code>voice-path</code> conatins a list of directories where
voices will be automatically searched for.  If this is not set it is set
automatically by appending `<tt>/voices/</tt>' to all paths in festival
<code>load-path</code>.  You may add new directories explicitly to this
variable in your `<tt>sitevars.scm</tt>' file or your own `<tt>.festivalrc</tt>'
as you wish.

</p><p>Each voice directory is assumed to be of the form
</p><table><tr><td>&nbsp;</td><td><pre class="example">LANGUAGE/VOICENAME/
</pre></td></tr></table><p>Within the <code>VOICENAME/</code> directory itself it is assumed there is a
file `<tt>festvox/VOICENAME.scm</tt>' which when loaded will define the
voice itself.  The actual voice function should be called
<code>voice_VOICENAME</code>.

</p><p>For example the voices distributed with the standard Festival
distribution all unpack in `<tt>festival/lib/voices</tt>'.  The Amercan
voice `<tt>ked_diphone</tt>' unpacks into
</p><table><tr><td>&nbsp;</td><td><pre class="example">festival/lib/voices/english/ked_diphone/
</pre></td></tr></table><p>Its actual definition file is in 
</p><table><tr><td>&nbsp;</td><td><pre class="example">festival/lib/voices/english/ked_diphone/festvox/ked_diphone.scm
</pre></td></tr></table><p>Note the name of the directory and the name of the Scheme definition
file must be the same.  

</p><p>Alternative voices using perhaps a different encoding of the database but
the same front end may be defined in the same way by using symbolic
links in the langauge directoriy to the main directory.  For example
a PSOLA version of the ked voice may be defined in 
</p><table><tr><td>&nbsp;</td><td><pre class="example">festival/lib/voices/english/ked_diphone/festvox/ked_psola.scm
</pre></td></tr></table><p>Adding a symbole link in `<tt>festival/lib/voices/english/</tt>' ro
`<tt>ked_diphone</tt>' called `<tt>ked_psola</tt>' will allow that voice
to be automatically registered when Festival starts up.

</p><p>Note that this method doesn't actually load the voices it finds, that
could be prohibitively time consuming to the start up process.  It
blindly assumes that there is a file
`<tt>VOICENAME/festvox/VOICENAME.scm</tt>' to load.  An autoload definition
is given for <code>voice_VOICENAME</code> which when called will load that
file and call the real definition if it exists in the file.

</p><p>This is only a recommended method to make adding new voices easier, it
may be ignored if you wish.  However we still recommend that even if you
use your own convetions for adding new voices you consider the autoload
function to define them in, for example, the `<tt>siteinit.scm</tt>' file or
`<tt>.festivalrc</tt>'.  The autoload function takes three arguments:
a function name, a file containing the actual definiton and a comment.
For example a definition of voice can be done explicitly by 
</p><table><tr><td>&nbsp;</td><td><pre class="example">(autooad voice_f2b  &quot;/home/awb/data/f2b/ducs/f2b_ducs&quot; 
     &quot;American English female f2b&quot;)))
</pre></td></tr></table><p>Of course you can also load the definition file explicitly if you
wish.

</p><a name="IDX221"></a>
<p>In order to allow the system to start making intellegent use of voices
we recommend that all voice definitions include a call to the function
<code>voice_proclaim</code> this allows the system to know some properties
about the voice such as language, gender and dialect.  The
<code>proclaim_voice</code> function taks two arguments a name (e.g.
<code>rab_diphone</code> and an assoc list of features and names.  Currently
we require <code>language</code>, <code>gender</code>, <code>dialect</code> and
<code>description</code>.  The last being a textual description of the voice
itself.  An example proclaimation is
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(proclaim_voice
 'rab_diphone
 '((language english)
   (gender male)
   (dialect british)
   (description
    &quot;This voice provides a British RP English male voice using a
     residual excited LPC diphone synthesis method.  It uses a 
     modified Oxford Advanced Learners' Dictionary for pronunciations.
     Prosodic phrasing is provided by a statistically trained model
     using part of speech and local distribution of breaks.  Intonation
     is provided by a CART tree predicting ToBI accents and an F0 
     contour generated from a model trained from natural speech.  The
     duration model is also trained from data using a CART tree.&quot;)))
</pre></td></tr></table><p>There are functions to access a description.  <code>voice.description</code>
will return the description for a given voice and will load that voice
if it is not already loaded.  <code>voice.describe</code> will describe the
given given voice by synthesizing the textual description using the
current voice.  It would be nice to use the voice itself to give a self
introduction but unfortunately that introduces of problem of decide
which language the description should be in, we are not all as fluent in
welsh as we'd like to be.

</p><p>The function <code>voice.list</code> will list the <em>potential</em> voices in
the system.  These are the names of voices which have been found in the
<code>voice-path</code>.  As they have not actaully been loaded they can't
actually be confirmed as usable voices.  One solution to this would be
to load all voices at start up time which would allow confirmation they
exist and to get their full description through <code>proclaim_voice</code>.
But start up is already too slow in festival so we have to accept this
stat for the time being.  Splitting the description of the voice from
the actual definition is a possible solution to this problem but we have
not yet looked in to this.

</p><hr size="6">
<a name="NOD87"></a>
<a name="SEC109"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC108" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC110" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC96" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC115" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 25. Tools </h1>

<p>A number of basic data manipulation tools are supported by Festival.
These often make building new modules very easy and are already used
in many of the existing modules.  They typically offer a Scheme method
for entering data, and Scheme and C++ functions for evaluating it.

</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC110">25.1 Regular expressions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> 
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC111">25.2 CART trees</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Building and using CART
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC112">25.3 Ngrams</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Building and using Ngrams
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC113">25.4 Viterbi decoder</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     Using the Viterbi decoder
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC114">25.5 Linear regression</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   Building and using linear regression models
</td></tr>
</table>

<hr size="6">
<a name="NOD88"></a>
<a name="SEC110"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC109" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC111" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC109" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC109" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC115" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 25.1 Regular expressions </h2>

<p>Regular expressions are a formal method for describing a certain class
of mathematical languages.  They may be viewed as patterns which match
some set of strings.  They are very common in many software tools such
as scripting languages like the UNIX shell, PERL, awk, Emacs etc.
Unfortunately the exact form of regualr expressions often differs
slightly between different applications making their use often a little
tricky.  

</p><p>Festival support regular expressions based mainly of the form used in
the GNU libg++ <code>Regex</code> class, though we have our own implementation
of it.  Our implementation (<code>EST_Regex</code>) is actually based on Henry
Spencer's `<tt>regex.c</tt>' as distributed with BSD 4.4.

</p><p>Regular expressions are represented as character strings which
are interpreted as regular expressions by certain Scheme
and C++ functions.  Most characters in a regular expression are
treated as literals and match only that character but a number
of others have special meaning.  Some characters may be escaped
with preceding backslashes to change them from operators to literals
(or sometime literals to operators).

</p><dl compact="compact">
<dt><code> .</code></dt>
<dd><p>Matches any character.  
</p></dd>
<dt><code> $ </code></dt>
<dd><p>matches end of string
</p></dd>
<dt><code> ^</code></dt>
<dd><p>matches beginning of string
</p></dd>
<dt><code> X*</code></dt>
<dd><p>matches zero or more occurrences of X, X may be a character, range
of parenthesized expression.
</p></dd>
<dt><code> X+</code></dt>
<dd><p>matches one or more occurrences of X, X may be a character, range
of parenthesized expression.
</p></dd>
<dt><code> X?</code></dt>
<dd><p>matches zero or one occurrence of X, X may be a character, range
of parenthesized expression.  
</p></dd>
<dt><code> [...]</code></dt>
<dd><p>a ranges matches an of the values in the brackets.  The range 
operator &quot;-&quot; allows specification of ranges e.g. <code>a-z</code> for all
lower case characters.  If the first character of the range is 
<code>^</code> then it matches anything character except those specified
in the range.  If you wish <code>-</code> to be in the range you must
put that first.
</p></dd>
<dt><code> \\(...\\)</code></dt>
<dd><p>Treat contents of parentheses as single object allowing operators
<code>*</code>, <code>+</code>, <code>?</code> etc to operate on more than single characters.
</p></dd>
<dt><code> X\\|Y</code></dt>
<dd><p>matches either X or Y.  X or Y may be single characters, ranges
or parenthesized expressions.
</p></dd>
</dl>
<p>Note that actuall only one backslash is needed before a character to
escape it but because these expressions are most often contained with
Scheme or C++ strings, the escape mechanaism for those strings requires
that backslash itself be escaped, hence you will most often be
required to type two backslashes.

</p><p>Some example may help in enderstanding the use of regular
expressions.
</p><dl compact="compact">
<dt><code> a.b</code></dt>
<dd><p>matches any three letter string starting with an <code>a</code> and 
ending with a <code>b</code>.
</p></dd>
<dt><code> .*a</code></dt>
<dd><p>matches any string ending in an <code>a</code>
</p></dd>
<dt><code> .*a.*</code></dt>
<dd><p>matches any string containing an <code>a</code>
</p></dd>
<dt><code> [A-Z].*</code></dt>
<dd><p>matches any string starting with a capital letter
</p></dd>
<dt><code> [0-9]+</code></dt>
<dd><p>matches any string of digits
</p></dd>
<dt><code> -?[0-9]+\\(\\.[0-9]+\\)?</code></dt>
<dd><p>matches any positive or negative real number.  Note the optional
preceding minus sign and the optional part contain the point and
following numbers.  The point itself must be escaped as dot on its
own matches any character.
</p></dd>
<dt><code> [^aeiouAEIOU]+</code></dt>
<dd><p>mathes any non-empty string which doesn't conatin a vowel
</p></dd>
<dt><code> \\([Ss]at\\(urday\\)\\)?\\|\\([Ss]un\\(day\\)\\)</code></dt>
<dd><p>matches Saturday and Sunday in various ways
</p></dd>
</dl>

<p>The Scheme function <code>string-matches</code> takes a string and
a regular expression and returns <code>t</code> if the regular 
expression macthes the string and <code>nil</code> otherwise.

</p><hr size="6">
<a name="NOD89"></a>
<a name="SEC111"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC110" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC112" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC109" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC109" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC115" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 25.2 CART trees </h2>

<p>One of the basic tools available with Festival is a system for building
and using Classification and Regression Trees (<cite>breiman84</cite>).  This
standard statistical method can be used to predict both categorical and
continuous data from a set of feature vectors.

</p><a name="IDX222"></a>
<p>The tree itself contains yes/no questions about features and ultimately
provides either a probability distribution, when predicting categorical
values (classification tree), or a mean and standard deviation when
predicting continuous values (regression tree).  Well defined techniques
can be used to construct an optimal tree from a set of training data.
The program, developed in conjunction with Festival, called
`<tt>wagon</tt>', distributed with the speech tools, provides a basic but
ever increasingly powerful method for constructing trees.

</p><p>A tree need not be automatically constructed, CART trees have the
advantage over some other automatic training methods, such as neural
networks and linear regression, in that their output is more readable
and often understandable by humans.  Importantly this makes it possible
to modify them.  CART trees may also be fully hand constructed.  This
is used, for example, in generating some duration models for languages we
do not yet have full databases to train from.

</p><p>A CART tree has the following syntax
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">    CART ::= QUESTION-NODE || ANSWER-NODE
    QUESTION-NODE ::= ( QUESTION YES-NODE NO-NODE )
    YES-NODE ::= CART
    NO-NODE ::= CART
    QUESTION ::= ( FEATURE in LIST )
    QUESTION ::= ( FEATURE is STRVALUE )
    QUESTION ::= ( FEATURE = NUMVALUE )
    QUESTION ::= ( FEATURE &gt; NUMVALUE )
    QUESTION ::= ( FEATURE &lt; NUMVALUE )
    QUESTION ::= ( FEATURE matches REGEX )
    ANSWER-NODE ::= CLASS-ANSWER || REGRESS-ANSWER
    CLASS-ANSWER ::= ( (VALUE0 PROB) (VALUE1 PROB) ... MOST-PROB-VALUE )
    REGRESS-ANSWER ::= ( ( STANDARD-DEVIATION MEAN ) )
</pre></td></tr></table><p>Note that answer nodes are distinguished by their car not being atomic.

</p><a name="IDX223"></a>
<p>The interpretation of a tree is with respect to a Stream_Item
The <var>FEATURE</var> in a tree is a standard feature (see section <a href="#SEC53">Features</a>).

</p><p>The following example tree is used in one of the Spanish voices
to predict variations from average durations.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(set! spanish_dur_tree
 '
(set! spanish_dur_tree
 '
   ((R:SylStructure.parent.R:Syllable.p.syl_break &gt; 1 ) ;; clause initial
    ((R:SylStructure.parent.stress is 1)
     ((1.5))
     ((1.2)))
    ((R:SylStructure.parent.syl_break &gt; 1)   ;; clause final
     ((R:SylStructure.parent.stress is 1)
      ((2.0))
      ((1.5)))
     ((R:SylStructure.parent.stress is 1)
      ((1.2))
      ((1.0))))))
</pre></td></tr></table><p>It is applied to the segment stream to give a factor to multiply
the average by.

</p><p><code>wagon</code> is constantly improving and with version 1.2 of the speech
tools may now be considered fairly stable for its basic operations.
Experimental features are described in help it gives.  See the
Speech Tools manual for a more comprehensive discussion of using 
`<tt>wagon</tt>'.

</p><p>However the above format of trees is similar to those produced by many
other systems and hence it is reasonable to translate their formats into
one which Festival can use.

</p><hr size="6">
<a name="NOD90"></a>
<a name="SEC112"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC111" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC113" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC109" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC109" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC115" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 25.3 Ngrams </h2>

<p>Bigram, trigrams, and general ngrams are used in the part
of speech tagger and the phrase break predicter.  An Ngram
C++ Class is defined in the speech tools library and some simple
facilities are added within Festival itself.

</p><p>Ngrams may be built from files of tokens using the program
<code>ngram_build</code> which is part of the speech tools.  See
the speech tools documentation for details.

</p><p>Within Festival ngrams may be named and loaded from files
and used when required.  The LISP function <code>load_ngram</code>
takes a name and a filename as argument and loads the Ngram 
from that file.  For an example of its use once loaded see
`<tt>src/modules/base/pos.cc</tt>' or 
`<tt>src/modules/base/phrasify.cc</tt>'.

</p><hr size="6">
<a name="NOD91"></a>
<a name="SEC113"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC112" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC114" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC109" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC109" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC115" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 25.4 Viterbi decoder </h2>

<p>Another common tool is a Viterbi decoder.  This C++ Class is defined in
the speech tools library `<tt>speech_tooks/include/EST_viterbi.h</tt>' and
`<tt>speech_tools/stats/EST_viterbi.cc</tt>'.  A Viterbi decoder
requires two functions at declaration time.  The first constructs
candidates at each stage, while the second combines paths.  A number of
options are available (which may change).

</p><p>The prototypical example of use is in the part of speech tagger which
using standard Ngram models to predict probabilities of tags.
See `<tt>src/modules/base/pos.cc</tt>' for an example.

</p><p>The Viterbi decoder can also be used through the Scheme function
<code>Gen_Viterbi</code>.  This function respects the parameters defined
in the variable <code>get_vit_params</code>.  Like other modules this
parameter list is an assoc list of feature name and value.  The
parameters supported are:
</p><dl compact="compact">
<dt><code> Relation</code></dt>
<dd><p>The name of the relation the decoeder is to be applied to.
</p></dd>
<dt><code> cand_function</code></dt>
<dd><p>A function that is to be called for each item that will return
a list of candidates (with probilities).
</p></dd>
<dt><code> return_feat</code></dt>
<dd><p>The name of a feature that the best candidate is to be returned in
for each item in the named relation.
</p></dd>
<dt><code> p_word</code></dt>
<dd><p>The previous word to the first item in the named relation (only used
when ngrams are the &quot;language model&quot;).
</p></dd>
<dt><code> pp_word</code></dt>
<dd><p>The previous previous word to the first item in the named relation 
(only used when ngrams are the &quot;language model&quot;).
</p></dd>
<dt><code> ngramname</code></dt>
<dd><p>the name of an ngram (loaded by <code>ngram.load</code>) to be used 
as a &quot;language model&quot;.
</p></dd>
<dt><code> wfstmname</code></dt>
<dd><p>the name of a WFST (loaded by <code>wfst.load</code>) to be used 
as a &quot;language model&quot;, this is ignored if an <code>ngramname</code> is also
specified.
</p></dd>
<dt><code> debug</code></dt>
<dd><p>If specified more debug features are added to the items in the
relation.
</p></dd>
<dt><code> gscale_p</code></dt>
<dd><p>Grammar scaling factor.
</p></dd>
</dl>
<p>Here is a short example to help make the use of this facility clearer.

</p><p>There are two parts required for the Viterbi decode a set of
candidate observations and some &quot;language model&quot;.  For the
math to work properly the candidate observations must be reverse
probabilities (for each candidiate as given what is the probability
of the observation, rather than the probability of the candidate
given the observation).  These can be calculated for the
probabilties candidate given the observation divided by the 
probability of the candidate in isolation.  

</p><p>For the sake of simplicity let us assume we have a lexicon of words to
distribution of part of speech tags with reverse probabilities.  And an
tri-gram called <code>pos-tri-gram</code> over ngram sequences of part of
speech tags.  First we must define the candidate function
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(define (pos_cand_function w)
 ;; select the appropriate lexicon
 (lex.select 'pos_lex)
 ;; return the list of cands with rprobs
 (cadr 
  (lex.lookup (item.name w) nil)))
</pre></td></tr></table><p>The returned candidate list would look somthing like
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">( (jj -9.872) (vbd -6.284) (vbn -5.565) )
</pre></td></tr></table><p>Our part of speech tagger function would look something
like this
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(define (pos_tagger utt)
  (set! get_vit_params
        (list
         (list 'Relation &quot;Word&quot;)
         (list 'return_feat 'pos_tag)
         (list 'p_word &quot;punc&quot;)
         (list 'pp_word &quot;nn&quot;)
         (list 'ngramname &quot;pos-tri-gram&quot;)
         (list 'cand_function 'pos_cand_function)))
  (Gen_Viterbi utt)
  utt)
</pre></td></tr></table><p>this will assign the optimal part of speech tags to each word in utt.

</p><hr size="6">
<a name="NOD92"></a>
<a name="SEC114"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC113" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC115" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC109" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC109" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC115" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 25.5 Linear regression </h2>

<p>The linear regression model takes models built from some external
package and finds coefficients based on the features and weights.  A
model consists of a list of features.  The first should be the atom
<code>Intercept</code> plus a value.  The following in the list should consist
of a feature (see section <a href="#SEC53">Features</a>) followed by a weight.  An optional third
element may be a list of atomic values.  If the result of the feature is
a member of this list the feature's value is treated as 1 else it is 0.
This third argument allows an efficient way to map categorical values
into numeric values.  For example, from the F0 prediction model in
`<tt>lib/f2bf0lr.scm</tt>'.  The first few parameters are
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(set! f2b_f0_lr_start
'(
   ( Intercept 160.584956 )
   ( Word.Token.EMPH 36.0 )
   ( pp.tobi_accent 10.081770 (H*) )
   ( pp.tobi_accent 3.358613 (!H*) )
   ( pp.tobi_accent 4.144342 (*? X*? H*!H* * L+H* L+!H*) )
   ( pp.tobi_accent -1.111794 (L*) )
   ...
)
</pre></td></tr></table><p>Note the feature <code>pp.tobi_accent</code> returns an atom, and is hence
tested with the map groups specified as third arguments.

</p><p>Models may be built from feature data (in the same format as
`<tt>wagon</tt>' using the `<tt>ols</tt>' program distributed with the speech
tools library.

</p><hr size="6">
<a name="NOD93"></a>
<a name="SEC115"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC114" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC116" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC109" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC119" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 26. Building models from databases </h1>

<p>Because our research interests tend towards creating statistical
models trained from real speech data, Festival offers various support
for extracting information from speech databases, in a way suitable
for building models. 

</p><p>Models for accent prediction, F0 generation, duration, vowel
reduction, homograph disambiguation, phrase break assignment and
unit selection have been built using Festival to extract and process
various databases.

</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC116">26.1 Labelling databases</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    Phones, syllables, words etc.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC117">26.2 Extracting features</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    Extraction of model parameters.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC118">26.3 Building models</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        Building stochastic models from features
</td></tr>
</table>

<hr size="6">
<a name="NOD94"></a>
<a name="SEC116"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC115" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC117" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC115" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC115" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC119" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 26.1 Labelling databases </h2>

<p>In order for Festival to use a database it is most useful to build
utterance structures for each utterance in the database.  As discussed
earlier, utterance structures contain relations of items.  Given such a
structure for each utterance in a database we can easily read in the
utterance representation and access it, dumping information in a
normalised way allowing for easy building and testing of models.

</p><p>Of course the level of labelling that exists, or that you are willing to
do by hand or using some automatic tool, for a particular database will
vary.  For many purposes you will at least need phonetic labelling.
Hand labelled data is still better than auto-labelled data, but that
could change.  The size and consistency of the data is important too.

</p><p>For this discussion we will assume labels for: segments, syllables, words,
phrases, intonation events, pitch targets.  Some of these can be
derived, some need to be labelled.  This would not fail with less
labelling but of course you wouldn't be able to extract as much
information from the result.

</p><p>In our databases these labels are in Entropic's Xlabel format, 
though it is fairly easy to convert any reasonable format.

</p><dl compact="compact">
<dt><em> Segment</em></dt>
<dd><a name="IDX224"></a>
<p>These give phoneme labels for files.  Note the these labels <em>must</em>
be members of the phoneset that you will be using for this database.
Often phone label files may contain extra labels (e.g. beginning
and end silence) which are not really part of the phoneset.  You
should remove (or re-label) these phones accordingly.
</p></dd>
<dt><em> Word</em></dt>
<dd><a name="IDX225"></a>
<p>Again these will need to be provided.  The end of the word should
come at the last phone in the word (or just after).  Pauses/silences
should not be part of the word.
</p></dd>
<dt><em> Syllable</em></dt>
<dd><a name="IDX226"></a>
<p>There is a chance these can be automatically generated from
Word and Segment files given a lexicon.  Ideally these should
include lexical stress.
</p></dd>
<dt><em> IntEvent</em></dt>
<dd><a name="IDX227"></a>
<p>These should ideally mark accent/boundary tone type for each syllable,
but this almost definitely requires hand-labelling.  Also given that
hand-labelling of accent type is harder and not as accurate, it is
arguable that anything other than accented vs. non-accented can be used
reliably.
</p></dd>
<dt><em> Phrase</em></dt>
<dd><a name="IDX228"></a>
<p>This could just mark the last non-silence phone in each utterance, or
before any silence phones in the whole utterance. 
</p></dd>
<dt><em> Target</em></dt>
<dd><a name="IDX229"></a>
<p>This can be automatically derived from an F0 file and the Segment files.
A marking of the mean F0 in each voiced phone seem to give adequate
results.  
</p></dd>
</dl>
<p>Once these files are created an utterance file can be automatically
created from the above data.   Note it is pretty easy to get the
streams right but getting the relations between the streams is 
much harder.  Firstly labelling is rarely accurate and small windows of
error must be allowed to ensure things line up properly.  The second 
problem is that some label files identify point type information
(IntEvent and Target) while others identify segments (e.g. Segment,
Words etc.).  Relations have to know this in order to get it right.
For example is not right for all syllables between two
IntEvents to be linked to the IntEvent, only to the Syllable
the IntEvent is within.

</p><a name="IDX230"></a>
<p>The script `<tt>festival/examples/make_utts</tt>' is an example Festival script
which automatically builds the utterance files from the above labelled
files. 

</p><p>The script, by default assumes, a hierarchy in an database directory
of the following form.  Under a directory `<tt>festival/</tt>' where
all festival specific database ifnromation can be kept, a directory
`<tt>relations/</tt>' contains a subdirectory for each basic relation
(e.g. `<tt>Segment/</tt>', `<tt>Syllable/</tt>', etc.)  Each of which contains
the basic label files for that relation.

</p><p>The following command will build a set of utterance structures (including
building hte relations that link between these basic relations).
</p><table><tr><td>&nbsp;</td><td><pre class="example">make_utts -phoneset radio festival/relation/Segment/*.Segment
</pre></td></tr></table><p>This will create utterances in `<tt>festival/utts/</tt>'.  There are
a number of options to `<tt>make_utts</tt>' use `<tt>-h</tt>' to find
them.  The `<tt>-eval</tt>' option allows extra scheme code to be
loaded which may be called by the utterance building process.
The function <code>make_utts_user_function</code> will be called on all
utterance created.  Redefining that in database specific loaded
code will allow database specific fixed to the utterance.

</p><hr size="6">
<a name="NOD95"></a>
<a name="SEC117"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC116" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC118" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC115" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC115" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC119" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 26.2 Extracting features </h2>

<p>The easiest way to extract features from a labelled database
of the form described in the previous section is by loading
in each of the utterance structures and dumping the desired features.

</p><p>Using the same mechanism to extract the features as will eventually be
used by models built from the features has the important advantage of
avoiding spurious errors easily introduced when collecting data.  For
example a feature such as <code>n.accent</code> in a Festival utterance will
be defined as 0 when there is no next accent.  Extracting all the
accents and using an external program to calculate the next accent may
make a different decision so that when the generated model is used a
different value for this feature will be produced.  Such mismatches
in training models and actual use are unfortunately common, so using
the same mechanism to extract data for training, and for actual
use is worthwhile.

</p><p>The recommedn method for extracting features is using the
festival script `<tt>dumpfeats</tt>'.  It basically takes a list
of feature names and a list of utterance files and dumps the desired
features.

</p><p>Features may be dumped into a single file or into separate files
one for each utterance.  Feature names may be specified on the
command line or in a separate file.  Extar code to define new features
may be loaded too.

</p><p>For example suppose we wanted to save the features for a set of
utterances include the duration, phone name, previous and next phone names
for all segments in each utterance.
</p><table><tr><td>&nbsp;</td><td><pre class="example">dumpfeats -feats &quot;(segment_duration name p.name n.name)&quot; \
          -output feats/%s.dur -relation Segment \
          festival/utts/*.utt
</pre></td></tr></table><p>This will save these features in files named for the utterances they come
from in the directory `<tt>feats/</tt>'.  The argument to `<tt>-feats</tt>' is
treated as literal list only if it starts with a left parenthesis, otherwise
it is treated as a filename contain named features (unbracketed).

</p><p>Extra code (for new feature definitions) may be loaded through the
`<tt>-eval</tt>' option.  If the argument to `<tt>-eval</tt>' starts
with a left parenthesis it is trated as an s-expression rather than
a filename and is evaluated.  If argument `<tt>-output</tt>' contains
&quot;%s&quot; it will be filled in with the utterance's filename, if it
is a simple filename the features from all utterances will be saved
in that same file.  The features for each item in the named
relation are saved on a single line.
</p><hr size="6">
<a name="NOD96"></a>
<a name="SEC118"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC117" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC119" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC115" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC115" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC119" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 26.3 Building models </h2>

<p>This section describes how to build models from data extracted from
databases as described in the previous section.  It uses the CART
building program, `<tt>wagon</tt>' which is available in the speech tools
distribution.  But the data is suitable for many other types of model
building techniques, such as linear regression or neural networks.

</p><p>Wagon is described in the speech tools manual, though we will
cover simple use here.  To use Wagon you need a datafile and a
data description file.

</p><p>A datafile consists of a number of vectors one per line each containing
the same number of fields.  This, not coincidentally, is exactly the
format produced by `<tt>dumpfeats</tt>' described in the previous
section.  The data description file describes the fields in the datafile
and their range.  Fields may be of any of the following types: class (a
list of symbols), floats, or ignored.  Wagon will build a classification
tree if the first field (the predictee) is of type class, or a
regression tree if the first field is a float.  An example
data description file would be
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(
( duration float )
( name # @ @@ a aa ai au b ch d dh e e@ ei f g h i i@ ii jh k l m n 
    ng o oi oo ou p r s sh t th u u@ uh uu v w y z zh )
( n.name # @ @@ a aa ai au b ch d dh e e@ ei f g h i i@ ii jh k l m n 
    ng o oi oo ou p r s sh t th u u@ uh uu v w y z zh )
( p.name # @ @@ a aa ai au b ch d dh e e@ ei f g h i i@ ii jh k l m n 
    ng o oi oo ou p r s sh t th u u@ uh uu v w y z zh )
( R:SylStructure.parent.position_type 0 final initial mid single )
( pos_in_syl float )
( syl_initial 0 1 )
( syl_final 0 1)
( R:SylStructure.parent.R:Syllable.p.syl_break 0 1 3 )
( R:SylStructure.parent.syl_break 0 1 3 4 )
( R:SylStructure.parent.R:Syllable.n.syl_break 0 1 3 4 )
( R:SylStructure.parent.R:Syllable.p.stress 0 1 )
( R:SylStructure.parent.stress 0 1 )
( R:SylStructure.parent.R:Syllable.n.stress 0 1 )
)
</pre></td></tr></table><p>The script `<tt>speech_tools/bin/make_wagon_desc</tt>' goes some way
to helping.  Given a datafile and a file containing the field names, it
will construct an approximation of the description file.  This file
should still be edited as all fields are treated as of type class by
`<tt>make_wagon_desc</tt>' and you may want to change them some of them to
float.

</p><p>The data file must be a single file, although we created a number of
feature files by the process described in the previous section.  From a
list of file ids select, say, 80% of them, as training data and cat them
into a single datafile.  The remaining 20% may be catted together as
test data.  

</p><p>To build a tree use a command like
</p><table><tr><td>&nbsp;</td><td><pre class="example">wagon -desc DESCFILE -data TRAINFILE -test TESTFILE
</pre></td></tr></table><p>The minimum cluster size (default 50) may be reduced using the
command line option <code>-stop</code> plus a number.

</p><p>Varying the features and stop size may improve the results.

</p><p>Building the models and getting good figures is only one part
of the process.  You must integrate this model into Festival
if its going to be of any use.  In the case of CART trees generated
by Wagon, Festival supports these directly.  In the case of
CART trees predicting zscores, or factors to modify duration averages,
ees can be used as is.

</p><p>Note there are other options to Wagon which may help build
better CART models.  Consult the chapter in the speech tools manual
on Wagon for more information.

</p><p>Other parts of the distributed system use CART trees, and linear
regression models that were training using the processes described in
this chapter.  Some other parts of the distributed system use CART trees
which were written by hand and may be improved by properly applying
these processes.

</p><hr size="6">
<a name="NOD97"></a>
<a name="SEC119"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC118" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC120" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC115" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC126" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 27. Programming </h1>

<p>This chapter covers aspects of programming within the Festival 
environment, creating new modules, and modifying existing ones.
It describes basic Classes available and gives some particular
examples of things you may wish to add.

</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC120">27.1 The source code</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        A walkthrough of the source code
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC121">27.2 Writing a new module</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   Example access of an utterance
</td></tr>
</table>

<hr size="6">
<a name="NOD98"></a>
<a name="SEC120"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC119" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC121" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC119" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC119" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC126" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 27.1 The source code </h2>

<p>The ultimate authority on what happens in the system lies
in the source code itself.  No matter how hard we try, and how 
automatic we make it, the source code will always be ahead
of the documentation.  Thus if you are going to be using Festival in
a serious way, familiarity with the source is essential.

</p><p>The lowest level functions are catered for in the Edinburgh
Speech Tools, a separate library distributed with Festival.  The
Edinburgh Speech Tool Library offers the basic utterance structure,
waveform file access, and other various useful low-level functions
which we share between different speech systems in our work.
See <a href="../speechtools/index.html">(speechtools)Top</a> section `Overview' in <cite>Edinburgh Speech Tools Library Manual</cite>.

</p><a name="IDX231"></a>
<p>The directory structure for the Festival distribution reflects 
the conceptual split in the code.

</p><dl compact="compact">
<dt>`<tt> ./bin/</tt>'</dt>
<dd><p>The user-level executable binaries and scripts that are part of the
festival system.  These are simple symbolic links to the binaries
or if the system is compiled with shared libraries small wrap-around
shell scripts that set <code>LD_LIBRARY_PATH</code> appropriately
</p></dd>
<dt>`<tt> ./doc/</tt>'</dt>
<dd><p>This contains the texinfo documentation for the whole system.  The
`<tt>Makefile</tt>' constructs the info and/or html version as desired.
Note that the <code>festival</code> binary itself is used to generate the lists
of functions and variables used within the system, so must be compiled
and in place to generate a new version of the documentation.
</p></dd>
<dt>`<tt> ./examples/</tt>'</dt>
<dd><p>This contains various examples.  Some are explained within this manual,
others are there just as examples.
</p></dd>
<dt>`<tt> ./lib/</tt>'</dt>
<dd><p>The basic Scheme parts of the system, including `<tt>init.scm</tt>' the
first file loaded by <code>festival</code> at start-up time.  Depending on
your installation, this directory may also contain subdirectories
containing lexicons, voices and databases.  This directory and its
sub-directories are used by Festival at run-time.
</p></dd>
<dt>`<tt> ./lib/etc/</tt>'</dt>
<dd><p>Executables for Festival's internal use.  A subdirectory containing
at least the audio spooler will be automatically created (one for each
different architecture the system is compiled on).  Scripts are
added to this top level directory itself.
</p></dd>
<dt>`<tt> ./lib/voices/</tt>'</dt>
<dd><p>By default this contains the voices used by Festival including their
basic Scheme set up functions as well as the diphone databases.
</p></dd>
<dt>`<tt> ./lib/dicts/</tt>'</dt>
<dd><p>This contains various lexicon files distributed as part of the
system.
</p></dd>
<dt>`<tt> ./config/</tt>'</dt>
<dd><p>This contains the basic `<tt>Makefile</tt>' configuration files for
compiling the system (run-time configuration is handled by Scheme
in the `<tt>lib/</tt>' directory).  The file `<tt>config/config</tt>' created
as a copy of the standard `<tt>config/config-dist</tt>' is the installation
specific configuration.  In most cases a simpel copy of the
distribution file will be sufficient.
</p></dd>
<dt>`<tt> ./src/</tt>'</dt>
<dd><p>The main C++/C source for the system.
</p></dd>
<dt>`<tt> ./src/lib/</tt>'</dt>
<dd><p>Where the `<tt>libFestival.a</tt>' is built.
</p></dd>
<dt>`<tt> ./src/include/</tt>'</dt>
<dd><p>Where include files shared between various parts of the system
live.  The file `<tt>festival.h</tt>' provides access to most of
the parts of the system.
</p></dd>
<dt>`<tt> ./src/main/</tt>'</dt>
<dd><p>Contains the top level C++ files for the actual executables.
This is directory where the executable binary `<tt>festival</tt>'
is created.
</p></dd>
<dt>`<tt> ./src/arch/</tt>'</dt>
<dd><p>The main core of the Festival system.  At present everything is held in
a single sub-directory `<tt>./src/arc/festival/</tt>'.  This contains the
basic core of the synthesis system itself.  This directory contains lisp
front ends to access the core utterance architecture, and phonesets,
basic tools like, client/server support, ngram support, etc, and an
audio spooler.
</p></dd>
<dt>`<tt> ./src/modules/</tt>'</dt>
<dd><p>In contrast to the `<tt>arch/</tt>' directory this contains the non-core
parts of the system.  A set of basic example modules are included with
the standard distribution.  These are the parts that do the synthesis,
the other parts are just there to make module writing easier.
</p></dd>
<dt>`<tt> ./src/modules/base/</tt>'</dt>
<dd><p>This contains some basic simple modules that weren't quite big enough
to deserve their own directory.  Most importantly it includes the 
<code>Initialize</code> module called by many synthesis methods which sets
up an utterance structure and loads in initial values.  This directory
also contains phrasing, part of speech, and word (syllable and phone
construction from words) modules.
</p></dd>
<dt>`<tt> ./src/modules/Lexicon/</tt>'</dt>
<dd><p>This is not really a module in the true sense (the <code>Word</code> module
is the main user of this).  This contains functions to construct, compile,
and access lexicons (entries of words, part of speech and 
pronunciations).  This also contains a letter-to-sound rule system.
</p></dd>
<dt>`<tt> ./src/modules/Intonation/</tt>'</dt>
<dd><p>This contains various intonation systems, from the very simple
to quite complex parameter driven intonation systems.
</p></dd>
<dt>`<tt> ./src/modules/Duration/</tt>'</dt>
<dd><p>This contains various duration prediction systems, from the very simple
(fixed duration) to quite complex parameter driven duration systems.
</p></dd>
<dt>`<tt> ./src/modules/UniSyn/</tt>'</dt>
<dd><p>A basic diphone synthesizer system, supporting a simple database format
(which can be grouped into a more efficient binary representation).  It
is multi-lingual, and allows multiple databases to be loaded at once.
It offers a choice of concatenation methods for diphones: residual
excited LPC or PSOLA (TM) (which is not distributed)
</p></dd>
<dt>`<tt> ./src/modules/Text/</tt>'</dt>
<dd><p>Various text analysis functions, particularly the tokenizer and
utterance segmenter (from arbitrary files).  This directory
also contains the support for text modes and SGML.
</p></dd>
<dt>`<tt> ./src/modules/donovan/</tt>'</dt>
<dd><p>An LPC based diphone synthesizer.  Very small and neat.
</p></dd>
<dt>`<tt> ./src/modules/rxp/</tt>'</dt>
<dd><p>The Festival/Scheme front end to 
An XML parser written by Richard Tobin from University of Edinburgh's
Language Technology Group.. rxp is now part of the speech tools
rather than just Festival.
</p></dd>
<dt>`<tt> ./src/modules/parser</tt>'</dt>
<dd><p>A simple interface the the Stochastic Context Free Grammar parser in
the speech tools library.
</p></dd>
<dt>`<tt> ./src/modules/diphone</tt>'</dt>
<dd><p>An optional module contain the previouslty used diphone synthsizer.
</p></dd>
<dt>`<tt> ./src/modules/clunits</tt>'</dt>
<dd><p>A partial implementation of a cluster unit selection algorithm
as described in <cite>black97c</cite>.
</p></dd>
<dt>`<tt> ./src/modules/Database rjc_synthesis</tt>'</dt>
<dd><p>This consist of a new set of modules for doing waveform synthesis.  They
are inteneded to unit size independent (e.g. diphone, phone, non-uniform
unit).  Also selection, prosodic modification, joining and signal
processing are separately defined.  Unfortunately this code has
not really been exercised enough to be considered stable to be used
in the default synthesis method, but those working on new synthesis
techniques may be interested in integration using these new modules.
They may be updated before the next full release of Festival.
</p></dd>
<dt>`<tt> ./src/modules/*</tt>'</dt>
<dd><p>Other optional directories may be contained here containing 
various research modules not yet part of the standard distribution.
See below for descriptions of how to add modules to the basic 
system.
</p></dd>
</dl>
<p>One intended use of Festival is offer a software system where
new modules may be easily tested in a stable environment.  We
have tried to make the addition of new modules easy, without requiring
complex modifications to the rest of the system.

</p><p>All of the basic modules should really be considered merely as example
modules.  Without much effort all of them could be improved.

</p><hr size="6">
<a name="NOD99"></a>
<a name="SEC121"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC120" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC122" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC119" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC119" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC126" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 27.2 Writing a new module </h2>

<p>This section gives a simple example of writing a new module. showing
the basic steps that must be done to create and add a new module that is
available for the rest of the system to use.  Note many things can be
done solely in Scheme now and really only low-level very intensive
things (like waveform synthesizers) need be coded in C++.

</p><hr size="6">
<a name="SEC122"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC121" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC123" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC119" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC121" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC126" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 27.2.1 Example 1: adding new modules </h3>

<p>The example here is a duration module which sets durations of phones for
a given list of averages.  To make this example more interesting, all
durations in accented syllables are increased by 1.5.  Note that this is
just an example for the sake of one, this (and much better techniques)
could easily done within the system as it is at present using a
hand-crafted CART tree.

</p><p>Our knew module, called <code>Duration_Simple</code> can most easily
be added to the `<tt>./src/Duration/</tt>' directory in a file
`<tt>simdur.cc</tt>'.  You can worry about the copyright notice, but
after that you'll probably need the following includes
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">#include &lt;festival.h&gt;

</pre></td></tr></table><p>The module itself must be declared in a fixed form.  That is 
receiving a single LISP form (an utterance) as an argument
and returning that LISP form at the end.  Thus our definition
will start
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">LISP FT_Duration_Simple(LISP utt)
{
</pre></td></tr></table><p>Next we need to declare an utterance structure and extract it
from the LISP form. We also make a few other variable declarations
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">    EST_Utterance *u = get_c_utt(utt);
    EST_Item *s;
    float end=0.0, dur;
    LISP ph_avgs,ldur;
</pre></td></tr></table><a name="IDX232"></a>
<p>We cannot list the average durations for each phone in the source
code as we cannot tell which phoneset we are using (or what
modifications we want to make to durations between speakers).  Therefore
the phone and average duration information is held in a Scheme variable
for easy setting at run time.  To use the information in our C++
domain we must get that value from the Scheme domain.  This is 
done with the following statement.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">    ph_avgs = siod_get_lval(&quot;phoneme_averages&quot;,&quot;no phoneme durations&quot;);
</pre></td></tr></table><p>The first argument to <code>siod_get_lval</code> is the Scheme name of
a variable which has been set to an assoc list of phone and average
duration before this module is called.  See the
variable <code>phone_durations</code> in `<tt>lib/mrpa_durs.scm</tt>' for
the format.  The second argument to <code>siod_get_lval</code>. is an 
error message to be printed if the variable <code>phone_averages</code>
is not set.  If the second argument to <code>siod_get_lval</code> is
<code>NULL</code> then no error is given and if the variable is unset
this function simply returns the Scheme value <code>nil</code>.

</p><p>Now that we have the duration data we can go through each segment
in the utterance and add the duration.  The loop looks like
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">    for (s=u-&gt;relation(&quot;Segment&quot;)-&gt;head(); s != 0; s = next(s))
    {
</pre></td></tr></table><p>We can lookup the average duration of the current segment name
using the function <code>siod_assoc_str</code>.  As arguments, it
takes the segment name <code>s-&gt;name()</code> and the assoc list of
phones and duration.  
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">        ldur = siod_assoc_str(s-&gt;name(),ph_avgs);
</pre></td></tr></table><p>Note the return value is actually a LISP pair (phone name and duration),
or <code>nil</code> if the phone isn't in the list.  Here we check if
the segment is in the list.  If it is not we print an error and set
the duration to 100 ms, if it is in the list the floating point number
is extracted from the LISP pair.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">        if (ldur == NIL)
        {
            cerr &lt;&lt; &quot;Phoneme: &quot; &lt;&lt; s-&gt;name() &lt;&lt; &quot; no duration &quot;
                &lt;&lt; endl;
            dur = 0.100;
        }
        else
            dur = get_c_float(car(cdr(ldur)));
</pre></td></tr></table><p>If this phone is in an accented syllable we wish to increase its
duration by a factor of 1.5.  To find out if it is accented
we use the feature system to find the syllable this phone is 
part of and find out if that syllable is accented.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">        if (ffeature(s,&quot;R:SylStructure.parent.accented&quot;) == 1)
            dur *= 1.5;
</pre></td></tr></table><p>Now that we have the desired duration we increment the <code>end</code>
duration with our predicted duration for this segment and set
the end of the current segment.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">        end += dur;
        s-&gt;fset(&quot;end&quot;,end);
    }
</pre></td></tr></table><p>Finally we return the utterance from the function.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">    return utt;
}
</pre></td></tr></table><p>Once a module is defined it must be declared to the system so it may be
called.  To do this one must call the function
<code>festival_def_utt_module</code> which takes a LISP name, the C++ function
name and a documentation string describing what the module does.  This
will automatically be available at run-time and added to the manual.
The call to this function should be added to the initialization function
in the directory you are adding the module too.  The function is called
<code>festival_DIRNAME_init()</code>.  If one doesn't exist you'll need to
create it.

</p><p>In `<tt>./src/Duration/</tt>' the function <code>festival_Duration_init()</code>
is at the end of the file `<tt>dur_aux.cc</tt>'.  Thus we can add our
new modules declaration at the end of that function.  But first 
we must declare the C++ function in that file.  Thus above
that function we would add
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">LISP FT_Duration_Simple(LISP args);
</pre></td></tr></table><p>While at the end of the function <code>festival_Duration_init()</code>
we would add
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">   festival_def_utt_module(&quot;Duration_Simple&quot;,FT_Duration_Simple,
   &quot;(Duration_Simple UTT)\n\
  Label all segments with average duration ... &quot;);
</pre></td></tr></table>
<p>In order for our new file to be compiled we must add it
to the `<tt>Makefile</tt>' in that directory, to the <code>SRCS</code> variable.
Then when we type <code>make</code> in `<tt>./src/</tt>' our new module
will be properly linked in and available for use.

</p><p>Of course we are not quite finished.  We still have to say when our
new duration module should be called.  When we set 
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">   (Parameter.set 'Duration_Method Duration_Simple)
</pre></td></tr></table><p>for a voice it will use our new module, calls to the function
<code>utt.synth</code> will use our new duration module.

</p><p>Note in earlier versions of Festival it was necessary to modify
the duration calling function in `<tt>lib/duration.scm</tt>' but
that is no longer necessary.

</p><hr size="6">
<a name="SEC123"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC122" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC124" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC119" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC121" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC126" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 27.2.2 Example 2: accessing the utterance </h3>

<p>In this example we will make more direct use of the utterance structure,
showing the gory details of following relations in an utterance.  This
time we will create a module that will name all syllables with a
concatenation of the names of the segments they are related to.

</p><p>As before we need the same standard includes
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">#include &quot;festival.h&quot;

</pre></td></tr></table><p>Now the definition the function
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">LISP FT_Name_Syls(LISP utt)
{
</pre></td></tr></table><p>As with the previous example we are called with an utterance LISP object
and will return the same.  The first task is to extract the
utterance object from the LISP object.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">    EST_Utterance *u = get_c_utt(utt);
    EST_Item *syl,*seg;
</pre></td></tr></table><p>Now for each syllable in the utterance we want to find which segments
are related to it.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">    for (syl=u-&gt;relation(&quot;Syllable&quot;)-&gt;head(); syl != 0; syl = next(syl))
    {
</pre></td></tr></table><p>Here we declare a variable to cummulate the names of the segments.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">        EST_String sylname = &quot;&quot;;
</pre></td></tr></table><p>Now we iterate through the <code>SylStructure</code> daughters of the
syllable.  These will be the segments in that syllable.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">        for (seg=daughter1(syl,&quot;SylStructure&quot;); seg; seg=next(seg))
            sylname += seg-&gt;name();
</pre></td></tr></table><p>Finally we set the syllables name to the concatenative name, and
loop to the next syllable.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">        syl-&gt;set_name(sylname);
    }
</pre></td></tr></table><p>Finally we return the LISP form of the utterance.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">    return utt;
}
</pre></td></tr></table>
<hr size="6">
<a name="SEC124"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC123" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC125" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC119" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC121" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC126" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 27.2.3 Example 3: adding new directories </h3>

<p>In this example we will add a whole new subsystem.  This will often be a
common way for people to use Festival.  For example let us assume we
wish to add a formant waveform synthesizer (e.g like that in the free
`<tt>rsynth</tt>' program).  In this case we will add a whole new
sub-directory to the modules directory.  Let us call it `<tt>rsynth/</tt>'.

</p><p>In the directory we need a `<tt>Makefile</tt>' of the standard form so we
should copy one from one of the other directories,
e.g. `<tt>Intonation/</tt>'.  Standard methods are used to identify the
source code files in a `<tt>Makefile</tt>' so that the `<tt>.o</tt>' files are
properly added to the library.  Following the other examples will ensure
your code is integrated properly.

</p><p>We'll just skip over the bit where you extract the information 
from the utterance structure and synthesize the waveform
(see `<tt>donovan/donovan.cc</tt>' or `<tt>diphone/diphone.cc</tt>'
for examples).

</p><p>To get Festival to use your new module you must tell it to compile the
directory's contents.  This is done in `<tt>festival/config/config</tt>'.
Add the line
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">ALSO_INCLUDE += rsynth
</pre></td></tr></table><p>to the end of that file (there are simialr ones mentioned).  Simply
adding the name of the directory here will add that as a new module
and the directory will be compiled.

</p><p>What you must provide in your code is a function
<code>festival_DIRNAME_init()</code> which will be called at initialization
time.  In this function you should call any further initialization
require and define and new Lisp functions you with to made available
to the rest of the system.  For example in the `<tt>rsynth</tt>'
case we would define in some file in `<tt>rsynth/</tt>'
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">#include &quot;festival.h&quot;

static LISP utt_rtsynth(LISP utt)
{
    EST_Utterance *u = get_c_utt(utt);
    // Do format synthesis 
    return utt;
}

void festival_rsynth_init()
{
   proclaim_module(&quot;rsynth&quot;);

   festival_def_utt_module(&quot;Rsynth_Synth&quot;,utt_rsynth,
   &quot;(Rsynth_Synth UTT)
   A simple formant synthesizer&quot;);

   ...
}

</pre></td></tr></table><p>Integration of the code in optional (and standard directories) is done
by automatically creating `<tt>src/modules/init_modules.cc</tt>' for the
list of standard directories plus those defined as
<code>ALSO_INCLUDE</code>. A call to a function called
<code>festival_DIRNAME_init()</code> will be made.

</p><p>This mechanism is specifically designed so you can add modules to the
system without changing anything in the standard distribution.

</p><hr size="6">
<a name="SEC125"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC124" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC126" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC119" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC121" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC126" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 27.2.4 Example 4: adding new LISP objects </h3>

<p>This third example shows you how to add a new Object to Scheme
and add wraparounds to allow manipulation within the Scheme
(and C++) domain.

</p><p>Like example 2 we are assuming this is done in a new directory.
Suppose you have a new object called <code>Widget</code> that can 
transduce a string into some other string (with some optional
continuous parameter).  Thus, here we create a new file `<tt>widget.cc</tt>'
like this

</p><table><tr><td>&nbsp;</td><td><pre class="lisp">#include &quot;festival.h&quot;
#include &quot;widget.h&quot;  // definitions for the widget class
</pre></td></tr></table><p>In order to register the widgets as Lisp objects we actually
need to register them as <code>EST_Val</code>'s as well.  Thus we now need
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">VAL_REGISTER_CLASS(widget,Widget)
SIOD_REGISTER_CLASS(widget,Widget)
</pre></td></tr></table><p>The first names given to these functions should be a short mnenomic name
for the object that will be used in the defining of a set
of access and construction functions.  It of course must be unique
within the whole system.  The second name is the name of the object
itself.

</p><p>To understand its usage we can add a few simple widget manipulation
functions
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">LISP widget_load(LISP filename)
{
   EST_String fname = get_c_string(filename);
   Widget *w = new Widget;   // build a new widget

   if (w-&gt;load(fname) == 0)  // successful load
      return siod(w);
   else
   {
      cerr &lt;&lt; &quot;widget load: failed to load \&quot;&quot; &lt;&lt; fname &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
      festival_error();
   }
   return NIL;  // for compilers that get confused
}
</pre></td></tr></table><p>Note that the function <code>siod</code> constructs a LISP object from 
a <code>widget</code>, the class register macro defines that for you.
Also note that when giving an object to a <code>LISP</code> object it then
owns the object and is responsible for deleting it when garbage
collection occurs on that <code>LISP</code> object.  Care should be
taken that you don't put the same object within different <code>LISP</code>
objects.  The macros <code>VAL_RESGISTER_CLASS_NODEL</code> should be
called if you do not want your given object to be deleted by the LISP
system (this may cause leaks).

</p><p>If you want refer to these functions in other files within your
models you can use
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">VAL_REGISTER_CLASS_DCLS(widget,Widget)
SIOD_REGISTER_CLASS_DCLS(widget,Widget)
</pre></td></tr></table><p>in a common `<tt>.h</tt>' file

</p><p>The following defines a function that takes a LISP object containing
a widget, applies some method and returns a string.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">LISP widget_apply(LISP lwidget, LISP string, LISP param)
{
    Widget *w = widget(lwidget);
    EST_String s = get_c_string(string);
    float p = get_c_float(param);
    EST_String answer;

    answer = w-&gt;apply(s,p);

    return strintern(answer);
}
</pre></td></tr></table>  
<p>The function <code>widget</code>, defined by the registration macros, takes
a <code>LISP</code> object and returns a pointer to the <code>widget</code> inside
it.  If the <code>LISP</code> object does not contain a <code>widget</code> an
error will be thrown.

</p><p>Finally you wish to add these functions to the Lisp
system
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">void festival_widget_init()
{
  init_subr_1(&quot;widget.load&quot;,widget_load,
    &quot;(widget.load FILENAME)\n\
  Load in widget from FILENAME.&quot;);
  init_subr_3(&quot;widget.apply&quot;,widget_apply,
    &quot;(widget.apply WIDGET INPUT VAL)\n\
  Returns widget applied to string iNPUT with float VAL.&quot;);
}
</pre></td></tr></table>
<p>In your `<tt>Makefile</tt>' for this directory you'll need to add
the include directory where `<tt>widget.h</tt>' is, if it is not 
contained within the directory itself.  This is done through
the make variable <code>LOCAL_INCLUDES</code> as
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">LOCAL_INCLUDES = -I/usr/local/widget/include
</pre></td></tr></table><p>And for the linker you'll need to identify where your widget library
is.  In your `<tt>festival/config/config</tt>' file at the end add
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">COMPILERLIBS += -L/usr/local/widget/lib -lwidget
</pre></td></tr></table>
<hr size="6">
<a name="NOD100"></a>
<a name="SEC126"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC125" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC127" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC119" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC136" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 28. API </h1>

<p>If you wish to use Festival within some other application there are
a number of possible interfaces.  

</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC127">28.1 Scheme API</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Programming in Scheme
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC128">28.2 Shell API</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            From Unix shell
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC129">28.3 Server/client API</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    Festival as a speech synthesis server
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC133">28.4 C/C++ API</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Through function calls from C++.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC134">28.5 C only API</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Small independent C client access
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC135">28.6 Java and JSAPI</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       Sythesizing from Java
</td></tr>
</table>

<hr size="6">
<a name="NOD101"></a>
<a name="SEC127"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC126" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC128" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC126" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC126" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC136" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 28.1 Scheme API </h2>

<p>Festival includes a full programming language, Scheme (a variant of
Lisp) as a powerful interface to its speech synthesis functions.
Often this will be the easiest method of controlling Festival's
functionality.  Even when using other API's they will ultimately
depend on the Scheme interpreter.

</p><p>Scheme commands (as s-expressions) may be simply written in files and
interpreted by Festival, either by specification as arguments on 
the command line, in the interactive interpreter, or through standard
input as a pipe.  Suppose we have a file `<tt>hello.scm</tt>' containing

</p><table><tr><td>&nbsp;</td><td><pre class="lisp">;; A short example file with Festival Scheme commands
(voice_rab_diphone) ;; select Gordon
(SayText &quot;Hello there&quot;)
(voice_don_diphone) ;; select Donovan
(SayText &quot;and hello from me&quot;)
</pre></td></tr></table>
<p>From the command interpreter we can execute the commands in this file
by loading them
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">festival&gt; (load &quot;hello.scm&quot;)
nil
</pre></td></tr></table><p>Or we can execute the commands in the file directly from the
shell command line 
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">unix$ festival -b hello.scm
</pre></td></tr></table><p>The `<samp>-b</samp>' option denotes batch operation meaning the file is loaded
and then Festival will exit, without starting the command interpreter.
Without this option `<samp>-b</samp>' Festival will load
`<tt>hello.scm</tt>' and then accept commands on standard input.  This can
be convenient when some initial set up is required for a session.

</p><p>Note one disadvantage of the batch method is that time is required for
Festival's initialisation every time it starts up.  Although this will
typically only be a few seconds, for saying short individual expressions
that lead in time may be unacceptable.  Thus simply executing the
commands within an already running system is more desirable, or using
the server/client mode.

</p><p>Of course its not just about strings of commands, because Scheme is a
fully functional language, functions, loops, variables, file access,
arithmetic operations may all be carried out in your Scheme programs.
Also, access to Unix is available through the <code>system</code>
function.  For many applications directly programming them in Scheme is
both the easiest and the most efficient method.

</p><a name="IDX233"></a>
<p>A number of example Festival scripts are included in `<tt>examples/</tt>'.
Including a program for saying the time, and for telling you the latest
news (by accessing a page from the web).  Also see the
detailed discussion of a script example in See section <a href="#SEC137">POS Example</a>.

</p><hr size="6">
<a name="NOD102"></a>
<a name="SEC128"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC127" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC129" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC126" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC126" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC136" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 28.2 Shell API </h2>

<p>The simplest use of Festival (though not the most powerful) is
simply using it to directly render text files as speech.  Suppose
we have a file `<tt>hello.txt</tt>' containing
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">Hello world.  Isn't it excellent weather
this morning.
</pre></td></tr></table><p>We can simply call Festival as
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">unix$ festival --tts hello.txt
</pre></td></tr></table><p>Or for even simpler one-off phrases
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">unix$ echo &quot;hello &quot; | festival --tts
</pre></td></tr></table><p>This is easy to use but you will need to wait for Festival to start up
and initialise its databases before it starts to render the text as
speech.  This may take several seconds on some machines.  A socket based
server mechanism is provided in Festival which will allow a single
server process to start up once and be used efficiently by multiple
client programs.

</p><p>Note also the use of Sable for marked up text, see section <a href="#SEC30">XML/SGML mark-up</a>.
Sable allows various forms of additional information in text, such as
phrasing, emphasis, pronunciation, as well as changing voices, and
inclusion of external waveform files (i.e. random noises).  For many
application this will be the preferred interface method.  Other text
modes too are available through the command line by using
<code>auto-text-mode-alist</code>.

</p><hr size="6">
<a name="NOD103"></a>
<a name="SEC129"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC128" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC130" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC126" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC126" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC136" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 28.3 Server/client API </h2>

<p>Festival offers a BSD socket-based interface.  This allows
Festival to run as a server and allow client programs to access
it.  Basically the server offers a new command interpreter for
each client that attaches to it.  The server is forked for each
client but this is much faster than having to wait for a 
Festival process to start from scratch.  Also the server can
run on a bigger machine, offering much faster synthesis.

</p><p><em>Note: the Festival server is inherently insecure and may allow
arbitrary users access to your machine.</em>

</p><p>Every effort has been made to minimise the risk of unauthorised access
through Festival and a number of levels of security are provided.
However with any program offering socket access, like <code>httpd</code>,
<code>sendmail</code> or <code>ftpd</code> there is a risk that unauthorised access
is possible.  I trust Festival's security enough to often run it on my
own machine and departmental servers, restricting access to within our
department.  Please read the information below before using
the Festival server so you understand the risks.

</p><hr size="6">
<a name="SEC130"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC129" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC131" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC126" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC129" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC136" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 28.3.1 Server access control </h3>

<p>The following access control is available for Festival when
running as a server.  When the server starts it will usually
start by loading in various commands specific for the task
it is to be used for.  The following variables are used
to control access.
</p><dl compact="compact">
<dt><code> server_port</code></dt>
<dd><p>A number identifying the inet socket port.  By default this
is 1314.  It may be changed as required.
</p></dd>
<dt><code> server_log_file</code></dt>
<dd><p>If nil no logging takes place, if t logging is printed to standard out
and if a file name log messages are appended to that file. All
connections and attempted connections are logged with a time stamp
and the name of the client.  All commands sent from the client
are also logged (output and data input is not logged).
</p></dd>
<dt><code> server_deny_list</code></dt>
<dd><p>If non-nil it is used to identify which machines are not allowed
access to the server.  This is a list of regular expressions.
If the host name of the client matches any of the regexs in this
list the client is denied access.   This overrides all other
access methods.  Remember that sometimes hosts are identified as
numbers not as names.
</p></dd>
<dt><code> server_access_list</code></dt>
<dd><p>If this is non-nil only machines whose names match at least one of the
regexs in this list may connect as clients.  Remember that sometimes
hosts are identified as numbers not as names, so you should probably
exclude the IP number of machine as well as its name to be properly
secure.
</p></dd>
<dt><code> server_passwd</code></dt>
<dd><p>If this is non-nil, the client must send this passwd to the server
followed by a newline before access is given.  This is required
even if the machine is included in the access list.  This is designed
so servers for specific tasks may be set up with reasonable security.
</p></dd>
<dt><code> (set_server_safe_functions FUNCNAMELIST)</code></dt>
<dd><p>If called this can restrict which functions the client may call.  This
is the most restrictive form of access, and thoroughly recommended.  In
this mode it would be normal to include only the specific functions the
client can execute (i.e. the function to set up output, and a tts
function).  For example a server could call the following at
set up time, thus restricting calls to only those that
`<tt>festival_client</tt>' <code>--ttw</code> uses.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(set_server_safe_functions 
        '(tts_return_to_client tts_text tts_textall Parameter.set))
</pre></td></tr></table>
</dd>
</dl>
<p>Its is strongly recommend that you run Festival in server mode as userid
<code>nobody</code> to limit the access the process will have, also running it
in a chroot environment is more secure.

</p><p>For example suppose we wish to allow access to all machines in the CSTR
domain except for <code>holmes.cstr.ed.ac.uk</code> and
<code>adam.cstr.ed.ac.uk</code>.  This may be done by adding the following two
commands to a file e.g. <code>server.scm</code>
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(set! server_deny_list '(&quot;holmes\\.cstr\\.ed\\.ac\\.uk&quot; 
                         &quot;adam\\.cstr\\.ed\\.ac\\.uk&quot;))
(set! server_access_list '(&quot;[^\\.]*\\.cstr\\.ed\\.ac\\.uk&quot;))
</pre></td></tr></table><p>and them running the command
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">festival PATH_TO/server.scm --server
</pre></td></tr></table>
<p>This is not complete though as when DNS is not working <code>holmes</code> and
<code>adam</code> will still be able to access the server (but if our DNS
isn't working we probably have more serious problems).  However the
above is secure in that only machines in the domain <code>cstr.ed.ac.uk</code>
can access the server, though there may be ways to fix machines to
identify themselves as being in that domain even when they are not.

</p><p>By default Festival in server mode will only accept client connections
for <code>localhost</code>.

</p><hr size="6">
<a name="SEC131"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC130" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC132" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC126" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC129" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC136" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 28.3.2 Client control </h3>

<p>An example client program called `<tt>festival_client</tt>' is
included with the system that provides a wide range of access methods
to the server.  A number of options for the client are offered.

</p><dl compact="compact">
<dt><code> --server</code></dt>
<dd><p>The name (or IP number) of the server host.  By default this
is `<tt>localhost</tt>' (i.e. the same machine you run the client on).
</p></dd>
<dt><code> --port</code></dt>
<dd><p>The port number the Festival server is running on.  By default this
is 1314.
</p></dd>
<dt><code> --output FILENAME</code></dt>
<dd><p>If a waveform is to be synchronously returned, it will be saved in
<var>FILENAME</var>.   The <code>--ttw</code> option uses this as does the
use of the Festival command <code>utt.send.wave.client</code>.  If 
an output waveform file is received by `<tt>festival_client</tt>'
and no output file has been given the waveform is discarded with
an error message.
</p></dd>
<dt><code> --passwd PASSWD</code></dt>
<dd><p>If a passwd is required by the server this should be stated
on the client call.  <var>PASSWD</var> is sent plus a newline
before any other communication takes places.  If this isn't
specified and a passwd is required, you must enter that first,
if the <code>--ttw</code> option is used, a passwd is required and 
none specified access will be denied.
</p></dd>
<dt><code> --prolog FILE</code></dt>
<dd><p><var>FILE</var> is assumed to be contain Festival commands and its contents
are sent to the server after the passwd but before anything else.  This
is convenient to use in conjunction with <code>--ttw</code> which otherwise
does not offer any way to send commands as well as the text to the
server.
</p></dd>
<dt><code> --otype OUTPUTTYPE</code></dt>
<dd><p>If an output waveform file is to be used this specified the output type
of the file.  The default is <code>nist</code>, but, <code>ulaw</code>,
<code>riff</code>, <code>ulaw</code> and others as supported by the Edinburgh
Speech Tools Library are valid.  You may use raw too but note that
Festival may return waveforms of various sampling rates depending on the
sample rates of the databases its using.  You can of course make
Festival only return one particular sample rate, by using
<code>after_synth_hooks</code>.  Note that byte order will be native machine of the
<em>client</em> machine if the output format allows it.
</p></dd>
<dt><code> --ttw</code></dt>
<dd><p>Text to wave is an attempt to make <code>festival_client</code> useful
in many simple applications.  Although you can connect to the server
and send arbitrary Festival Scheme commands, this option automatically
does what is probably what you want most often.  When specified
this options takes text from the specified file (or stdin),
synthesizes it (in one go) and saves it in the specified output
file.  It basically does the following
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(Parameter.set 'Wavefiletype '&lt;output type&gt;)
(tts_textall &quot;
&lt;file/stdin contents&gt;
&quot;)))
</pre></td></tr></table><p>Note that this is best used for small, single utterance texts as you
have to wait for the whole text to be synthesized before it is returned.
</p></dd>
<dt><code> --aucommand COMMAND</code></dt>
<dd><p>Execute <var>COMMAND</var> of each waveform returned by the server.   The
variable <code>FILE</code> will be set when <var>COMMAND</var> is executed.
</p></dd>
<dt><code> --async</code></dt>
<dd><p>So that the delay between the text being sent and the first sound
being available to play, this option in conjunction with <code>--ttw</code>
causes the text to be synthesized utterance by utterance and be sent back
in separated waveforms.  Using <code>--aucommand</code> each waveform my
be played locally, and when `<tt>festival_client</tt>' is interrupted
the sound will stop.  Getting the client to connect to an audio
server elsewhere means the sound will not necessarily stop when 
the `<tt>festival_client</tt>' process is stopped.
</p></dd>
<dt><code> --withlisp</code></dt>
<dd><p>With each command being sent to Festival a Lisp return value is
sent, also Lisp expressions may be sent from the server to the
client through the command <code>send_client</code>.  If this option
is specified the Lisp expressions are printed to standard out,
otherwise this information is discarded.
</p></dd>
</dl>

<p>A typical example use of `<tt>festival_client</tt>' is 
</p><table><tr><td>&nbsp;</td><td><pre class="example">festival_client --async --ttw --aucommand 'na_play $FILE' fred.txt
</pre></td></tr></table><p>This will use `<tt>na_play</tt>' to play each waveform generated for the
utterances in `<tt>fred.txt</tt>'.  Note the <em>single</em> quotes so that
the <code>$</code> in <code>$FILE</code> isn't expanded locally.

</p><p>Note the server must be running before you can talk to it.  At present
Festival is not set up for automatic invocations through `<tt>inetd</tt>'
and `<tt>/etc/services</tt>'.  If you do that yourself, note
that it is a different type of interface as `<tt>inetd</tt>' assumes all
communication goes through standard in/out.

</p><p>Also note that each connection to the server starts a new session.
Variables are not persistent over multiple calls to the server so if any
initialization is required (e.g. loading of voices) it must be done
each time the client starts or more reasonably in the server
when it is started.

</p><a name="IDX234"></a>
<p>A PERL festival client is also available in
`<tt>festival/examples/festival_client.pl</tt>'

</p><hr size="6">
<a name="SEC132"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC131" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC133" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC126" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC129" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC136" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 28.3.3 Server/client protocol </h3>

<p>The client talks to the server using s-expression (Lisp).  The server
will reply with a number of different chunks until either OK is
returned or ER (on error).  The communication is synchronous, each
client request can generate a number of waveform (WV) replies and/or
Lisp replies (LP) and will be terminated with an OK (or ER).  Lisp is
used as it has its own inherent syntax that Festival can already
parse.

</p><p>The following pseudo-code will help define the protocol
as well as show typical use
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">   fprintf(serverfd,&quot;%s\n&quot;,s-expression);
   do
      ack = read three character acknowledgemnt
      if (ack == &quot;WV\n&quot;)
         read a waveform
      else if (ack == &quot;LP\n&quot;)
         read an s-expression
      else if (ack == &quot;ER\n&quot;)
         an error occurred, break;
   while ack != &quot;OK\n&quot;
</pre></td></tr></table><p>The server can send a waveform in an utterance to the client through the
function <code>utt.send.wave.client</code>.  The server can send a lisp
expression to the client through the function <em>TO BE DONE</em>.

</p>
<hr size="6">
<a name="NOD104"></a>
<a name="SEC133"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC132" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC134" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC126" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC126" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC136" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 28.4 C/C++ API </h2>

<p>As well as offerening an interface through Scheme and the shell some
users may also wish to embedd Festival within their own C++ programs.
A number of simply to use high level functions are available for such
uses.  

</p><p>In order to use Festival you must include
`<tt>festival/src/include/festival.h</tt>' which in turn will include the
necessary other include files in `<tt>festival/src/include</tt>' and
`<tt>speech_tools/include</tt>' you should ensure these are included in the
include path for you your program.  Also you will need to link your
program with `<tt>festival/src/lib/libFestival.a</tt>',
`<tt>speech_tools/lib/libestools.a</tt>',
`<tt>speech_tools/lib/libestbase.a</tt>' and
`<tt>speech_tools/lib/libeststring.a</tt>' as well as any other optional
libraries such as net audio.

</p><p>The main external functions available for C++ users of Festival
are.
</p><dl compact="compact">
<dt><code> void festival_initialize(int load_init_files,int heapsize);</code></dt>
<dd><p>This must be called before any other festival functions may be called.
It sets up the synthesizer system.  The first argument if true,
causes the system set up files to be loaded (which is normally
what is necessary), the second argument is the initial size of the
Scheme heap, this should normally be 210000 unless you envisage
processing very large Lisp structures.
</p></dd>
<dt><code> int festival_say_file(const EST_String &amp;filename);</code></dt>
<dd><p>Say the contents of the given file.  Returns <code>TRUE</code> or <code>FALSE</code>
depending on where this was successful.
</p></dd>
<dt><code> int festival_say_text(const EST_String &amp;text);</code></dt>
<dd><p>Say the contents of the given string.  Returns <code>TRUE</code> or <code>FALSE</code>
depending on where this was successful.
</p></dd>
<dt><code> int festival_load_file(const EST_String &amp;filename);</code></dt>
<dd><p>Load the contents of the given file and evaluate its contents as
Lisp commands.  Returns <code>TRUE</code> or <code>FALSE</code>
depending on where this was successful.
</p></dd>
<dt><code> int festival_eval_command(const EST_String &amp;expr);</code></dt>
<dd><p>Read the given string as a Lisp command and evaluate it.  Returns
<code>TRUE</code> or <code>FALSE</code> depending on where this was successful.
</p></dd>
<dt><code> int festival_text_to_wave(const EST_String &amp;text,EST_Wave &amp;wave);</code></dt>
<dd><p>Synthesize the given string into the given wave.  Returns <code>TRUE</code> or
<code>FALSE</code> depending on where this was successful.
</p></dd>
</dl>
<p>Many other commands are also available but often the above will be
sufficient.

</p><p>Below is a simple top level program that uses the Festival
functions
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">int main(int argc, char **argv)
{
    EST_Wave wave;
    int heap_size = 210000;  // default scheme heap size
    int load_init_files = 1; // we want the festival init files loaded

    festival_initialize(load_init_files,heap_size);

    // Say simple file
    festival_say_file(&quot;/etc/motd&quot;);

    festival_eval_command(&quot;(voice_ked_diphone)&quot;);
    // Say some text;
    festival_say_text(&quot;hello world&quot;);

    // Convert to a waveform
    festival_text_to_wave(&quot;hello world&quot;,wave);
    wave.save(&quot;/tmp/wave.wav&quot;,&quot;riff&quot;);

    // festival_say_file puts the system in async mode so we better
    // wait for the spooler to reach the last waveform before exiting
    // This isn't necessary if only festival_say_text is being used (and
    // your own wave playing stuff)
    festival_wait_for_spooler();

    return 0;
}
</pre></td></tr></table>
<hr size="6">
<a name="NOD105"></a>
<a name="SEC134"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC133" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC135" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC126" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC126" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC136" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 28.5 C only API </h2>

<p>A simpler C only interface example is given inf
`<tt>festival/examples/festival_client.c</tt>'.  That interface talks to a
festival server.  The code does not require linking with any other EST
or Festival code so is much smaller and easier to include in other
programs.  The code is missing some functionality but not much consider
how much smaller it is.

</p><hr size="6">
<a name="NOD106"></a>
<a name="SEC135"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC134" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC136" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC126" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC126" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC136" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 28.6 Java and JSAPI </h2>

<p>Initial support for talking to a Festival server from java is included
from version 1.3.0 and initial JSAPI support is included from 1.4.0.
At present the JSAPI talks to a Festival server elsewhere rather than
as part of the Java process itself.

</p><p>A simple (Pure) Java festival client is given 
`<tt>festival/src/modules/java/cstr/festival/Client.java</tt>' with a
wraparound script in `<tt>festival/bin/festival_client_java</tt>'.

</p><p>See the file `<tt>festival/src/modules/java/cstr/festival/jsapi/ReadMe</tt>'
for requirements and a small example of using the JSAPI interface.

</p><hr size="6">
<a name="NOD107"></a>
<a name="SEC136"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC135" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC137" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC126" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC139" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 29. Examples </h1>

<p>This chapter contains some simple walkthrough examples of using
Festival in various ways, not just as speech synthesizer

</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC137">29.1 POS Example</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Using Festival as a part of speech tagger
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC138">29.2 Singing Synthesis</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    Using Festival for singing
</td></tr>
</table>

<hr size="6">
<a name="NOD108"></a>
<a name="SEC137"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC136" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC138" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC136" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC136" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC139" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 29.1 POS Example </h2>

<p>This example shows how we can use part of the standard synthesis process
to tokenize and tag a file of text.  This section does not cover
training and setting up a part of speech tag set See section <a href="#SEC61">POS tagging</a>,
only how to go about using the standard POS tagger on text.

</p><p>This example also shows how to use Festival as a simple scripting
language, and how to modify various methods used during text to speech.

</p><p>The file `<tt>examples/text2pos</tt>' contains an executable shell script
which will read arbitrary ascii text from standard input and produce
words and their part of speech (one per line) on standard output.

</p><p>A Festival script, like any other UNIX script, it must start with the
the characters <code>#!</code> followed by the name of the `<tt>festival</tt>'
executable.  For scripts the option <code>-script</code> is also
required.  Thus our first line looks like
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">#!/usr/local/bin/festival -script
</pre></td></tr></table><p>Note that the pathname may need to be different on your system

</p><p>Following this we have copious comments, to keep our lawyers happy,
before we get into the real script.

</p><p>The basic idea we use is that the tts process segments text into
utterances, those utterances are then passed to a list of functions, as
defined by the Scheme variable <code>tts_hooks</code>.  Normally this variable
contains a list of two function, <code>utt.synth</code> and <code>utt.play</code> which
will synthesize and play the resulting waveform.  In this case, instead,
we wish to predict the part of speech value, and then print it out.

</p><p>The first function we define basically replaces the normal synthesis
function <code>utt.synth</code>.  It runs the standard festival utterance
modules used in the synthesis process, up to the point where POS is
predicted. This function looks like
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(define (find-pos utt)
&quot;Main function for processing TTS utterances.  Predicts POS and
prints words with their POS&quot;
  (Token utt)
  (POS utt)
)
</pre></td></tr></table><p>The normal text-to-speech process first tokenizes the text splitting it
in to &quot;sentences&quot;.  The utterance type of these is <code>Token</code>.  Then
we call the <code>Token</code> utterance module, which converts the tokens to
a stream of words.  Then we call the <code>POS</code> module to predict part
of speech tags for each word.  Normally we would call other modules
ultimately generating a waveform but in this case we need no further
processing.

</p><p>The second function we define is one that will print out the words and
parts of speech
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(define (output-pos utt)
&quot;Output the word/pos for each word in utt&quot;
 (mapcar
  (lambda (pair)
    (format t &quot;%l/%l\n&quot; (car pair) (car (cdr pair))))
  (utt.features utt 'Word '(name pos))))
</pre></td></tr></table><p>This uses the <code>utt.features</code> function to extract features from the
items in a named stream of an utterance.  In this case we want the
<code>name</code> and <code>pos</code> features for each item in the <code>Word</code>
stream.  Then for each pair we print out the word's name, a slash and its
part of speech followed by a newline.

</p><p>Our next job is to redefine the functions to be called
during text to speech.  The variable <code>tts_hooks</code> is defined
in `<tt>lib/tts.scm</tt>'.  Here we set it to our two newly-defined
functions
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(set! tts_hooks (list find-pos output-pos))
</pre></td></tr></table><a name="IDX235"></a>
<a name="IDX236"></a>
<p>So that garbage collection messages do not appear on the screen
we stop the message from being outputted by the following
command
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(gc-status nil)
</pre></td></tr></table><p>The final stage is to start the tts process running on standard
input.  Because we have redefined what functions are to be run on
the utterances, it will no longer generate speech but just predict
part of speech and print it to standard output.
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(tts_file &quot;-&quot;)
</pre></td></tr></table>
<hr size="6">
<a name="NOD109"></a>
<a name="SEC138"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC137" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC139" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC136" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC136" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC139" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 29.2 Singing Synthesis </h2>

<p>As an interesting example a `<tt>singing-mode</tt>' is included.  This
offers an XML based mode for specifying songs, both notes and duration.
This work was done as a student project by Dominic Mazzoni.  A 
number of examples are provided in `<tt>examples/songs</tt>'.  This
may be run as
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">festival&gt; (tts &quot;doremi.xml&quot; 'singing)
</pre></td></tr></table><p>Each note can be given a note and a beat value
</p><table><tr><td>&nbsp;</td><td><pre class="example">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE SINGING PUBLIC &quot;-//SINGING//DTD SINGING mark up//EN&quot; 
      &quot;Singing.v0_1.dtd&quot;
[]&gt;
&lt;SINGING BPM=&quot;30&quot;&gt;
&lt;PITCH NOTE=&quot;G3&quot;&gt;&lt;DURATION BEATS=&quot;0.3&quot;&gt;doe&lt;/DURATION&gt;&lt;/PITCH&gt;
&lt;PITCH NOTE=&quot;A3&quot;&gt;&lt;DURATION BEATS=&quot;0.3&quot;&gt;ray&lt;/DURATION&gt;&lt;/PITCH&gt;
&lt;PITCH NOTE=&quot;B3&quot;&gt;&lt;DURATION BEATS=&quot;0.3&quot;&gt;me&lt;/DURATION&gt;&lt;/PITCH&gt;
&lt;PITCH NOTE=&quot;C4&quot;&gt;&lt;DURATION BEATS=&quot;0.3&quot;&gt;fah&lt;/DURATION&gt;&lt;/PITCH&gt;
&lt;PITCH NOTE=&quot;D4&quot;&gt;&lt;DURATION BEATS=&quot;0.3&quot;&gt;sew&lt;/DURATION&gt;&lt;/PITCH&gt;
&lt;PITCH NOTE=&quot;E4&quot;&gt;&lt;DURATION BEATS=&quot;0.3&quot;&gt;lah&lt;/DURATION&gt;&lt;/PITCH&gt;
&lt;PITCH NOTE=&quot;F#4&quot;&gt;&lt;DURATION BEATS=&quot;0.3&quot;&gt;tee&lt;/DURATION&gt;&lt;/PITCH&gt;
&lt;PITCH NOTE=&quot;G4&quot;&gt;&lt;DURATION BEATS=&quot;0.3&quot;&gt;doe&lt;/DURATION&gt;&lt;/PITCH&gt;
&lt;/SINGING&gt;
</pre></td></tr></table><p>You can construct multi-part songs by synthesizing each part
and generating waveforms, then combining them.  For example
</p><table><tr><td>&nbsp;</td><td><pre class="example">text2wave -mode singing america1.xml -o america1.wav
text2wave -mode singing america2.xml -o america2.wav
text2wave -mode singing america3.xml -o america3.wav
text2wave -mode singing america4.xml -o america4.wav
ch_wave -o america.wav -pc longest america?.wav
</pre></td></tr></table><p>The voice used to sing is the current voice.  Note that the number of
syllables in the words must match that at run time, which means this
doesn't always work cross dialect (UK voices sometimes won't work without
tweaking).

</p><a name="IDX237"></a>
<p>This technique is basically simple, though is definitely effective.
However for a more serious singing synthesizer we recommend you look
at Flinger <a href="http://cslu.cse.ogi.edu/tts/flinger/">http://cslu.cse.ogi.edu/tts/flinger/</a>, which addresses
the issues of synthesizing the human singing voice in more detail.

</p><hr size="6">
<a name="NOD110"></a>
<a name="SEC139"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC138" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC140" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC136" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC140" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 30. Problems </h1>

<p>There will be many problems with Festival, both in installation
and running it.  It is a young system and there is a lot to it.
We believe the basic design is sound and problems will be features
that are missing or incomplete rather than fundamental ones.

</p><p>We are always open to suggestions on how to improve it and fix problems,
we don't guarantee we'll have the time to fix problems but we are
interested in hearing what problems you have.

</p><p>Before you smother us with mail here is an incomplete
list of general problems we have already identified
</p><ul>
<li>
<p>The more documentation we write the more we realize how much more
documentation is required.  Most of the Festival documentation was
written by someone who knows the system very well, and makes many
English mistakes.  A good re-write by some one else would be a good
start.
</p></li><li>
<p>The system is far too slow.  Although machines are getting faster, it
still takes too long to start the system and get it to speak some
given text.  Even so, on reasonable machines, Festival can generate
the speech several times faster than it takes to say it.  But even if
it is five time faster, it will take 2 seconds to generate a 10 second
utterance.  A 2 second wait is too long.  Faster machines would improve
this but a change in design is a better solution.
</p></li><li>
<p>The system is too big.  It takes a long time to compile even on quite
large machines, and its foot print is still in the 10s of megabytes as
is the run-time requirement.  Although we have spent some time trying
to fix this (optional modules have made the possibility of building
a much smaller binary) we haven't done enough yet.
</p></li><li>
<p>The signal quality of the voices isn't very good by today's standard of
synthesizers, even given the improvement quality since the last release.
This is partly our fault in not spending the time (or perhaps also not
having enough expertise) on the low-level waveform synthesis parts of
the system.  This will improve in the future with better signal
processing (under development) and better synthesis techniques (also
under development).
</p></li></ul>

<hr size="6">
<a name="NOD111"></a>
<a name="SEC140"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC139" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC141" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC139" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC141" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 31. References </h1>

<dl compact="compact">
<dt><em> allen87</em></dt>
<dd><p>Allen J., Hunnicut S. and Klatt, D. <em>Text-to-speech: the
MITalk system</em>, Cambridge University Press, 1987.
</p></dd>
<dt><em> abelson85</em></dt>
<dd><p>Abelson H. and Sussman G. <em>Structure and Interpretation of Computer
Programs</em>, MIT Press, 1985.
</p></dd>
<dt><em> black94</em></dt>
<dd><p>Black A. and Taylor, P. &quot;CHATR: a generic speech synthesis system.&quot;,
<em>Proceedings of COLING-94</em>, Kyoto, Japan 1994.
</p></dd>
<dt><em> black96</em></dt>
<dd><p>Black, A. and Hunt, A. &quot;Generating F0 contours from ToBI labels
using linear regression&quot;, <em>ICSLP96</em>, vol. 3, pp 1385-1388,
Philadelphia, PA. 1996.
</p></dd>
<dt><em> black97b</em></dt>
<dd><p>Black, A, and Taylor, P. &quot;Assigning Phrase Breaks from Part-of-Speech 
Sequences&quot;, <em>Eurospeech97</em>, Rhodes, Greece, 1997.
</p></dd>
<dt><em> black97c</em></dt>
<dd><p>Black, A, and Taylor, P. &quot;Automatically clustering similar units for 
unit selection in speech synthesis&quot;, <em>Eurospeech97</em>, Rhodes, Greece,
1997.
</p></dd>
<dt><em> black98</em></dt>
<dd><p>Black, A., Lenzo, K. and Pagel, V., &quot;Issues in building general
letter to sound rules.&quot;, 3rd ESCA Workshop on Speech Synthesis, 
Jenolan Caves, Australia, 1998.
</p></dd>
<dt><em> black99</em></dt>
<dd><p>Black, A., and Lenzo, K., &quot;Building Voices in the Festival Speech
Synthesis System,&quot; unpublished document, Carnegie Mellon University,
available at
<a href="http://www.cstr.ed.ac.uk/projects/festival/docs/festvox/">http://www.cstr.ed.ac.uk/projects/festival/docs/festvox/</a>
</p></dd>
<dt><em> breiman84</em></dt>
<dd><p>Breiman, L., Friedman, J. Olshen, R. and Stone, C. <em>Classification
and regression trees</em>, Wadsworth and Brooks, Pacific Grove, CA. 1984.
</p></dd>
<dt><em> campbell91</em></dt>
<dd><p>Campbell, N. and Isard, S. &quot;Segment durations in a syllable frame&quot;,
<em>Journal of Phonetics</em>, 19:1 37-47, 1991.
</p></dd>
<dt><em> DeRose88</em></dt>
<dd><p>DeRose, S. &quot;Grammatical category disambiguation by statistical 
optimization&quot;. <em>Computational Linguistics</em>, 14:31-39, 1988. 
</p></dd>
<dt><em> dusterhoff97</em></dt>
<dd><p>Dusterhoff, K. and Black, A. &quot;Generating F0 contours for speech
synthesis using the Tilt intonation theory&quot; <em>Proceedings of ESCA
Workshop of Intonation</em>, September, Athens, Greece. 1997
</p></dd>
<dt><em> dutoit97</em></dt>
<dd><p>Dutoit, T. <em>An introduction to Text-to-Speech Synthesis</em> Kluwer
Acedemic Publishers, 1997.
</p></dd>
<dt><em> hunt89</em></dt>
<dd><p>Hunt, M., Zwierynski, D. and Carr, R. &quot;Issues in high quality LPC
analysis and synthesis&quot;, <em>Eurospeech89</em>, vol. 2, pp 348-351, 
Paris, France. 1989.
</p></dd>
<dt><em> jilka96</em></dt>
<dd><p>Jilka M. <em>Regelbasierte Generierung natuerlich klingender
Intonation des Amerikanischen Englisch</em>, Magisterarbeit, Institute of
Natural Language Processing, University of Stuttgart. 1996
</p></dd>
<dt><em> moulines90</em></dt>
<dd><p>Moulines, E, and Charpentier, N. &quot;Pitch-synchronous waveform processing
techniques for text-to-speech synthesis using diphones&quot;
<em>Speech Communication</em>, 9(5/6) pp 453-467. 1990.
</p></dd>
<dt><em> pagel98,</em></dt>
<dd><p>Pagel, V., Lenzo, K., and Black, A.
&quot;Letter to Sound Rules for Accented Lexicon Compression&quot;, ICSLP98, Sydney,
Australia, 1998.
</p></dd>
<dt><em> ritchie92</em></dt>
<dd><p>Ritchie G, Russell G, Black A and Pulman S. <em>Computational
Morphology: practical mechanisms for the English Lexicon</em>, MIT Press,
Cambridge, Mass.
</p></dd>
<dt><em> vansanten96</em></dt>
<dd><p>van Santen, J., Sproat, R., Olive, J. and Hirschberg, J. eds, 
&quot;Progress in Speech Synthesis,&quot; Springer Verlag, 1996.
</p></dd>
<dt><em> silverman92</em></dt>
<dd><p>Silverman K., Beckman M., Pitrelli, J., Ostendorf, M., Wightman, C.,
Price, P., Pierrehumbert, J., and Hirschberg, J &quot;ToBI: a standard for
labelling English prosody.&quot;  <em>Proceedings of ICSLP92</em> vol 2. pp
867-870, 1992
</p></dd>
<dt><em> sproat97</em></dt>
<dd><p>Sproat, R., Taylor, P, Tanenblatt, M. and Isard, A. &quot;A Markup Language for
Text-to-Speech Synthesis&quot;, <em>Eurospeech97</em>, Rhodes, Greece, 1997.
</p></dd>
<dt><em> sproat98,</em></dt>
<dd><p>Sproat, R. eds, &quot;Multilingual Text-to-Speech Synthesis: The Bell Labs
approach&quot;, Kluwer 1998.
</p></dd>
<dt><em> sable98,</em></dt>
<dd><p>Sproat, R., Hunt, A., Ostendorf, M., Taylor, P., Black, A., Lenzo, K.,
and Edgington, M. &quot;SABLE: A standard for TTS markup.&quot; ICSLP98, Sydney,
Australia, 1998.
</p></dd>
<dt><em> taylor91</em></dt>
<dd><p>Taylor P., Nairn I., Sutherland A. and Jack M.. &quot;A real time speech synthesis
system&quot;, <em>Eurospeech91</em>, vol. 1, pp 341-344, Genoa, Italy. 1991.
</p></dd>
<dt><em> taylor96</em></dt>
<dd><p>Taylor P. and Isard, A. &quot;SSML: A speech synthesis markup language&quot;
to appear in <em>Speech Communications</em>.
</p></dd>
<dt><em> wwwxml97</em></dt>
<dd><p>World Wide Web Consortium Working Draft &quot;Extensible Markup Language
(XML)Version 1.0 Part 1: Syntax&quot;,
<a href="http://www.w3.org/pub/WWW/TR/WD-xml-lang-970630.html">http://www.w3.org/pub/WWW/TR/WD-xml-lang-970630.html</a>
</p></dd>
<dt><em> yarowsky96</em></dt>
<dd><p>Yarowsky, D., &quot;Homograph disambiguation in text-to-speech synthesis&quot;,
in &quot;Progress in Speech Synthesis,&quot; eds. van Santen, J., Sproat, R., 
Olive, J. and Hirschberg, J. pp 157-172. Springer Verlag, 1996.
</p></dd>
</dl>

<hr size="6">
<a name="NOD112"></a>
<a name="SEC141"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC140" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC142" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC140" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC142" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 32. Feature functions </h1>

<p>This chapter contains a list of a basic feature functions available for
stream items in utterances.  See section <a href="#SEC53">Features</a>.  These are the basic
features, which can be combined with relative features (such as
<code>n.</code> for next, and relations to follow links).  Some of these
features are implemented as short C++ functions (e.g. <code>asyl_in</code>)
while others are simple features on an item (e.g. <code>pos</code>).  Note
that functional feature take precidence over simple features, so
accessing and feature called &quot;X&quot; will always use the function called &quot;X&quot;
even if a the simple feature call &quot;X&quot; exists on the item.  

</p><p>Unlike previous versions there are no features that are builtin on all
items except <code>addr</code> (reintroduced in 1.3.1) which returns a unique
string for that item (its the hex address on teh item within the
machine).  Features may be defined through Scheme too, these all have
the prefix <code>lisp_</code>.

</p><p>The feature functions are listed in the form <var>Relation.name</var> where
<var>Relation</var> is the name of the stream that the function is
appropriate to and <var>name</var> is its name.  Note that you will not
require the <var>Relation</var> part of the name if the stream item you are
applying the function to is of that type.

</p>

<hr size="6">
<a name="NOD113"></a>
<a name="SEC142"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC141" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC143" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC141" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC143" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 33. Variable list </h1>

<p>This chapter contains a list of variables currently defined within
Festival available for general use.  This list is automatically
generated from the documentation strings of the variables as they are
defined within the system, so has some chance in being up-to-date.

</p><p>Cross references to sections elsewhere int he manual are given where 
appropriate.

</p>

<hr size="6">
<a name="NOD114"></a>
<a name="SEC143"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC142" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC142" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 34. Function list </h1>

<p>This chapter contains a list of functions currently defined within
Festival available for general use.  This list is automatically
generated from the documentation strings of the functions as they are
defined within the system, so has some chance in being up-to-date.

</p><p>Note some of the functions which have origins in the SIOD system itself
are little used in Festival and may not work fully, particularly, the
arrays.

</p><p>Cross references to sections elsewhere in the manual are given where 
appropriate.

</p>

<hr size="6">
<a name="NOD115"></a>
<a name="SEC144"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC143" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[ &gt; ]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC143" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#NOD1" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[ &gt;&gt; ]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="unnumbered"> Index </h1>

<table><tr><th valign="top">Jump to: &nbsp; </th><td><a href="#SEC144_0" class="summary-letter"><b>.</b></a>
 &nbsp; 
<a href="#SEC144_1" class="summary-letter"><b>/</b></a>
 &nbsp; 
<br>
<a href="#SEC144_2" class="summary-letter"><b>A</b></a>
 &nbsp; 
<a href="#SEC144_3" class="summary-letter"><b>B</b></a>
 &nbsp; 
<a href="#SEC144_4" class="summary-letter"><b>C</b></a>
 &nbsp; 
<a href="#SEC144_5" class="summary-letter"><b>D</b></a>
 &nbsp; 
<a href="#SEC144_6" class="summary-letter"><b>E</b></a>
 &nbsp; 
<a href="#SEC144_7" class="summary-letter"><b>F</b></a>
 &nbsp; 
<a href="#SEC144_8" class="summary-letter"><b>G</b></a>
 &nbsp; 
<a href="#SEC144_9" class="summary-letter"><b>H</b></a>
 &nbsp; 
<a href="#SEC144_10" class="summary-letter"><b>I</b></a>
 &nbsp; 
<a href="#SEC144_11" class="summary-letter"><b>J</b></a>
 &nbsp; 
<a href="#SEC144_12" class="summary-letter"><b>K</b></a>
 &nbsp; 
<a href="#SEC144_13" class="summary-letter"><b>L</b></a>
 &nbsp; 
<a href="#SEC144_14" class="summary-letter"><b>M</b></a>
 &nbsp; 
<a href="#SEC144_15" class="summary-letter"><b>N</b></a>
 &nbsp; 
<a href="#SEC144_16" class="summary-letter"><b>O</b></a>
 &nbsp; 
<a href="#SEC144_17" class="summary-letter"><b>P</b></a>
 &nbsp; 
<a href="#SEC144_18" class="summary-letter"><b>Q</b></a>
 &nbsp; 
<a href="#SEC144_19" class="summary-letter"><b>R</b></a>
 &nbsp; 
<a href="#SEC144_20" class="summary-letter"><b>S</b></a>
 &nbsp; 
<a href="#SEC144_21" class="summary-letter"><b>T</b></a>
 &nbsp; 
<a href="#SEC144_22" class="summary-letter"><b>U</b></a>
 &nbsp; 
<a href="#SEC144_23" class="summary-letter"><b>V</b></a>
 &nbsp; 
<a href="#SEC144_24" class="summary-letter"><b>W</b></a>
 &nbsp; 
<a href="#SEC144_25" class="summary-letter"><b>X</b></a>
 &nbsp; 
</td></tr></table><table border="0" class="index-cp">
<tr><td></td><th align="left">Index Entry</th><th align="left"> Section</th></tr>
<tr><td colspan="3"> <hr></td></tr>
<tr><th><a name="SEC144_0">.</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#IDX31">`<tt>.festivalrc</tt>'</a></td><td valign="top"><a href="#SEC15">6.3 Site initialization</a></td></tr>
<tr><td colspan="3"> <hr></td></tr>
<tr><th><a name="SEC144_1">/</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#IDX197">`<tt>/dev/audio</tt>'</a></td><td valign="top"><a href="#SEC95">23. Audio output</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX199">`<tt>/dev/audio</tt>'</a></td><td valign="top"><a href="#SEC95">23. Audio output</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX201">`<tt>/dev/dsp</tt>'</a></td><td valign="top"><a href="#SEC95">23. Audio output</a></td></tr>
<tr><td colspan="3"> <hr></td></tr>
<tr><th><a name="SEC144_2">A</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#SEC89">access strategies</a></td><td valign="top"><a href="#SEC89">21.5 Access strategies</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX232">accessing Lisp variables</a></td><td valign="top"><a href="#SEC122">27.2.1 Example 1: adding new modules</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC3">acknowledgements</a></td><td valign="top"><a href="#SEC3">3. Acknowledgements</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX111">addenda</a></td><td valign="top"><a href="#SEC40">13.2 Defining lexicons</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC124">adding new directories</a></td><td valign="top"><a href="#SEC124">27.2.3 Example 3: adding new directories</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC125">adding new LISP objects</a></td><td valign="top"><a href="#SEC125">27.2.4 Example 4: adding new LISP objects</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC122">adding new modules</a></td><td valign="top"><a href="#SEC122">27.2.1 Example 1: adding new modules</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC108">adding new voices</a></td><td valign="top"><a href="#SEC108">24.3 Defining a new voice</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX149"><code>after_analysis_hooks</code></a></td><td valign="top"><a href="#SEC49">14.2 Utterance types</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX150"><code>after_synth_hooks</code></a></td><td valign="top"><a href="#SEC49">14.2 Utterance types</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX188">alternate diphones</a></td><td valign="top"><a href="#SEC80">20.3 Database declaration</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX139">apostrophe s</a></td><td valign="top"><a href="#SEC46">13.8 Post-lexical rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX214">asynchronous synthesis</a></td><td valign="top"><a href="#SEC95">23. Audio output</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX80"><code>atof</code></a></td><td valign="top"><a href="#SEC25">8.4 Scheme I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX209">audio command</a></td><td valign="top"><a href="#SEC95">23. Audio output</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX27">audio command output</a></td><td valign="top"><a href="#SEC15">6.3 Site initialization</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX210">audio devices</a></td><td valign="top"><a href="#SEC95">23. Audio output</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX6">audio hardware</a></td><td valign="top"><a href="#SEC13">6.1 Requirements</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC95">audio output</a></td><td valign="top"><a href="#SEC95">23. Audio output</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX29">audio output filetype</a></td><td valign="top"><a href="#SEC15">6.3 Site initialization</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX28">audio output rate</a></td><td valign="top"><a href="#SEC15">6.3 Site initialization</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX33">audio problems</a></td><td valign="top"><a href="#SEC16">6.4 Checking an installation</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX213">audio spooler</a></td><td valign="top"><a href="#SEC95">23. Audio output</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX84"><code>auto-text-mode-alist</code></a></td><td valign="top"><a href="#SEC28">9.2 Text modes</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX85">automatic selection of text mode</a></td><td valign="top"><a href="#SEC28">9.2 Text modes</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX16">automounter</a></td><td valign="top"><a href="#SEC14">6.2 Configuration</a></td></tr>
<tr><td colspan="3"> <hr></td></tr>
<tr><th><a name="SEC144_3">B</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#IDX65">backtrace</a></td><td valign="top"><a href="#SEC24">8.3 Scheme Festival specifics</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX37">batch mode</a></td><td valign="top"><a href="#SEC18">7.1 Basic command line options</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX116">BEEP lexicon</a></td><td valign="top"><a href="#SEC41">13.3 Lookup process</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX137">BEEP lexicon</a></td><td valign="top"><a href="#SEC45">13.7 Available lexicons</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX151"><code>before_synth_hooks</code></a></td><td valign="top"><a href="#SEC49">14.2 Utterance types</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX61">bug reports</a></td><td valign="top"><a href="#SEC20">7.3 Getting some help</a></td></tr>
<tr><td colspan="3"> <hr></td></tr>
<tr><th><a name="SEC144_4">C</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#SEC134">C interface</a></td><td valign="top"><a href="#SEC134">28.5 C only API</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX4">C++</a></td><td valign="top"><a href="#SEC13">6.1 Requirements</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX164">CART trees</a></td><td valign="top"><a href="#SEC53">14.6 Features</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC111">CART trees</a></td><td valign="top"><a href="#SEC111">25.2 CART trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX89">Cascading style sheets</a></td><td valign="top"><a href="#SEC30">10. XML/SGML mark-up</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX71">catching errors</a></td><td valign="top"><a href="#SEC24">8.3 Scheme Festival specifics</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX67">catching errors in Scheme</a></td><td valign="top"><a href="#SEC24">8.3 Scheme Festival specifics</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX22">change libdir at run-time</a></td><td valign="top"><a href="#SEC15">6.3 Site initialization</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC131">client</a></td><td valign="top"><a href="#SEC131">28.3.2 Client control</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC132">client/server protocol</a></td><td valign="top"><a href="#SEC132">28.3.3 Server/client protocol</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX117">CMU lexicon</a></td><td valign="top"><a href="#SEC41">13.3 Lookup process</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX135">CMU lexicon</a></td><td valign="top"><a href="#SEC45">13.7 Available lexicons</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC18">command line options</a></td><td valign="top"><a href="#SEC18">7.1 Basic command line options</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX34">command mode</a></td><td valign="top"><a href="#SEC17">7. Quick start</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX40">command mode</a></td><td valign="top"><a href="#SEC18">7.1 Basic command line options</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX115">compiled lexicons</a></td><td valign="top"><a href="#SEC41">13.3 Lookup process</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX109">compiling a lexicon</a></td><td valign="top"><a href="#SEC40">13.2 Defining lexicons</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX127">compressing the lexicon</a></td><td valign="top"><a href="#SEC43">13.5 Building letter to sound rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX13">`<tt>config/config</tt>'</a></td><td valign="top"><a href="#SEC14">6.2 Configuration</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX12">configuration</a></td><td valign="top"><a href="#SEC14">6.2 Configuration</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC90">consonant clusters</a></td><td valign="top"><a href="#SEC90">21.6 Diphone selection</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX82">convert string to number</a></td><td valign="top"><a href="#SEC25">8.4 Scheme I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC40">creating a lexicon</a></td><td valign="top"><a href="#SEC40">13.2 Defining lexicons</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX230">creating utterances</a></td><td valign="top"><a href="#SEC116">26.1 Labelling databases</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX215">CSLU</a></td><td valign="top"><a href="#SEC97">24.1 Current voices</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX88">CSS</a></td><td valign="top"><a href="#SEC30">10. XML/SGML mark-up</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX219">current voice</a></td><td valign="top"><a href="#SEC107">24.2.9 Resetting globals</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX133">CUVOALD lexicon</a></td><td valign="top"><a href="#SEC45">13.7 Available lexicons</a></td></tr>
<tr><td colspan="3"> <hr></td></tr>
<tr><th><a name="SEC144_5">D</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#SEC90">dark l's</a></td><td valign="top"><a href="#SEC90">21.6 Diphone selection</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC116">database labelling</a></td><td valign="top"><a href="#SEC116">26.1 Labelling databases</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC115">databases</a></td><td valign="top"><a href="#SEC115">26. Building models from databases</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX63">debugging Scheme errors</a></td><td valign="top"><a href="#SEC24">8.3 Scheme Festival specifics</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX64">debugging scripts</a></td><td valign="top"><a href="#SEC24">8.3 Scheme Festival specifics</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX87">declaring text modes</a></td><td valign="top"><a href="#SEC29">9.3 Example text mode</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX186">default diphone</a></td><td valign="top"><a href="#SEC80">20.3 Database declaration</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX30">default voice</a></td><td valign="top"><a href="#SEC15">6.3 Site initialization</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX146"><code>defSynthType</code></a></td><td valign="top"><a href="#SEC49">14.2 Utterance types</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC49"><code>defUttType</code></a></td><td valign="top"><a href="#SEC49">14.2 Utterance types</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC38">dictionary</a></td><td valign="top"><a href="#SEC38">13. Lexicons</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX187">diphone alternates</a></td><td valign="top"><a href="#SEC80">20.3 Database declaration</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC81">diphone group files</a></td><td valign="top"><a href="#SEC81">20.4 Making groupfiles</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC79">diphone index</a></td><td valign="top"><a href="#SEC79">20.2 Generating a diphone index</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC90">diphone names</a></td><td valign="top"><a href="#SEC90">21.6 Diphone selection</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC83">diphone selection</a></td><td valign="top"><a href="#SEC83">20.6 Diphone selection</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC75">diphone synthesis</a></td><td valign="top"><a href="#SEC75">20. UniSyn synthesizer</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX191">diphone synthesis</a></td><td valign="top"><a href="#SEC84">21. Diphone synthesizer</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX192"><code>diphone_module_hooks</code></a></td><td valign="top"><a href="#SEC90">21.6 Diphone selection</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX193"><code>diphone_phone_name</code></a></td><td valign="top"><a href="#SEC90">21.6 Diphone selection</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX231">directory structure</a></td><td valign="top"><a href="#SEC120">27.1 The source code</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX177">display</a></td><td valign="top"><a href="#SEC54">14.7 Utterance I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX11">documentation</a></td><td valign="top"><a href="#SEC13">6.1 Requirements</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX90">DSSSL</a></td><td valign="top"><a href="#SEC30">10. XML/SGML mark-up</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC64">duff intonation</a></td><td valign="top"><a href="#SEC64">18.1 Default intonation</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC70">duration</a></td><td valign="top"><a href="#SEC70">19. Duration</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX182">duration stretch</a></td><td valign="top"><a href="#SEC70">19. Duration</a></td></tr>
<tr><td colspan="3"> <hr></td></tr>
<tr><th><a name="SEC144_6">E</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#SEC6">Edinburgh Speech Tools Library</a></td><td valign="top"><a href="#SEC6">3.3 Edinburgh Speech Tools Library</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX8">editline</a></td><td valign="top"><a href="#SEC13">6.1 Requirements</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC36">Emacs interface</a></td><td valign="top"><a href="#SEC36">11. Emacs interface</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC29">email mode</a></td><td valign="top"><a href="#SEC29">9.3 Example text mode</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC27"><code>eou_tree</code></a></td><td valign="top"><a href="#SEC27">9.1 Utterance chunking</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX69">errors in Scheme</a></td><td valign="top"><a href="#SEC24">8.3 Scheme Festival specifics</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX53">exiting Festival</a></td><td valign="top"><a href="#SEC19">7.2 Sample command driven session</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC117">extracting features</a></td><td valign="top"><a href="#SEC117">26.2 Extracting features</a></td></tr>
<tr><td colspan="3"> <hr></td></tr>
<tr><th><a name="SEC144_7">F</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#IDX181">F0 generation</a></td><td valign="top"><a href="#SEC65">18.2 Simple intonation</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX73"><code>fclose</code></a></td><td valign="top"><a href="#SEC25">8.4 Scheme I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC117">feature extraction</a></td><td valign="top"><a href="#SEC117">26.2 Extracting features</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC53">features</a></td><td valign="top"><a href="#SEC53">14.6 Features</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX223">features</a></td><td valign="top"><a href="#SEC111">25.2 CART trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC141">features</a></td><td valign="top"><a href="#SEC141">32. Feature functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX144">Festival relations</a></td><td valign="top"><a href="#SEC48">14.1 Utterance structure</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX43">Festival script files</a></td><td valign="top"><a href="#SEC18">7.1 Basic command line options</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX97">`<tt>festival.el</tt>'</a></td><td valign="top"><a href="#SEC36">11. Emacs interface</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC131">festival_client</a></td><td valign="top"><a href="#SEC131">28.3.2 Client control</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC134">festival_client.c</a></td><td valign="top"><a href="#SEC134">28.5 C only API</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC25">file i/o in Scheme</a></td><td valign="top"><a href="#SEC25">8.4 Scheme I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC71">fixed durations</a></td><td valign="top"><a href="#SEC71">19.1 Default durations</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX237">flinger</a></td><td valign="top"><a href="#SEC138">29.2 Singing Synthesis</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX72"><code>fopen</code></a></td><td valign="top"><a href="#SEC25">8.4 Scheme I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX74"><code>format</code></a></td><td valign="top"><a href="#SEC25">8.4 Scheme I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX75">formatted output</a></td><td valign="top"><a href="#SEC25">8.4 Scheme I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX203">FreeBSD</a></td><td valign="top"><a href="#SEC95">23. Audio output</a></td></tr>
<tr><td colspan="3"> <hr></td></tr>
<tr><th><a name="SEC144_8">G</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#IDX3">g++</a></td><td valign="top"><a href="#SEC13">6.1 Requirements</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX235">garbage collection</a></td><td valign="top"><a href="#SEC137">29.1 POS Example</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX236">GC</a></td><td valign="top"><a href="#SEC137">29.1 POS Example</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX2">GNU g++</a></td><td valign="top"><a href="#SEC13">6.1 Requirements</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX9">GNU readline</a></td><td valign="top"><a href="#SEC13">6.1 Requirements</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC81">group files</a></td><td valign="top"><a href="#SEC81">20.4 Making groupfiles</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC87">group files</a></td><td valign="top"><a href="#SEC87">21.3 Group files</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC76">grouped diphones</a></td><td valign="top"><a href="#SEC76">20.1 UniSyn database format</a></td></tr>
<tr><td colspan="3"> <hr></td></tr>
<tr><th><a name="SEC144_9">H</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#IDX44">heap size</a></td><td valign="top"><a href="#SEC18">7.1 Basic command line options</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX49">hello world</a></td><td valign="top"><a href="#SEC19">7.2 Sample command driven session</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC20">help</a></td><td valign="top"><a href="#SEC20">7.3 Getting some help</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX107">homographs</a></td><td valign="top"><a href="#SEC39">13.1 Lexical entries</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC58">homographs</a></td><td valign="top"><a href="#SEC58">15.3 Homograph disambiguation</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX66">hooks</a></td><td valign="top"><a href="#SEC24">8.3 Scheme Festival specifics</a></td></tr>
<tr><td colspan="3"> <hr></td></tr>
<tr><th><a name="SEC144_10">I</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#SEC25">i/o in Scheme</a></td><td valign="top"><a href="#SEC25">8.4 Scheme I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC15">`<tt>init.scm</tt>'</a></td><td valign="top"><a href="#SEC15">6.3 Site initialization</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC15">initialization</a></td><td valign="top"><a href="#SEC15">6.3 Site initialization</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX145"><code>Initialize</code></a></td><td valign="top"><a href="#SEC49">14.2 Utterance types</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC15">installation initialization</a></td><td valign="top"><a href="#SEC15">6.3 Site initialization</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC65"><code>int_accent_cart_tree</code></a></td><td valign="top"><a href="#SEC65">18.2 Simple intonation</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX38">interactive mode</a></td><td valign="top"><a href="#SEC18">7.1 Basic command line options</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX227">IntEvent labelling</a></td><td valign="top"><a href="#SEC116">26.1 Labelling databases</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX228">IntEvent labelling</a></td><td valign="top"><a href="#SEC116">26.1 Labelling databases</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC63">intonation</a></td><td valign="top"><a href="#SEC63">18. Intonation</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX207">IRIX</a></td><td valign="top"><a href="#SEC95">23. Audio output</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX163"><code>item</code> functions</a></td><td valign="top"><a href="#SEC52">14.5 Accessing an utterance</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX142">Items</a></td><td valign="top"><a href="#SEC48">14.1 Utterance structure</a></td></tr>
<tr><td colspan="3"> <hr></td></tr>
<tr><th><a name="SEC144_11">J</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#SEC135">Java</a></td><td valign="top"><a href="#SEC135">28.6 Java and JSAPI</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC135">JSAPI</a></td><td valign="top"><a href="#SEC135">28.6 Java and JSAPI</a></td></tr>
<tr><td colspan="3"> <hr></td></tr>
<tr><th><a name="SEC144_12">K</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#SEC73">Klatt duration rules</a></td><td valign="top"><a href="#SEC73">19.3 Klatt durations</a></td></tr>
<tr><td colspan="3"> <hr></td></tr>
<tr><th><a name="SEC144_13">L</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#SEC116">labelling</a></td><td valign="top"><a href="#SEC116">26.1 Labelling databases</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX41">language specification</a></td><td valign="top"><a href="#SEC18">7.1 Basic command line options</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC77">laryngograph</a></td><td valign="top"><a href="#SEC77">20.1.1 Generating pitchmarks</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX110">letter to sound rules</a></td><td valign="top"><a href="#SEC40">13.2 Defining lexicons</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC42">letter to sound rules</a></td><td valign="top"><a href="#SEC42">13.4 Letter to sound rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX123">letter to sound rules</a></td><td valign="top"><a href="#SEC42">13.4 Letter to sound rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX218">letter to sound rules</a></td><td valign="top"><a href="#SEC100">24.2.2 Lexicon and LTS</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC39">lexical entries</a></td><td valign="top"><a href="#SEC39">13.1 Lexical entries</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX108">lexical stress</a></td><td valign="top"><a href="#SEC39">13.1 Lexical entries</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX1">lexicon</a></td><td valign="top"><a href="#SEC13">6.1 Requirements</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC38">lexicon</a></td><td valign="top"><a href="#SEC38">13. Lexicons</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC45">lexicon</a></td><td valign="top"><a href="#SEC45">13.7 Available lexicons</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX112">lexicon addenda</a></td><td valign="top"><a href="#SEC40">13.2 Defining lexicons</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX129">lexicon compression</a></td><td valign="top"><a href="#SEC43">13.5 Building letter to sound rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX217">lexicon creation</a></td><td valign="top"><a href="#SEC100">24.2.2 Lexicon and LTS</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX113">lexicon hooks</a></td><td valign="top"><a href="#SEC41">13.3 Lookup process</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC44">lexicon requirements</a></td><td valign="top"><a href="#SEC44">13.6 Lexicon requirements</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX165">linear regression</a></td><td valign="top"><a href="#SEC53">14.6 Features</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC114">linear regression</a></td><td valign="top"><a href="#SEC114">25.5 Linear regression</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX18">Linux</a></td><td valign="top"><a href="#SEC14">6.2 Configuration</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX202">Linux</a></td><td valign="top"><a href="#SEC95">23. Audio output</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX24"><code>load-path</code></a></td><td valign="top"><a href="#SEC15">6.3 Site initialization</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX173">loading a waveform</a></td><td valign="top"><a href="#SEC54">14.7 Utterance I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX78">loading data from files</a></td><td valign="top"><a href="#SEC25">8.4 Scheme I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX183">local duration stretch</a></td><td valign="top"><a href="#SEC70">19. Duration</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX114">lookup hooks</a></td><td valign="top"><a href="#SEC41">13.3 Lookup process</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC78">LPC analysis</a></td><td valign="top"><a href="#SEC78">20.1.2 Generating LPC coefficients</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC78">LPC residual</a></td><td valign="top"><a href="#SEC78">20.1.2 Generating LPC coefficients</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX124">LTS</a></td><td valign="top"><a href="#SEC42">13.4 Letter to sound rules</a></td></tr>
<tr><td colspan="3"> <hr></td></tr>
<tr><th><a name="SEC144_14">M</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#IDX60"><code>manual</code></a></td><td valign="top"><a href="#SEC20">7.3 Getting some help</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX101">mapping between phones</a></td><td valign="top"><a href="#SEC37">12. Phonesets</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC93">MBROLA</a></td><td valign="top"><a href="#SEC93">22.2 MBROLA</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX21">minimal system</a></td><td valign="top"><a href="#SEC14">6.2 Configuration</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX138">MOBY lexicon</a></td><td valign="top"><a href="#SEC45">13.7 Available lexicons</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC51">modules</a></td><td valign="top"><a href="#SEC51">14.4 Utterance modules</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC64">monotone</a></td><td valign="top"><a href="#SEC64">18.1 Default intonation</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX136">mrpa lexicon</a></td><td valign="top"><a href="#SEC45">13.7 Available lexicons</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX119">multiple lexical entries</a></td><td valign="top"><a href="#SEC41">13.3 Lookup process</a></td></tr>
<tr><td colspan="3"> <hr></td></tr>
<tr><th><a name="SEC144_15">N</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#IDX195">NAS</a></td><td valign="top"><a href="#SEC95">23. Audio output</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX196">netaudio</a></td><td valign="top"><a href="#SEC95">23. Audio output</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC122">new modules</a></td><td valign="top"><a href="#SEC122">27.2.1 Example 1: adding new modules</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX15">NFS</a></td><td valign="top"><a href="#SEC14">6.2 Configuration</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC112">ngrams</a></td><td valign="top"><a href="#SEC112">25.3 Ngrams</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX131">NO digits</a></td><td valign="top"><a href="#SEC44">13.6 Lexicon requirements</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX93">`<tt>nsgmls</tt>'</a></td><td valign="top"><a href="#SEC34">10.4 XML/SGML requirements</a></td></tr>
<tr><td colspan="3"> <hr></td></tr>
<tr><th><a name="SEC144_16">O</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#IDX58">offline TTS</a></td><td valign="top"><a href="#SEC19">7.2 Sample command driven session</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX14">OTHER_DIRS</a></td><td valign="top"><a href="#SEC14">6.2 Configuration</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX26">output file type</a></td><td valign="top"><a href="#SEC15">6.3 Site initialization</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX25">output sample rate</a></td><td valign="top"><a href="#SEC15">6.3 Site initialization</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC90">overriding diphone names</a></td><td valign="top"><a href="#SEC90">21.6 Diphone selection</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX134">Oxford Advanced Learners' Dictionary</a></td><td valign="top"><a href="#SEC45">13.7 Available lexicons</a></td></tr>
<tr><td colspan="3"> <hr></td></tr>
<tr><th><a name="SEC144_17">P</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#SEC4">Paradigm Associates</a></td><td valign="top"><a href="#SEC4">3.1 SIOD</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX161">Parameters</a></td><td valign="top"><a href="#SEC51">14.4 Utterance modules</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX79"><code>parse-number</code></a></td><td valign="top"><a href="#SEC25">8.4 Scheme I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX105">part of speech map</a></td><td valign="top"><a href="#SEC39">13.1 Lexical entries</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX103">part of speech tag</a></td><td valign="top"><a href="#SEC39">13.1 Lexical entries</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC61">part of speech tagging</a></td><td valign="top"><a href="#SEC61">16. POS tagging</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX234">perl</a></td><td valign="top"><a href="#SEC131">28.3.2 Client control</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX86">personal text modes</a></td><td valign="top"><a href="#SEC28">9.2 Text modes</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX102">phone maps</a></td><td valign="top"><a href="#SEC37">12. Phonesets</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC37">phoneme definitions</a></td><td valign="top"><a href="#SEC37">12. Phonesets</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX156"><code>Phones</code> utterance</a></td><td valign="top"><a href="#SEC50">14.3 Example utterance types</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC99">phoneset definitions</a></td><td valign="top"><a href="#SEC99">24.2.1 Phoneset</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC37">phonesets</a></td><td valign="top"><a href="#SEC37">12. Phonesets</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC62">phrase breaks</a></td><td valign="top"><a href="#SEC62">17. Phrase breaks</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC77">pitchmarking</a></td><td valign="top"><a href="#SEC77">20.1.1 Generating pitchmarks</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX51">playing an utterance</a></td><td valign="top"><a href="#SEC19">7.2 Sample command driven session</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX104">POS</a></td><td valign="top"><a href="#SEC39">13.1 Lexical entries</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC137">POS example</a></td><td valign="top"><a href="#SEC137">29.1 POS Example</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC61">POS tagging</a></td><td valign="top"><a href="#SEC61">16. POS tagging</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX130">possessives</a></td><td valign="top"><a href="#SEC44">13.6 Lexicon requirements</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX140">possessives</a></td><td valign="top"><a href="#SEC46">13.8 Post-lexical rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC46">post-lexical rules</a></td><td valign="top"><a href="#SEC46">13.8 Post-lexical rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX121">post_hooks</a></td><td valign="top"><a href="#SEC41">13.3 Lookup process</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX184">power normalisation</a></td><td valign="top"><a href="#SEC78">20.1.2 Generating LPC coefficients</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX120">pre_hooks</a></td><td valign="top"><a href="#SEC41">13.3 Lookup process</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX126">predicting stress</a></td><td valign="top"><a href="#SEC43">13.5 Building letter to sound rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX76">pretty printing</a></td><td valign="top"><a href="#SEC25">8.4 Scheme I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX221"><code>proclaim_voice</code></a></td><td valign="top"><a href="#SEC108">24.3 Defining a new voice</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC119">programming</a></td><td valign="top"><a href="#SEC119">27. Programming</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX106">pronunciation</a></td><td valign="top"><a href="#SEC39">13.1 Lexical entries</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX190">PSOLA</a></td><td valign="top"><a href="#SEC82">20.5 UniSyn module selection</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC56">punctuation</a></td><td valign="top"><a href="#SEC56">15.1 Tokenizing</a></td></tr>
<tr><td colspan="3"> <hr></td></tr>
<tr><th><a name="SEC144_18">Q</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#IDX54"><code>quit</code></a></td><td valign="top"><a href="#SEC19">7.2 Sample command driven session</a></td></tr>
<tr><td colspan="3"> <hr></td></tr>
<tr><th><a name="SEC144_19">R</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#IDX47">read-eval-print loop</a></td><td valign="top"><a href="#SEC19">7.2 Sample command driven session</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX77">reading from files</a></td><td valign="top"><a href="#SEC25">8.4 Scheme I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX7">readline</a></td><td valign="top"><a href="#SEC13">6.1 Requirements</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC2">redistribution</a></td><td valign="top"><a href="#SEC2">2. Copying</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX128">reducing the lexicon</a></td><td valign="top"><a href="#SEC43">13.5 Building letter to sound rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC110">regex</a></td><td valign="top"><a href="#SEC110">25.1 Regular expressions</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC110">regular expressions</a></td><td valign="top"><a href="#SEC110">25.1 Regular expressions</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX143">Relations</a></td><td valign="top"><a href="#SEC48">14.1 Utterance structure</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC123">Relations</a></td><td valign="top"><a href="#SEC123">27.2.2 Example 2: accessing the utterance</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX211">remote audio</a></td><td valign="top"><a href="#SEC95">23. Audio output</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC13">requirements</a></td><td valign="top"><a href="#SEC13">6.1 Requirements</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX169">resampling</a></td><td valign="top"><a href="#SEC54">14.7 Utterance I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX170">rescaling a waveform</a></td><td valign="top"><a href="#SEC54">14.7 Utterance I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC107">reseting globals</a></td><td valign="top"><a href="#SEC107">24.2.9 Resetting globals</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC78">residual</a></td><td valign="top"><a href="#SEC78">20.1.2 Generating LPC coefficients</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC2">restrictions</a></td><td valign="top"><a href="#SEC2">2. Copying</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX179">resynthesis</a></td><td valign="top"><a href="#SEC54">14.7 Utterance I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC15">run-time configuration</a></td><td valign="top"><a href="#SEC15">6.3 Site initialization</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX23">run-time configuration</a></td><td valign="top"><a href="#SEC15">6.3 Site initialization</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC34">rxp</a></td><td valign="top"><a href="#SEC34">10.4 XML/SGML requirements</a></td></tr>
<tr><td colspan="3"> <hr></td></tr>
<tr><th><a name="SEC144_20">S</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#SEC30">Sable</a></td><td valign="top"><a href="#SEC30">10. XML/SGML mark-up</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX91">SABLE DTD</a></td><td valign="top"><a href="#SEC31">10.1 Sable example</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC32">Sable tags</a></td><td valign="top"><a href="#SEC32">10.2 Supported Sable tags</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC35">Sable using</a></td><td valign="top"><a href="#SEC35">10.5 Using Sable</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX92">`<tt>Sable.v0_2.dtd</tt>'</a></td><td valign="top"><a href="#SEC31">10.1 Sable example</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX175">saving relations</a></td><td valign="top"><a href="#SEC54">14.7 Utterance I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX95">saving Sable waveforms</a></td><td valign="top"><a href="#SEC35">10.5 Using Sable</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX174">saving segments</a></td><td valign="top"><a href="#SEC54">14.7 Utterance I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX168">saving the waveform</a></td><td valign="top"><a href="#SEC54">14.7 Utterance I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX96">saving TTS waveforms</a></td><td valign="top"><a href="#SEC35">10.5 Using Sable</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX98"><code>say-minor-mode</code></a></td><td valign="top"><a href="#SEC36">11. Emacs interface</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX157"><code>SayPhones</code></a></td><td valign="top"><a href="#SEC50">14.3 Example utterance types</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX52"><code>SayText</code></a></td><td valign="top"><a href="#SEC19">7.2 Sample command driven session</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC4">Scheme</a></td><td valign="top"><a href="#SEC4">3.1 SIOD</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX46">Scheme</a></td><td valign="top"><a href="#SEC19">7.2 Sample command driven session</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX45">Scheme heap size</a></td><td valign="top"><a href="#SEC18">7.1 Basic command line options</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC21">Scheme introduction</a></td><td valign="top"><a href="#SEC21">8. Scheme</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC127">Scheme programming</a></td><td valign="top"><a href="#SEC127">28.1 Scheme API</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX62">Scheme references</a></td><td valign="top"><a href="#SEC22">8.1 Scheme references</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX42">script files</a></td><td valign="top"><a href="#SEC18">7.1 Basic command line options</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC137">script programming</a></td><td valign="top"><a href="#SEC137">29.1 POS Example</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX233">scripts</a></td><td valign="top"><a href="#SEC127">28.1 Scheme API</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC130">security</a></td><td valign="top"><a href="#SEC130">28.3.1 Server access control</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX160"><code>SegF0</code> utterance</a></td><td valign="top"><a href="#SEC50">14.3 Example utterance types</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX224">Segment labelling</a></td><td valign="top"><a href="#SEC116">26.1 Labelling databases</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX155"><code>Segments</code> utterance</a></td><td valign="top"><a href="#SEC50">14.3 Example utterance types</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX100">selecting a phoneset</a></td><td valign="top"><a href="#SEC37">12. Phonesets</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC83">selection of diphones</a></td><td valign="top"><a href="#SEC83">20.6 Diphone selection</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX194">selection-based synthesis</a></td><td valign="top"><a href="#SEC94">22.3 Synthesizers in development</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC76">separate diphones</a></td><td valign="top"><a href="#SEC76">20.1 UniSyn database format</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC129">server mode</a></td><td valign="top"><a href="#SEC129">28.3 Server/client API</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC130">server security</a></td><td valign="top"><a href="#SEC130">28.3.1 Server access control</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC132">server/client protocol</a></td><td valign="top"><a href="#SEC132">28.3.3 Server/client protocol</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX208">SGI</a></td><td valign="top"><a href="#SEC95">23. Audio output</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC30">SGML</a></td><td valign="top"><a href="#SEC30">10. XML/SGML mark-up</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX94">SGML parser</a></td><td valign="top"><a href="#SEC34">10.4 XML/SGML requirements</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC128">shell programming</a></td><td valign="top"><a href="#SEC128">28.2 Shell API</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX99">silences</a></td><td valign="top"><a href="#SEC37">12. Phonesets</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX216">silences</a></td><td valign="top"><a href="#SEC99">24.2.1 Phoneset</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC138">singing</a></td><td valign="top"><a href="#SEC138">29.2 Singing Synthesis</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC4">SIOD</a></td><td valign="top"><a href="#SEC4">3.1 SIOD</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC15">`<tt>siteinit.scm</tt>'</a></td><td valign="top"><a href="#SEC15">6.3 Site initialization</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX20">smaller system</a></td><td valign="top"><a href="#SEC14">6.2 Configuration</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX212">snack</a></td><td valign="top"><a href="#SEC95">23. Audio output</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC120">source</a></td><td valign="top"><a href="#SEC120">27.1 The source code</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC98">spanish voice</a></td><td valign="top"><a href="#SEC98">24.2 Building a new voice</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC30">Spoken Text Mark-up Language</a></td><td valign="top"><a href="#SEC30">10. XML/SGML mark-up</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC30">SSML</a></td><td valign="top"><a href="#SEC30">10. XML/SGML mark-up</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC30">STML</a></td><td valign="top"><a href="#SEC30">10. XML/SGML mark-up</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX125">stress assignment</a></td><td valign="top"><a href="#SEC43">13.5 Building letter to sound rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX81">string to number</a></td><td valign="top"><a href="#SEC25">8.4 Scheme I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX200">sun16</a></td><td valign="top"><a href="#SEC95">23. Audio output</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX198">sunaudio</a></td><td valign="top"><a href="#SEC95">23. Audio output</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX17">SunOS</a></td><td valign="top"><a href="#SEC14">6.2 Configuration</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX118">syllabification</a></td><td valign="top"><a href="#SEC41">13.3 Lookup process</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX226">Syllable labelling</a></td><td valign="top"><a href="#SEC116">26.1 Labelling databases</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX148">synthesis hooks</a></td><td valign="top"><a href="#SEC49">14.2 Utterance types</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX180">synthesis of natural utterances</a></td><td valign="top"><a href="#SEC54">14.7 Utterance I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX50">synthesizing an utterance</a></td><td valign="top"><a href="#SEC19">7.2 Sample command driven session</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX147">SynthTypes</a></td><td valign="top"><a href="#SEC49">14.2 Utterance types</a></td></tr>
<tr><td colspan="3"> <hr></td></tr>
<tr><th><a name="SEC144_21">T</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#SEC61">tagging</a></td><td valign="top"><a href="#SEC61">16. POS tagging</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX152">talking head</a></td><td valign="top"><a href="#SEC49">14.2 Utterance types</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX229">Target labelling</a></td><td valign="top"><a href="#SEC116">26.1 Labelling databases</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX189">TD-PSOLA</a></td><td valign="top"><a href="#SEC82">20.5 UniSyn module selection</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX10">`<tt>texi2html</tt>'</a></td><td valign="top"><a href="#SEC13">6.1 Requirements</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX83">text modes</a></td><td valign="top"><a href="#SEC26">9. TTS</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC28">text modes</a></td><td valign="top"><a href="#SEC28">9.2 Text modes</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX56">text to speech</a></td><td valign="top"><a href="#SEC19">7.2 Sample command driven session</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX57">text to wave</a></td><td valign="top"><a href="#SEC19">7.2 Sample command driven session</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX153"><code>Text</code> utterance</a></td><td valign="top"><a href="#SEC50">14.3 Example utterance types</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX35">text-to-speech mode</a></td><td valign="top"><a href="#SEC17">7. Quick start</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX59">text2wave</a></td><td valign="top"><a href="#SEC19">7.2 Sample command driven session</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC3">thanks</a></td><td valign="top"><a href="#SEC3">3. Acknowledgements</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC56">tokenizing</a></td><td valign="top"><a href="#SEC56">15.1 Tokenizing</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC57">tokens to words</a></td><td valign="top"><a href="#SEC57">15.2 Token to word rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX159"><code>Tokens</code> utterance</a></td><td valign="top"><a href="#SEC50">14.3 Example utterance types</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC109">tools</a></td><td valign="top"><a href="#SEC109">25. Tools</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX55">TTS</a></td><td valign="top"><a href="#SEC19">7.2 Sample command driven session</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX36">tts mode</a></td><td valign="top"><a href="#SEC17">7. Quick start</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX39">tts mode</a></td><td valign="top"><a href="#SEC18">7.1 Basic command line options</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC48">TTS processes</a></td><td valign="top"><a href="#SEC48">14.1 Utterance structure</a></td></tr>
<tr><td colspan="3"> <hr></td></tr>
<tr><th><a name="SEC144_22">U</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#SEC76">ungrouped diphones</a></td><td valign="top"><a href="#SEC76">20.1 UniSyn database format</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC75">UniSyn</a></td><td valign="top"><a href="#SEC75">20. UniSyn synthesizer</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX122">unknown words</a></td><td valign="top"><a href="#SEC42">13.4 Letter to sound rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX132">unknown words</a></td><td valign="top"><a href="#SEC44">13.6 Lexicon requirements</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX68"><code>unwind-protect</code></a></td><td valign="top"><a href="#SEC24">8.3 Scheme Festival specifics</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX70"><code>unwind-protect</code></a></td><td valign="top"><a href="#SEC24">8.3 Scheme Festival specifics</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX185"><code>us_diphone_init</code></a></td><td valign="top"><a href="#SEC80">20.3 Database declaration</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX32">user initialization</a></td><td valign="top"><a href="#SEC15">6.3 Site initialization</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC35">using Sable</a></td><td valign="top"><a href="#SEC35">10.5 Using Sable</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX172"><code>utt.import.wave</code></a></td><td valign="top"><a href="#SEC54">14.7 Utterance I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX167"><code>utt.load</code></a></td><td valign="top"><a href="#SEC54">14.7 Utterance I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX162"><code>utt.relation</code> functions</a></td><td valign="top"><a href="#SEC52">14.5 Accessing an utterance</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX166"><code>utt.save</code></a></td><td valign="top"><a href="#SEC54">14.7 Utterance I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX176"><code>utt.save.segs</code></a></td><td valign="top"><a href="#SEC54">14.7 Utterance I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX171"><code>utt.save.wave</code></a></td><td valign="top"><a href="#SEC54">14.7 Utterance I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC49"><code>utt.synth</code></a></td><td valign="top"><a href="#SEC49">14.2 Utterance types</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX48">utterance</a></td><td valign="top"><a href="#SEC19">7.2 Sample command driven session</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC47">utterance</a></td><td valign="top"><a href="#SEC47">14. Utterances</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC48">utterance</a></td><td valign="top"><a href="#SEC48">14.1 Utterance structure</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC27">utterance chunking</a></td><td valign="top"><a href="#SEC27">9.1 Utterance chunking</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC50">utterance examples</a></td><td valign="top"><a href="#SEC50">14.3 Example utterance types</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX141">Utterance structure</a></td><td valign="top"><a href="#SEC48">14.1 Utterance structure</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC49">utterance types</a></td><td valign="top"><a href="#SEC49">14.2 Utterance types</a></td></tr>
<tr><td colspan="3"> <hr></td></tr>
<tr><th><a name="SEC144_23">V</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#IDX19">Visual C++</a></td><td valign="top"><a href="#SEC14">6.2 Configuration</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC113">Viterbi decoder</a></td><td valign="top"><a href="#SEC113">25.4 Viterbi decoder</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX220"><code>voice-path</code></a></td><td valign="top"><a href="#SEC108">24.3 Defining a new voice</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC107"><code>voice_reset</code></a></td><td valign="top"><a href="#SEC107">24.2.9 Resetting globals</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC97">voices</a></td><td valign="top"><a href="#SEC97">24.1 Current voices</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX204">voxware</a></td><td valign="top"><a href="#SEC95">23. Audio output</a></td></tr>
<tr><td colspan="3"> <hr></td></tr>
<tr><th><a name="SEC144_24">W</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#IDX222">wagon</a></td><td valign="top"><a href="#SEC111">25.2 CART trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC118">wagon</a></td><td valign="top"><a href="#SEC118">26.3 Building models</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX158"><code>Wave</code> utterance</a></td><td valign="top"><a href="#SEC50">14.3 Example utterance types</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC75">waveform synthesis</a></td><td valign="top"><a href="#SEC75">20. UniSyn synthesizer</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC56">whitespace</a></td><td valign="top"><a href="#SEC56">15.1 Tokenizing</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC110">wild card matching</a></td><td valign="top"><a href="#SEC110">25.1 Regular expressions</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX206">Windows 95 audio</a></td><td valign="top"><a href="#SEC95">23. Audio output</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX205">Windows NT audio</a></td><td valign="top"><a href="#SEC95">23. Audio output</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX5">Windows NT/95</a></td><td valign="top"><a href="#SEC13">6.1 Requirements</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX225">Word labelling</a></td><td valign="top"><a href="#SEC116">26.1 Labelling databases</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX154"><code>Words</code> utterance</a></td><td valign="top"><a href="#SEC50">14.3 Example utterance types</a></td></tr>
<tr><td colspan="3"> <hr></td></tr>
<tr><th><a name="SEC144_25">X</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#SEC30">XML</a></td><td valign="top"><a href="#SEC30">10. XML/SGML mark-up</a></td></tr>
<tr><td></td><td valign="top"><a href="#SEC34">XML</a></td><td valign="top"><a href="#SEC34">10.4 XML/SGML requirements</a></td></tr>
<tr><td></td><td valign="top"><a href="#IDX178">Xwaves</a></td><td valign="top"><a href="#SEC54">14.7 Utterance I/O</a></td></tr>
<tr><td colspan="3"> <hr></td></tr>
</table><table><tr><th valign="top">Jump to: &nbsp; </th><td><a href="#SEC144_0" class="summary-letter"><b>.</b></a>
 &nbsp; 
<a href="#SEC144_1" class="summary-letter"><b>/</b></a>
 &nbsp; 
<br>
<a href="#SEC144_2" class="summary-letter"><b>A</b></a>
 &nbsp; 
<a href="#SEC144_3" class="summary-letter"><b>B</b></a>
 &nbsp; 
<a href="#SEC144_4" class="summary-letter"><b>C</b></a>
 &nbsp; 
<a href="#SEC144_5" class="summary-letter"><b>D</b></a>
 &nbsp; 
<a href="#SEC144_6" class="summary-letter"><b>E</b></a>
 &nbsp; 
<a href="#SEC144_7" class="summary-letter"><b>F</b></a>
 &nbsp; 
<a href="#SEC144_8" class="summary-letter"><b>G</b></a>
 &nbsp; 
<a href="#SEC144_9" class="summary-letter"><b>H</b></a>
 &nbsp; 
<a href="#SEC144_10" class="summary-letter"><b>I</b></a>
 &nbsp; 
<a href="#SEC144_11" class="summary-letter"><b>J</b></a>
 &nbsp; 
<a href="#SEC144_12" class="summary-letter"><b>K</b></a>
 &nbsp; 
<a href="#SEC144_13" class="summary-letter"><b>L</b></a>
 &nbsp; 
<a href="#SEC144_14" class="summary-letter"><b>M</b></a>
 &nbsp; 
<a href="#SEC144_15" class="summary-letter"><b>N</b></a>
 &nbsp; 
<a href="#SEC144_16" class="summary-letter"><b>O</b></a>
 &nbsp; 
<a href="#SEC144_17" class="summary-letter"><b>P</b></a>
 &nbsp; 
<a href="#SEC144_18" class="summary-letter"><b>Q</b></a>
 &nbsp; 
<a href="#SEC144_19" class="summary-letter"><b>R</b></a>
 &nbsp; 
<a href="#SEC144_20" class="summary-letter"><b>S</b></a>
 &nbsp; 
<a href="#SEC144_21" class="summary-letter"><b>T</b></a>
 &nbsp; 
<a href="#SEC144_22" class="summary-letter"><b>U</b></a>
 &nbsp; 
<a href="#SEC144_23" class="summary-letter"><b>V</b></a>
 &nbsp; 
<a href="#SEC144_24" class="summary-letter"><b>W</b></a>
 &nbsp; 
<a href="#SEC144_25" class="summary-letter"><b>X</b></a>
 &nbsp; 
</td></tr></table>


<hr size="6">
<a name="SEC_Contents"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1>Table of Contents</h1>
<div class="contents">

<ul class="toc">
  <li><a name="TOC1" href="#SEC1">1. Abstract</a></li>
  <li><a name="TOC2" href="#SEC2">2. Copying</a></li>
  <li><a name="TOC3" href="#SEC3">3. Acknowledgements</a>
  <ul class="toc">
    <li><a name="TOC4" href="#SEC4">3.1 SIOD</a></li>
    <li><a name="TOC5" href="#SEC5">3.2 editline</a></li>
    <li><a name="TOC6" href="#SEC6">3.3 Edinburgh Speech Tools Library</a></li>
    <li><a name="TOC7" href="#SEC7">3.4 Others</a></li>
  </ul></li>
  <li><a name="TOC8" href="#SEC8">4. What is new</a></li>
  <li><a name="TOC9" href="#SEC9">5. Overview</a>
  <ul class="toc">
    <li><a name="TOC10" href="#SEC10">5.1 Philosophy</a></li>
    <li><a name="TOC11" href="#SEC11">5.2 Future</a></li>
  </ul></li>
  <li><a name="TOC12" href="#SEC12">6. Installation</a>
  <ul class="toc">
    <li><a name="TOC13" href="#SEC13">6.1 Requirements</a></li>
    <li><a name="TOC14" href="#SEC14">6.2 Configuration</a></li>
    <li><a name="TOC15" href="#SEC15">6.3 Site initialization</a></li>
    <li><a name="TOC16" href="#SEC16">6.4 Checking an installation</a></li>
  </ul></li>
  <li><a name="TOC17" href="#SEC17">7. Quick start</a>
  <ul class="toc">
    <li><a name="TOC18" href="#SEC18">7.1 Basic command line options</a></li>
    <li><a name="TOC19" href="#SEC19">7.2 Sample command driven session</a></li>
    <li><a name="TOC20" href="#SEC20">7.3 Getting some help</a></li>
  </ul></li>
  <li><a name="TOC21" href="#SEC21">8. Scheme</a>
  <ul class="toc">
    <li><a name="TOC22" href="#SEC22">8.1 Scheme references</a></li>
    <li><a name="TOC23" href="#SEC23">8.2 Scheme fundamentals</a></li>
    <li><a name="TOC24" href="#SEC24">8.3 Scheme Festival specifics</a></li>
    <li><a name="TOC25" href="#SEC25">8.4 Scheme I/O</a></li>
  </ul></li>
  <li><a name="TOC26" href="#SEC26">9. TTS</a>
  <ul class="toc">
    <li><a name="TOC27" href="#SEC27">9.1 Utterance chunking</a></li>
    <li><a name="TOC28" href="#SEC28">9.2 Text modes</a></li>
    <li><a name="TOC29" href="#SEC29">9.3 Example text mode</a></li>
  </ul></li>
  <li><a name="TOC30" href="#SEC30">10. XML/SGML mark-up</a>
  <ul class="toc">
    <li><a name="TOC31" href="#SEC31">10.1 Sable example</a></li>
    <li><a name="TOC32" href="#SEC32">10.2 Supported Sable tags</a></li>
    <li><a name="TOC33" href="#SEC33">10.3 Adding Sable tags</a></li>
    <li><a name="TOC34" href="#SEC34">10.4 XML/SGML requirements</a></li>
    <li><a name="TOC35" href="#SEC35">10.5 Using Sable</a></li>
  </ul></li>
  <li><a name="TOC36" href="#SEC36">11. Emacs interface</a></li>
  <li><a name="TOC37" href="#SEC37">12. Phonesets</a></li>
  <li><a name="TOC38" href="#SEC38">13. Lexicons</a>
  <ul class="toc">
    <li><a name="TOC39" href="#SEC39">13.1 Lexical entries</a></li>
    <li><a name="TOC40" href="#SEC40">13.2 Defining lexicons</a></li>
    <li><a name="TOC41" href="#SEC41">13.3 Lookup process</a></li>
    <li><a name="TOC42" href="#SEC42">13.4 Letter to sound rules</a></li>
    <li><a name="TOC43" href="#SEC43">13.5 Building letter to sound rules</a></li>
    <li><a name="TOC44" href="#SEC44">13.6 Lexicon requirements</a></li>
    <li><a name="TOC45" href="#SEC45">13.7 Available lexicons</a></li>
    <li><a name="TOC46" href="#SEC46">13.8 Post-lexical rules</a></li>
  </ul></li>
  <li><a name="TOC47" href="#SEC47">14. Utterances</a>
  <ul class="toc">
    <li><a name="TOC48" href="#SEC48">14.1 Utterance structure</a></li>
    <li><a name="TOC49" href="#SEC49">14.2 Utterance types</a></li>
    <li><a name="TOC50" href="#SEC50">14.3 Example utterance types</a></li>
    <li><a name="TOC51" href="#SEC51">14.4 Utterance modules</a></li>
    <li><a name="TOC52" href="#SEC52">14.5 Accessing an utterance</a></li>
    <li><a name="TOC53" href="#SEC53">14.6 Features</a></li>
    <li><a name="TOC54" href="#SEC54">14.7 Utterance I/O</a></li>
  </ul></li>
  <li><a name="TOC55" href="#SEC55">15. Text analysis</a>
  <ul class="toc">
    <li><a name="TOC56" href="#SEC56">15.1 Tokenizing</a></li>
    <li><a name="TOC57" href="#SEC57">15.2 Token to word rules</a></li>
    <li><a name="TOC58" href="#SEC58">15.3 Homograph disambiguation</a>
    <ul class="toc">
      <li><a name="TOC59" href="#SEC59">15.3.1 Using disambiguators</a></li>
      <li><a name="TOC60" href="#SEC60">15.3.2 Building disambiguators</a></li>
    </ul>
</li>
  </ul></li>
  <li><a name="TOC61" href="#SEC61">16. POS tagging</a></li>
  <li><a name="TOC62" href="#SEC62">17. Phrase breaks</a></li>
  <li><a name="TOC63" href="#SEC63">18. Intonation</a>
  <ul class="toc">
    <li><a name="TOC64" href="#SEC64">18.1 Default intonation</a></li>
    <li><a name="TOC65" href="#SEC65">18.2 Simple intonation</a></li>
    <li><a name="TOC66" href="#SEC66">18.3 Tree intonation</a></li>
    <li><a name="TOC67" href="#SEC67">18.4 Tilt intonation</a></li>
    <li><a name="TOC68" href="#SEC68">18.5 General intonation</a></li>
    <li><a name="TOC69" href="#SEC69">18.6 Using ToBI</a></li>
  </ul></li>
  <li><a name="TOC70" href="#SEC70">19. Duration</a>
  <ul class="toc">
    <li><a name="TOC71" href="#SEC71">19.1 Default durations</a></li>
    <li><a name="TOC72" href="#SEC72">19.2 Average durations</a></li>
    <li><a name="TOC73" href="#SEC73">19.3 Klatt durations</a></li>
    <li><a name="TOC74" href="#SEC74">19.4 CART durations</a></li>
  </ul></li>
  <li><a name="TOC75" href="#SEC75">20. UniSyn synthesizer</a>
  <ul class="toc">
    <li><a name="TOC76" href="#SEC76">20.1 UniSyn database format</a>
    <ul class="toc">
      <li><a name="TOC77" href="#SEC77">20.1.1 Generating pitchmarks</a></li>
      <li><a name="TOC78" href="#SEC78">20.1.2 Generating LPC coefficients</a></li>
    </ul></li>
    <li><a name="TOC79" href="#SEC79">20.2 Generating a diphone index</a></li>
    <li><a name="TOC80" href="#SEC80">20.3 Database declaration</a></li>
    <li><a name="TOC81" href="#SEC81">20.4 Making groupfiles</a></li>
    <li><a name="TOC82" href="#SEC82">20.5 UniSyn module selection</a></li>
    <li><a name="TOC83" href="#SEC83">20.6 Diphone selection</a></li>
  </ul></li>
  <li><a name="TOC84" href="#SEC84">21. Diphone synthesizer</a>
  <ul class="toc">
    <li><a name="TOC85" href="#SEC85">21.1 Diphone database format</a></li>
    <li><a name="TOC86" href="#SEC86">21.2 LPC databases</a></li>
    <li><a name="TOC87" href="#SEC87">21.3 Group files</a></li>
    <li><a name="TOC88" href="#SEC88">21.4 Diphone_Init</a></li>
    <li><a name="TOC89" href="#SEC89">21.5 Access strategies</a></li>
    <li><a name="TOC90" href="#SEC90">21.6 Diphone selection</a></li>
  </ul></li>
  <li><a name="TOC91" href="#SEC91">22. Other synthesis methods</a>
  <ul class="toc">
    <li><a name="TOC92" href="#SEC92">22.1 LPC diphone synthesizer</a></li>
    <li><a name="TOC93" href="#SEC93">22.2 MBROLA</a></li>
    <li><a name="TOC94" href="#SEC94">22.3 Synthesizers in development</a></li>
  </ul></li>
  <li><a name="TOC95" href="#SEC95">23. Audio output</a></li>
  <li><a name="TOC96" href="#SEC96">24. Voices</a>
  <ul class="toc">
    <li><a name="TOC97" href="#SEC97">24.1 Current voices</a></li>
    <li><a name="TOC98" href="#SEC98">24.2 Building a new voice</a>
    <ul class="toc">
      <li><a name="TOC99" href="#SEC99">24.2.1 Phoneset</a></li>
      <li><a name="TOC100" href="#SEC100">24.2.2 Lexicon and LTS</a></li>
      <li><a name="TOC101" href="#SEC101">24.2.3 Phrasing</a></li>
      <li><a name="TOC102" href="#SEC102">24.2.4 Intonation</a></li>
      <li><a name="TOC103" href="#SEC103">24.2.5 Duration</a></li>
      <li><a name="TOC104" href="#SEC104">24.2.6 Waveform synthesis</a></li>
      <li><a name="TOC105" href="#SEC105">24.2.7 Voice selection function</a></li>
      <li><a name="TOC106" href="#SEC106">24.2.8 Last remarks</a></li>
      <li><a name="TOC107" href="#SEC107">24.2.9 Resetting globals</a></li>
    </ul></li>
    <li><a name="TOC108" href="#SEC108">24.3 Defining a new voice</a></li>
  </ul></li>
  <li><a name="TOC109" href="#SEC109">25. Tools</a>
  <ul class="toc">
    <li><a name="TOC110" href="#SEC110">25.1 Regular expressions</a></li>
    <li><a name="TOC111" href="#SEC111">25.2 CART trees</a></li>
    <li><a name="TOC112" href="#SEC112">25.3 Ngrams</a></li>
    <li><a name="TOC113" href="#SEC113">25.4 Viterbi decoder</a></li>
    <li><a name="TOC114" href="#SEC114">25.5 Linear regression</a></li>
  </ul></li>
  <li><a name="TOC115" href="#SEC115">26. Building models from databases</a>
  <ul class="toc">
    <li><a name="TOC116" href="#SEC116">26.1 Labelling databases</a></li>
    <li><a name="TOC117" href="#SEC117">26.2 Extracting features</a></li>
    <li><a name="TOC118" href="#SEC118">26.3 Building models</a></li>
  </ul></li>
  <li><a name="TOC119" href="#SEC119">27. Programming</a>
  <ul class="toc">
    <li><a name="TOC120" href="#SEC120">27.1 The source code</a></li>
    <li><a name="TOC121" href="#SEC121">27.2 Writing a new module</a>
    <ul class="toc">
      <li><a name="TOC122" href="#SEC122">27.2.1 Example 1: adding new modules</a></li>
      <li><a name="TOC123" href="#SEC123">27.2.2 Example 2: accessing the utterance</a></li>
      <li><a name="TOC124" href="#SEC124">27.2.3 Example 3: adding new directories</a></li>
      <li><a name="TOC125" href="#SEC125">27.2.4 Example 4: adding new LISP objects</a></li>
    </ul>
</li>
  </ul></li>
  <li><a name="TOC126" href="#SEC126">28. API</a>
  <ul class="toc">
    <li><a name="TOC127" href="#SEC127">28.1 Scheme API</a></li>
    <li><a name="TOC128" href="#SEC128">28.2 Shell API</a></li>
    <li><a name="TOC129" href="#SEC129">28.3 Server/client API</a>
    <ul class="toc">
      <li><a name="TOC130" href="#SEC130">28.3.1 Server access control</a></li>
      <li><a name="TOC131" href="#SEC131">28.3.2 Client control</a></li>
      <li><a name="TOC132" href="#SEC132">28.3.3 Server/client protocol</a></li>
    </ul></li>
    <li><a name="TOC133" href="#SEC133">28.4 C/C++ API</a></li>
    <li><a name="TOC134" href="#SEC134">28.5 C only API</a></li>
    <li><a name="TOC135" href="#SEC135">28.6 Java and JSAPI</a></li>
  </ul></li>
  <li><a name="TOC136" href="#SEC136">29. Examples</a>
  <ul class="toc">
    <li><a name="TOC137" href="#SEC137">29.1 POS Example</a></li>
    <li><a name="TOC138" href="#SEC138">29.2 Singing Synthesis</a></li>
  </ul></li>
  <li><a name="TOC139" href="#SEC139">30. Problems</a></li>
  <li><a name="TOC140" href="#SEC140">31. References</a></li>
  <li><a name="TOC141" href="#SEC141">32. Feature functions</a></li>
  <li><a name="TOC142" href="#SEC142">33. Variable list</a></li>
  <li><a name="TOC143" href="#SEC143">34. Function list</a></li>
  <li><a name="TOC144" href="#SEC144">Index</a></li>
</ul>
</div>
<hr size="1">
<a name="SEC_About"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#NOD1" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1>About This Document</h1>
<p>
  This document was generated by <em>Aleksey Cherkes</em> on <em>August, 29 2013</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.70</em></a>.
</p>
<p>
  The buttons in the navigation panels have the following meaning:
</p>
<table border="1">
  <tr>
    <th> Button </th>
    <th> Name </th>
    <th> Go to </th>
    <th> From 1.2.3 go to</th>
  </tr>
  <tr>
    <td align="center"> [ &lt; ] </td>
    <td align="center">Back</td>
    <td>previous section in reading order</td>
    <td>1.2.2</td>
  </tr>
  <tr>
    <td align="center"> [ &gt; ] </td>
    <td align="center">Forward</td>
    <td>next section in reading order</td>
    <td>1.2.4</td>
  </tr>
  <tr>
    <td align="center"> [ &lt;&lt; ] </td>
    <td align="center">FastBack</td>
    <td>beginning of this chapter or previous chapter</td>
    <td>1</td>
  </tr>
  <tr>
    <td align="center"> [ Up ] </td>
    <td align="center">Up</td>
    <td>up section</td>
    <td>1.2</td>
  </tr>
  <tr>
    <td align="center"> [ &gt;&gt; ] </td>
    <td align="center">FastForward</td>
    <td>next chapter</td>
    <td>2</td>
  </tr>
  <tr>
    <td align="center"> [Top] </td>
    <td align="center">Top</td>
    <td>cover (top) of document</td>
    <td> &nbsp; </td>
  </tr>
  <tr>
    <td align="center"> [Contents] </td>
    <td align="center">Contents</td>
    <td>table of contents</td>
    <td> &nbsp; </td>
  </tr>
  <tr>
    <td align="center"> [Index] </td>
    <td align="center">Index</td>
    <td>index</td>
    <td> &nbsp; </td>
  </tr>
  <tr>
    <td align="center"> [ ? ] </td>
    <td align="center">About</td>
    <td>about (help)</td>
    <td> &nbsp; </td>
  </tr>
</table>

<p>
  where the <strong> Example </strong> assumes that the current position is at <strong> Subsubsection One-Two-Three </strong> of a document of the following structure:
</p>

<ul>
  <li> 1. Section One
    <ul>
      <li>1.1 Subsection One-One
        <ul>
          <li>...</li>
        </ul>
      </li>
      <li>1.2 Subsection One-Two
        <ul>
          <li>1.2.1 Subsubsection One-Two-One</li>
          <li>1.2.2 Subsubsection One-Two-Two</li>
          <li>1.2.3 Subsubsection One-Two-Three &nbsp; &nbsp;
            <strong>&lt;== Current Position </strong></li>
          <li>1.2.4 Subsubsection One-Two-Four</li>
        </ul>
      </li>
      <li>1.3 Subsection One-Three
        <ul>
          <li>...</li>
        </ul>
      </li>
      <li>1.4 Subsection One-Four</li>
    </ul>
  </li>
</ul>

<hr size="1">
<p>
 <font size="-1">
  This document was generated by <em>Aleksey Cherkes</em> on <em>August, 29 2013</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.70</em></a>.
 </font>
 <br>

</p>
</body>
</html>
